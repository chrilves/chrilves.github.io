<!DOCTYPE html>
<html lang="en" dir="ltr" itemscope itemtype="http://schema.org/Article">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.136.3">
    <meta name="generator" content="Relearn 7.0.1+72a875f1db967152c77914cff4d53f8fcee0e619">
    <meta name="description" content="A short and informal introduction to type theory.">
    <meta name="author" content="chrilves">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Introduction to Types :: @chrilves&#39; Archives">
    <meta name="twitter:description" content="A short and informal introduction to type theory.">
  <meta name="twitter:site" content="@chrilves"/>
    <meta property="og:url" content="https://chrilves.github.io/types/index.html">
    <meta property="og:site_name" content="@chrilves&#39; Archives">
    <meta property="og:title" content="Introduction to Types :: @chrilves&#39; Archives">
    <meta property="og:description" content="A short and informal introduction to type theory.">
    <meta property="og:locale" content="en">
    <meta property="og:type" content="website">
    <meta itemprop="name" content="Introduction to Types :: @chrilves&#39; Archives">
    <meta itemprop="description" content="A short and informal introduction to type theory.">
    <meta itemprop="datePublished" content="2018-12-16T00:00:00+00:00">
    <meta itemprop="dateModified" content="2018-12-16T00:00:00+00:00">
    <meta itemprop="wordCount" content="51">
    <title>Introduction to Types :: @chrilves&#39; Archives</title>
    <link href="https://chrilves.github.io/types/index.html" rel="canonical" type="text/html" title="Introduction to Types :: @chrilves&#39; Archives">
    <link href="../types/index.xml" rel="alternate" type="application/rss+xml" title="Introduction to Types :: @chrilves&#39; Archives">
    <link href="../css/fontawesome-all.min.css?1729680927" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../css/fontawesome-all.min.css?1729680927" rel="stylesheet"></noscript>
    <link href="../css/nucleus.css?1729680927" rel="stylesheet">
    <link href="../css/auto-complete.css?1729680927" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../css/auto-complete.css?1729680927" rel="stylesheet"></noscript>
    <link href="../css/perfect-scrollbar.min.css?1729680927" rel="stylesheet">
    <link href="../css/fonts.css?1729680927" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../css/fonts.css?1729680927" rel="stylesheet"></noscript>
    <link href="../css/theme.css?1729680927" rel="stylesheet">
    <link href="../css/theme-relearn-auto.css?1729680927" rel="stylesheet" id="R-variant-style">
    <link href="../css/chroma-relearn-auto.css?1729680927" rel="stylesheet" id="R-variant-chroma-style">
    <link href="../css/print.css?1729680927" rel="stylesheet" media="print">
    <link href="../css/format-print.css?1729680927" rel="stylesheet">
    <script src="../js/variant.js?1729680927"></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.relBasePath='..';
      window.relearn.relBaseUri='..';
      window.relearn.absBaseUri='https:\/\/chrilves.github.io';
      window.relearn.disableAnchorCopy=false;
      window.relearn.disableAnchorScrolling=false;
      // variant stuff
      window.variants && variants.init( [ 'relearn-auto', 'relearn-light', 'relearn-dark', 'relearn-bright', 'zen-auto', 'zen-light', 'zen-dark', 'retro-auto', 'neon', 'learn', 'blue', 'green', 'red' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script>
  </head>
  <body class="mobile-support print disableInlineCopyToClipboard" data-url="../types/index.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide"><button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)"><i class="fa-fw fas fa-bars"></i></button>
            </div>
            <div class="topbar-button topbar-button-toc" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="Table of Contents (CTRL&#43;ALT&#43;t)"><i class="fa-fw fas fa-list-alt"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper"> 
                </div>
              </div>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">Introduction to Types</span><meta itemprop="position" content="1"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
            <div class="topbar-button topbar-button-edit" data-content-empty="disable" data-width-s="area-more" data-width-m="show" data-width-l="show"><a class="topbar-control" href="https://github.com/chrilves/chrilves.github.io/edit/master/hugo/content/types/_index.md" target="_self" title="Edit (CTRL&#43;ALT&#43;w)"><i class="fa-fw fas fa-pen"></i></a>
            </div>
            <div class="topbar-button topbar-button-print" data-content-empty="disable" data-width-s="area-more" data-width-m="show" data-width-l="show"><a class="topbar-control" href="../types/index.print.html" title="Print whole chapter (CTRL&#43;ALT&#43;p)"><i class="fa-fw fas fa-print"></i></a>
            </div>
            <div class="topbar-button topbar-button-prev" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="../posts/falgebra_scalaio_2017/index.html" title="F-Algebra talk at ScalaIO 2017: Mod√©liser astucieusement vos donn√©es (ü°ê)"><i class="fa-fw fas fa-chevron-left"></i></a>
            </div>
            <div class="topbar-button topbar-button-next" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="../types/1-why/index.html" title="Episode 1 - Why Types? (ü°í)"><i class="fa-fw fas fa-chevron-right"></i></a>
            </div>
            <div class="topbar-button topbar-button-more" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="More"><i class="fa-fw fas fa-ellipsis-v"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper">
                  <div class="topbar-area topbar-area-more" data-area="more">
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable types" tabindex="-1">
        <div class="flex-block-wrapper">
<article class="default">
  <header class="headline">
  </header>

<h1 id="introduction-to-types">Introduction to Types</h1>

<p><strong>Why using</strong> types? <strong>When</strong> are they useful? <strong>Why</strong> we should <strong>care</strong> about types? <strong>What</strong> are types? These are the questions <a href="https://chrilves.github.io/types/" rel="external" target="_self">this series of posts</a> give some answers to.</p>
<div class="children children-h2 children-sort-">
  <h2><a href="../types/1-why/index.html">Episode 1 - Why Types?</a></h2>
  <h2><a href="../types/2-enums/index.html">Episode 2 - Enumerations</a></h2>
  <h2><a href="../types/3-products/index.html">Episode 3 - Products</a></h2>
  <h2><a href="../types/4-coproducts/index.html">Episode 4 - CoProducts</a></h2>
  <h2><a href="../types/5-rectypes/index.html">Episode 5 - Recursive Data Types</a></h2>
</div>

  <footer class="footline">
  </footer>
</article>
          <section>
            <h1 class="a11y-only">Subsections of Introduction to Types</h1>
<article class="default">
  <header class="headline">
  </header>

<h1 id="episode-1---why-types">Episode 1 - Why Types?</h1>

<p><strong>Why using</strong> types? <strong>When</strong> are they useful? <strong>Why</strong> we should <strong>care</strong> about types? <strong>What</strong> are types? These are the questions <a href="https://chrilves.github.io/types/" rel="external" target="_self">this series of posts</a> give some answers to. Let&rsquo;s start by realizing a fundamental fact: <strong>types are everywhere</strong>! Business models are all about types: users, shipments, orders, etc. Placing a user in the cart or shipping a client just makes no sense. <strong>Types are specification</strong>, discriminating what makes sense from what makes not.</p>
<h2 id="a-real-life-example">A real life example</h2>
<p>They can be simple like the well known <em>strings</em>, <em>integers</em>, <em>booleans</em>, <em>lists</em>, <em>chars</em> and <em>floating-point numbers</em>. But these six are far from covering the whole picture. Take as an example, a business application about finding the best deal amount a list of prices expressed in various currencies. To do so it would need currency conversion rates. Which data structure would you use to store these rates? One euro (<code>EUR</code>) worths when i write these lines <em>1.13</em> dollars (<code>USD</code>) which i could represent as the triple <code>(&quot;EUR&quot;, 1.13 ,&quot;USD&quot;)</code>. To store many rates, using a list is straightforward:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">rates</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span> <span class="o">(</span><span class="s">&#34;EUR&#34;</span><span class="o">,</span> <span class="mf">1.13</span><span class="o">,</span> <span class="s">&#34;USD&#34;</span><span class="o">),</span> <span class="o">(</span><span class="s">&#34;GBP&#34;</span><span class="o">,</span>  <span class="mf">142.79</span><span class="o">,</span> <span class="s">&#34;JPY&#34;</span><span class="o">)</span> <span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="n">rates</span><span class="k">:</span> <span class="kt">List</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Double</span>, <span class="kt">String</span><span class="o">)]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">((</span><span class="nc">EUR</span><span class="o">,</span><span class="mf">1.13</span><span class="o">,</span><span class="nc">USD</span><span class="o">),</span> <span class="o">(</span><span class="nc">GBP</span><span class="o">,</span><span class="mf">142.79</span><span class="o">,</span><span class="nc">JPY</span><span class="o">))</span></span></span></code></pre></div>
<p>Are you sure the type <code>(String, Double, String)</code> is a faithful representation for rates? Among all the possible values of this type is <code>(&quot;EUR&quot;, -3.0, &quot;USD&quot;)</code> meaning when you give one euro, you have to <em>pay</em> three dollars more to get nothing. This is silly, currency trading don&rsquo;t work that way. Another problematic value is <code>(&quot;EUR&quot;, 0, &quot;USD&quot;)</code>. What is the point in exchanging one euro for nothing? Using <code>Double</code> to encode rates is wrong as not all <em>floating point number</em> makes a valid rate, only those <em>strictly positive</em>! A faithful representation of rates is the type <code>r:Double{r &gt; 0}</code> which is the types of value <code>r:Double</code> such that <code>r &gt; 0</code>. Such types are called <a href="https://en.wikipedia.org/wiki/Refinement_type" rel="external" target="_self">refinement types</a> and used heavily in <a href="https://www.fstar-lang.org/" rel="external" target="_self">F*</a>.</p>
<p>We&rsquo;re not done yet! Are you sure <code>String</code> is faithful representation of currencies? The empty string <code>&quot;&quot;</code> is not a currency, neither are <code>&quot;‚õ±&quot;</code>, <code>&quot;‚õè&quot;</code>, etc but they are all valid strings. Assuming <code>currencies:Set[String]</code> is the set of all valid currency names, the type of currencies would be <code>cur:String{currencies.contains(cur)}</code> if it was expressible in <em>Scala</em>. But it is in <a href="https://www.fstar-lang.org/" rel="external" target="_self">F*</a>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-ocaml" data-lang="ocaml"><span class="line"><span class="cl"><span class="k">open</span> <span class="nn">FStar</span><span class="p">.</span><span class="nc">Set</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">currencies</span><span class="o">:</span> <span class="n">set</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="k">let</span> <span class="n">currencies</span> <span class="o">=</span> <span class="nn">Set</span><span class="p">.</span><span class="n">as_set</span> <span class="o">[</span><span class="s2">&#34;EUR&#34;</span><span class="o">;</span> <span class="s2">&#34;USD&#34;</span><span class="o">;</span> <span class="s2">&#34;JPY&#34;</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">type</span> <span class="n">currency</span> <span class="o">=</span> <span class="n">cur</span><span class="o">:</span><span class="kt">string</span><span class="o">{</span><span class="nn">Set</span><span class="p">.</span><span class="n">mem</span> <span class="n">cur</span> <span class="n">currencies</span><span class="o">}</span></span></span></code></pre></div>
<p>For the rest of this section, we will assume <em>Scala</em> has refinement types so that we can write:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">type</span> <span class="kt">Rate</span> <span class="o">=</span> <span class="n">r</span><span class="k">:</span><span class="kt">Double</span><span class="o">{</span><span class="kt">r</span> <span class="kt">&gt;</span> <span class="err">0</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">val</span> <span class="kt">currencies:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="nc">Set</span><span class="o">(</span><span class="s">&#34;EUR&#34;</span><span class="o">,</span> <span class="s">&#34;USD&#34;</span><span class="o">,</span> <span class="s">&#34;JPY&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">type</span> <span class="kt">Currency</span> <span class="o">=</span> <span class="n">cur</span><span class="k">:</span><span class="kt">String</span><span class="o">{</span><span class="kt">currencies.contains</span><span class="o">(</span><span class="kt">cur</span><span class="o">)}</span></span></span></code></pre></div>
<p>We&rsquo;re still not done yet as the type <code>(Currency, Rate, Currency)</code> still does not faithfully encode a conversion rate: <code>(&quot;EUR&quot;, 2.0, &quot;EUR&quot;)</code> is a value of this type but one euro can not worth two euros, this would not make sense! We could define the type <code>Rate</code> such that the only possible value is <code>1.0</code> when there is the same currency on both sides, but for simplicity&rsquo;s sake and without loss of generality, we will just forbid converting into the same currency. Once again, in a version of <em>Scala</em> with <em>refinement and dependent types</em>, conversion rates would be:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">ConvRate</span><span class="o">(</span>
</span></span><span class="line"><span class="cl">  <span class="n">from</span><span class="k">:</span> <span class="kt">Currency</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">rate</span><span class="k">:</span> <span class="kt">Rate</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">to</span><span class="k">:</span><span class="kt">Currency</span><span class="o">{</span><span class="kt">from</span> <span class="kt">!=</span> <span class="kt">to</span><span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">)</span></span></span></code></pre></div>
<p>We&rsquo;re almost there! Now every value of <code>ConvRate</code> makes sense from a business perspective: currencies <code>from</code> and <code>to</code> are valid distinct currencies and <code>rate</code> is a strictly positive exchange rate. Does the type <code>List[ConvRate]</code> faithfully represents a valid set of conversion rates? Values like <code>List(ConvRate(&quot;EUR&quot;, 2.0, &quot;USD&quot;), ConvRate(&quot;EUR&quot;, 1.13, &quot;USB&quot;))</code>, where there are several distinct rates for the same conversion, do not make sense. Likewise, there is a relation between a conversion rate and its opposite direction. If one euros worth <code>1.13</code> dollars, then one dollar worths <code>0.88</code> euros. Values like <code>List(ConvRate(&quot;EUR&quot;, 1.13, &quot;USD&quot;), ConvRate(&quot;USD&quot;, 2.0, &quot;EUR&quot;))</code> do not respect this rule, so are invalid business values. To be sure values do respect these <strong>business rules</strong> we can use the data structure <a href="https://www.scala-lang.org/api/2.12.4/scala/collection/immutable/Map.html" rel="external" target="_self">Map</a> and only allow one side of the conversion (<code>from &lt; to</code>) in the type <code>ConversionRates</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">currencies</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="nc">Set</span><span class="o">(</span><span class="s">&#34;EUR&#34;</span><span class="o">,</span> <span class="s">&#34;USD&#34;</span><span class="o">,</span> <span class="s">&#34;JPY&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Conversion</span><span class="o">(</span>
</span></span><span class="line"><span class="cl">  <span class="n">from</span><span class="k">:</span> <span class="kt">String</span><span class="o">{</span><span class="kt">currencies.contains</span><span class="o">(</span><span class="kt">from</span><span class="o">)},</span>
</span></span><span class="line"><span class="cl">  <span class="n">to</span><span class="k">:</span> <span class="kt">String</span><span class="o">{</span><span class="kt">currencies.contains</span><span class="o">(</span><span class="kt">to</span><span class="o">)</span> <span class="kt">&amp;&amp;</span> <span class="kt">from</span> <span class="kt">&lt;</span> <span class="kt">to</span> <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">type</span> <span class="kt">ConversionRates</span> <span class="o">=</span> <span class="nc">Map</span><span class="o">[</span><span class="kt">Conversion</span>, <span class="kt">rate:Double</span><span class="o">{</span><span class="kt">rate</span> <span class="kt">&gt;</span> <span class="err">0</span><span class="o">}]</span></span></span></code></pre></div>
<p>The type <code>ConversionRates</code> is certainly more complex than <code>List[(String, Double, String)]</code> but we gained several major benefits:</p>
<ul>
<li>every piece of code taking <code>ConversionRates</code> <strong>values</strong> as input is sure they <strong>respect business rules</strong>.</li>
<li>every piece of code outputting <code>ConversionRates</code> values is <strong>guaranteed to respect business rules</strong>.</li>
<li><strong>division by zero is impossible!</strong>
<ul>
<li>no need to check!</li>
<li>no risk of exceptions!</li>
<li>no need to write tests!</li>
<li>no need to test the tests!</li>
</ul>
</li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>You may think you are such an excellent developer than all of this is useless because you would never define a negative rate or an empty string currency. But how could you be sure that the previous developers on the project were as perfect as you? Have you written the thousands of tests required to reach the same level of confidence types provide? Will you be happy refactoring those thousands of test every time the specification change? Are you sure you know perfectly every one of the millions ones of the project? Even the one you never had to work with?</p>
<p>If we were as good as we think we are, there would not be null pointer exceptions, segfaults, exploits, undefined-is-not-a-function, <code>java.util.NoSuchElementException: None.get</code> and all the other so common bugs and vulnerabilities we see far too often! Software are complex beasts, made usually by many people, some who leave, some who join. Relying of people being perfect (perfect knowledge, perfect understanding, perfect execution) is not realistic.</p>
<p>You can see type systems as powerful linters whose job is to check your code. Types get more and more complex as business rules do from simple properties to <a href="https://homotopytypetheory.org/book/" rel="external" target="_self">heavy mathematical theorems</a>.</p>
<p><strong>Types are specification</strong>, so in an ideal world a program well-typed would be, by definition, a program without bugs. If you still find bugs in your application, it either means you need to tighten your types to fit the specification or your language&rsquo;s type-system is not expressive enough to encode the specification.</p>
<h2 id="next-episodehttpschrilvesgithubiotypes2-enums"><a href="https://chrilves.github.io/types/2-enums/" rel="external" target="_self">Next Episode</a></h2>
<p>In the <a href="https://chrilves.github.io/types/2-enums/" rel="external" target="_self">next episode</a>, we will see enumerations like you probably have never seen them before.</p>

  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="episode-2---enumerations">Episode 2 - Enumerations</h1>

<p>Now that we know what types are and why there are useful, it is about time to meet some remarkable ones. But before we start, there is some important things to state. As a developer i know how tempting it is to search ready-to-paste answers. But <em>the subject of these post series is nothing like a ready-to-paste answers cookbook</em>. On the contrary, this is a presentation of <strong>deep, difficult but rewarding concepts</strong>. Do not see them as patterns to follow blindly, like it is unfortunately too often the case in our field. Instead, <strong>take the time to develop a deep understanding</strong> of what is really going on.</p>
<p>As such, the example i give may look simple. They are indeed much simpler than in real-life applications. They are not meant to be applicable as-is but to shed light on the core ideas. If you understand the principles they rely on, you&rsquo;ll be able to apply these powerful concepts in your day to day code. <strong>Do not skim through</strong> this but take the time to develop your understanding.</p>
<p>In this whole series is we will assume <code>null</code> (in <em>Scala</em>), <code>undefined</code> (in <em>Haskell</em>) and <a href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)" rel="external" target="_self">side-effects</a> do not exist. <code>null</code>, <code>undefined</code> and <em>side-effects</em> are <em>absurd</em> in every possible way. They make interesting properties collapse and should be <em>avoided at all costs</em>! We will consider all functions from <code>A</code> to <code>B</code> to be <strong>mathematical functions</strong>:</p>
<ul>
<li>they always return a valid value of type <code>B</code> of any input input value of type <code>A</code></li>
<li>on the same argument (or an equal argument), they always return the same result (or an equal result)</li>
<li>the only effect of executing them is obtaining a result, no side-effect allowed</li>
<li>If <code>b:B = f(a:A)</code> we can always replace <code>b</code> by <code>f(a)</code> and vice-versa, anywhere in the program, without altering its behavior (apart from computation time and memory consumption)</li>
</ul>
<p>Formally it means we will consider all functions <a href="https://en.wikipedia.org/wiki/Referential_transparency" rel="external" target="_self">referentially transparent</a> and <a href="https://en.wikipedia.org/wiki/Total_functional_programming" rel="external" target="_self">total</a>. That being said, let the journey begin with a very useful concept.</p>
<h2 id="many-equivalent-ways-to-express-it">Many equivalent ways to express it</h2>
<p>There is often many ways to express the same idea. How would you represent a piece of text? The types <code>List[Char]</code> and <code>String</code> are two different ways to do so. These types are indeed not equal: they are not encoded the same way and have distinct performance properties. But despite their differences, they can be considered equivalent. There is indeed  a one-to-one correspondence between them: we can define two functions <code>list2string: List[Char] =&gt; String</code> and <code>string2list: String =&gt; List[Char]</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">list2string</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">String</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="o">(</span><span class="n">l</span><span class="k">:</span><span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="n">l</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="s">&#34;&#34;</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="o">(</span><span class="n">str</span><span class="o">,</span><span class="n">char</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">s&#34;</span><span class="si">$str$char</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">string2list</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="o">(</span><span class="n">str</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">str</span><span class="o">.</span><span class="n">toList</span></span></span></code></pre></div>
<p>such that <code>list2string</code> and <code>string2list</code> are the <strong>inverse of each other</strong>
</p>
$$\forall s:\texttt{String},\quad \texttt{string2list}(\texttt{list2string}(s)) = s$$$$\forall l:\texttt{List[Char]},\quad \texttt{list2string}(\texttt{string2list}(l)) = l$$<p>which also means</p>
<ul>
<li>
<p>for any list there is a unique string </p>
$$\forall l:\texttt{List[Char]}\ \exists! s:\texttt{String}  ,\quad \texttt{string2list}(s) = l$$</li>
<li>
<p>for any string there is a unique list </p>
$$\forall s:\texttt{String}\ \exists! l:\texttt{List[Char]},\quad \texttt{string2list}(\texttt{list2string}(s)) = s$$</li>
<li>
<p><code>list2string</code> and <code>string2list</code> are <strong>injective</strong>
</p>
$$\forall l1, l2:\texttt{List[Char]},\ \texttt{list2string}(l1) = \texttt{list2string}(l2) \implies l1 = l2$$$$\forall s1, s2:\texttt{String},\ \texttt{string2list}(s1) = \texttt{string2list}(s2) \implies s1 = s2$$</li>
</ul>
<p>Basically it means we can always convert from one type to the other without loss of generality.</p>
<blockquote>
<p>For any function <code>f: A =&gt; B</code> (i.e. from <code>A</code> to <code>B</code>), <code>f</code> is called a <strong>bjection</strong> <em>if and only if</em> there exists a function <code>g: B =&gt; A</code> (i.e. from <code>B</code> to <code>A</code>) such that <code>f</code> and <code>g</code> are <em>inverse of each other</em>:
</p>
$$\forall a:\texttt{A},\quad \texttt{g}(\texttt{f}(a)) = a$$$$\forall b:\texttt{B},\quad \texttt{f}(\texttt{g}(b)) = b$$<p>
Two types <code>A</code> and <code>B</code> are called <strong>equivalent</strong>, which is written <code>A ‚âÖ B</code>, <em>if and only if</em> there exists a <em>bijection</em> <code>f: A =&gt; B</code>.</p>
</blockquote>
<p>This notion is <em>fundamental</em> as it tells us that similarity between types is how closely they behave, not how closely they look. Two types of apparent very different form may actually be equivalent while two whose form may seem close may be fundamentally at odds. Focus on properties, not on looks.</p>
<h2 id="the-empty-type">The empty type</h2>
<p>The first type i want to present has many names. <a href="https://www.scala-lang.org" rel="external" target="_self">Scala</a> names it <code>Nothing</code>, <a href="https://elm-lang.org" rel="external" target="_self">Elm</a> calls it <code>Never</code>, <a href="https://coq.inria.fr" rel="external" target="_self">Coq</a> uses the name it usually has in <a href="https://en.wikipedia.org/wiki/Proof_theory" rel="external" target="_self">Proof Theory</a> which is <code>False</code> while <a href="https://en.wikipedia.org/wiki/Type_theory" rel="external" target="_self">Type Theory</a> refers to it as <code>0</code>. This is an <strong>uninhabited type</strong> which means there is no value of this type. You may look at it as the empty set (hence the name <code>0</code>):</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">final</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">False</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">A</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p>This class being <code>final</code> we cannot define sub-classes, but being also <code>abstract</code> we cannot instantiate it either! And even if we could, how would we write a function <code>fold</code> which meets the specification that it provides a value of type <code>A</code> for any <code>A</code>? Remember, <code>null</code> does not exists.</p>
<p>How a type without values can be useful? By representing impossible cases in the type-system. Let <code>v</code> be a value of type <code>Either[False, Int]</code>. <code>v</code> has to be <code>Right(i)</code> for some integer <code>i</code> because otherwise it would be <code>Left(f)</code> for some value <code>f</code> of type <code>False</code> which is impossible! It means the following pattern-matching is exhaustive.</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">extractRight</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">v</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">False</span>,<span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">v</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">Right</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
<p>Unfortunately <em>Scala</em> protests it&rsquo;s not, demanding we cover the case <code>v = Left(f: False)</code> by returning a value of type <code>A</code>. We know, assuming <code>null</code> does not exists, there can not be such a value <code>f:False</code>. How to make <em>Scala</em> happy? Fortunately, every hypothetical value of type <code>False</code> comes with a handy <code>fold</code> function able to return anything. It corresponds in logic to <a href="https://en.wikipedia.org/wiki/Principle_of_explosion" rel="external" target="_self">the principle of explosion</a> stating that from a contradicton (having a value of an empty type for example), you can conclude anything:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">extractRight</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">v</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">False</span>,<span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">v</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">Right</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">Left</span><span class="o">(</span><span class="n">f</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">fold</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
<p>Note that <code>extractRight</code> and <code>Right:A =&gt; Either[False, A]</code> being <em>inverse functions</em> it means <code>Either[False, A]</code> is equivalent to <code>A</code>. This one is of the main properties of <code>False</code>: <code>Either[False, A]</code>, <code>Either[A, False]</code> and <code>A</code> are all equivalent (i.e. <code>Either[False, A] ‚âÖ A ‚âÖ Either[A, False]</code>).</p>
<p>You could argue using <code>Either[False, A]</code> is pointless as it is equivalent to <code>A</code> which is true, but bare in mind it is just a toy example. A more realistic one would involve complex types such as bifunctors like <code>IO[E,A]</code>. The ability to express impossible cases let us write <em>IO</em> computations that never fails <code>IO[False, A]</code> and <em>IO</em> computation that never returns <code>IO[E,False]</code> with the same code and <a href="https://en.wikipedia.org/wiki/Application_programming_interface" rel="external" target="_self">API</a> instead of relying on code/API duplication which is a <em>waste of time, effort and complexity</em>.</p>
<p>The idea being <code>False</code> can be <em>expressed in many equivalent ways</em>. The three types <code>False</code>, <code>FalseInd</code> and <code>FalseFun</code> are equivalent (``False ‚âÖ FalseInd ‚âÖ FalseFun`):</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">final</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">FalseInd</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">trait</span> <span class="nc">FalseFun</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">A</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p>This is even clearer in <a href="https://www.haskell.org/ghc" rel="external" target="_self">Haskell</a> as shown below where <code>ind2fun</code> and <code>fun2ind</code> are <em>inverse functions</em>.</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="cm">{-# LANGUAGE RankNTypes, EmptyCase #-}</span>
</span></span><span class="line"><span class="cl"><span class="kr">module</span> <span class="nn">Iso</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">data</span> <span class="kt">FalseInd</span>
</span></span><span class="line"><span class="cl"><span class="kr">type</span> <span class="kt">FalseFun</span> <span class="ow">=</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">ind2fun</span> <span class="ow">::</span> <span class="kt">FalseInd</span> <span class="ow">-&gt;</span> <span class="kt">FalseFun</span>
</span></span><span class="line"><span class="cl"><span class="nf">ind2fun</span> <span class="n">x</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">x</span> <span class="kr">of</span> <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">fun2ind</span> <span class="ow">::</span> <span class="kt">FalseFun</span> <span class="ow">-&gt;</span> <span class="kt">FalseInd</span>
</span></span><span class="line"><span class="cl"><span class="nf">fun2ind</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span></span></span></code></pre></div>
<p>In <em>Scala</em> like in <em>Haskell</em> <code>FalseInd</code> express the idea of a <strong>data type with no constructor</strong> (i.e. to way to build a value) while <code>FalseFun</code> is the <strong>type of a function</strong> with no argument (i.e. a constant) returning values of type <code>A</code> for any <code>A</code>, but such a function does not exists. It may seem weird having functions between empty types but it actually makes a lot of sense: there is indeed a one-to-one correspondence between these two types as both have no values at all.</p>
<h2 id="the-singleton-type">The singleton type</h2>
<p>Often called <code>unit</code>, <code>()</code> or <code>1</code>, it is the type with <strong>only one value</strong>.</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Unit</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">Unique</span> <span class="k">=&gt;</span> <span class="n">x</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">Unique</span> <span class="k">extends</span> <span class="nc">Unit</span></span></span></code></pre></div>
<p>Note that the type <code>Unit</code> admits <em>one and exactly one value</em> which is <code>UniqueInd</code>. <code>UniqueInd</code> is called a <strong>constructor of the data type <code>Unit</code></strong> as it one way (the only one actually) to build a value of type <code>Unit</code>. <code>Unit</code> is useful everywhere you have to fill a value and/or a type but you actually don&rsquo;t care which. For example, let <code>v = println(&quot;Hello World&quot;):IO[Unit]</code> be the value printing a message to the screen. We don&rsquo;t care what the execution <code>v</code> returns, we are only interested into what is printed, but it still needs to return something for the program to continue.</p>
<p>Once again <code>Unit</code> can be <em>equivalently expressed</em> as both the data type <code>UnitInd</code> and the <em>function type</em> <code>UnitFun</code>. Indeed <code>ind2fun</code> and <code>fun2ind</code> are <em>inverse functions</em> showing <code>Unit ‚âÖ UnitInd ‚âÖ UnitFun</code>.</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">UnitInd</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">UniqueInd</span> <span class="k">extends</span> <span class="nc">UnitInd</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">trait</span> <span class="nc">UnitFun</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">uniqueFun</span><span class="k">:</span> <span class="kt">UnitFun</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="k">new</span> <span class="nc">UnitFun</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">x</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">ind2fun</span><span class="k">:</span> <span class="kt">UnitInd</span> <span class="o">=&gt;</span> <span class="nc">UnitFun</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">UnitInd</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">i</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">UniqueInd</span> <span class="k">=&gt;</span> <span class="n">uniqueFun</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">fun2ind</span><span class="k">:</span> <span class="kt">UnitFun</span> <span class="o">=&gt;</span> <span class="nc">UnitInd</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">UnitFun</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">fold</span><span class="o">[</span><span class="kt">UnitInd</span><span class="o">](</span><span class="nc">UniqueInd</span><span class="o">)</span></span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">data</span> <span class="kt">UnitInd</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  <span class="kt">UniqueInd</span> <span class="ow">::</span> <span class="kt">UnitInd</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">type</span> <span class="kt">UnitFun</span> <span class="ow">=</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">uniqueFun</span> <span class="ow">::</span> <span class="kt">UnitFun</span>
</span></span><span class="line"><span class="cl"><span class="nf">uniqueFun</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">ind2fun</span> <span class="ow">::</span> <span class="kt">UnitInd</span> <span class="ow">-&gt;</span> <span class="kt">UnitFun</span>
</span></span><span class="line"><span class="cl"><span class="nf">ind2fun</span> <span class="kt">UniqueInd</span> <span class="ow">=</span> <span class="n">uniqueFun</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">fun2ind</span> <span class="ow">::</span> <span class="kt">UnitFun</span> <span class="ow">-&gt;</span> <span class="kt">UnitInd</span>
</span></span><span class="line"><span class="cl"><span class="nf">fun2ind</span> <span class="n">u</span> <span class="ow">=</span> <span class="n">u</span> <span class="kt">UniqueInd</span></span></span></code></pre></div>
<p>The type <code>UnitFun</code> may surprise you. How is it possible that a function type like it has only one possible value? <strong>Try</strong> to write a <em>referentially transparent</em> and <em>total</em> instance of <code>UnitFun</code>. You will see there is only one way to do so.</p>
<p>One of the main properties of <code>Unit</code> is that <code>(Unit, A)</code>, <code>(A, Unit)</code> and <code>A</code> are equivalent (i.e. <code>(Unit, A) ‚âÖ A ‚âÖ (A, Unit)</code>). <em>Exercise: write the inverse functions between these types.</em></p>
<h2 id="the-two-values-type-booleans">The two values type: Booleans</h2>
<p>Here comes one of the most well known type: the one with <strong>exactly two values</strong> often called <code>Boolean</code> in programming and <code>2</code> in <em>Type Theory</em>. Its values are generally named <code>true</code> and <code>false</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Boolean</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">tt</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">ff</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">True</span>  <span class="k">=&gt;</span> <span class="n">tt</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">False</span> <span class="k">=&gt;</span> <span class="n">ff</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">True</span>  <span class="k">extends</span> <span class="nc">Boolean</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">False</span> <span class="k">extends</span> <span class="nc">Boolean</span></span></span></code></pre></div>
<p>I&rsquo;m sure you&rsquo;re already familiar with booleans, but did you recognize the <code>fold</code> function? It is generally named <code>if-then-else</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">ifThenElse</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">b</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)(</span><span class="n">tt</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">ff</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">fold</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">tt</span><span class="o">,</span> <span class="n">ff</span><span class="o">)</span></span></span></code></pre></div>
<p><code>True</code> and <code>False</code> are called the <strong>constructors of <code>Boolean</code></strong> because they are the <strong>only way to build values</strong> of type <code>Boolean</code>. Once again this idea of a type with two values is <em>equivalently expressed</em> both as the <em>data type</em> <code>BoolInd</code> and as the <em>function type</em> <code>BoolFun</code> . Functions <code>ind2fun</code> and <code>fun2ind</code> are indeed <em>inverse</em> of each other.</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">BoolInd</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">TrueInd</span>  <span class="k">extends</span> <span class="nc">BoolInd</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">FalseInd</span> <span class="k">extends</span> <span class="nc">BoolInd</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">trait</span> <span class="nc">BoolFun</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">tt</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">ff</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">trueFun</span><span class="k">:</span> <span class="kt">BoolFun</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="k">new</span> <span class="nc">BoolFun</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">tt</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">ff</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">tt</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">falseFun</span><span class="k">:</span> <span class="kt">BoolFun</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="k">new</span> <span class="nc">BoolFun</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">tt</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">ff</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">ff</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">ind2fun</span><span class="k">:</span> <span class="kt">BoolInd</span> <span class="o">=&gt;</span> <span class="nc">BoolFun</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">BoolInd</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">i</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">TrueInd</span>  <span class="k">=&gt;</span> <span class="n">trueFun</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">FalseInd</span> <span class="k">=&gt;</span> <span class="n">falseFun</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">fun2ind</span><span class="k">:</span> <span class="kt">BoolFun</span> <span class="o">=&gt;</span> <span class="nc">BoolInd</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">BoolFun</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">fold</span><span class="o">[</span><span class="kt">BoolInd</span><span class="o">](</span><span class="nc">TrueInd</span><span class="o">,</span> <span class="nc">FalseInd</span><span class="o">)</span></span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">data</span> <span class="kt">BoolInd</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  <span class="kt">TrueInd</span>  <span class="ow">::</span> <span class="kt">BoolInd</span>
</span></span><span class="line"><span class="cl">  <span class="kt">FalseInd</span> <span class="ow">::</span> <span class="kt">BoolInd</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">type</span> <span class="kt">BoolFun</span> <span class="ow">=</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="n">a</span> <span class="ow">-&gt;</span>  <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">trueFun</span> <span class="ow">::</span> <span class="kt">BoolFun</span>
</span></span><span class="line"><span class="cl"><span class="nf">trueFun</span> <span class="n">tt</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">tt</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">falseFun</span> <span class="ow">::</span> <span class="kt">BoolFun</span>
</span></span><span class="line"><span class="cl"><span class="nf">falseFun</span> <span class="kr">_</span> <span class="n">ff</span> <span class="ow">=</span> <span class="n">ff</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">ind2fun</span> <span class="ow">::</span> <span class="kt">BoolInd</span> <span class="ow">-&gt;</span> <span class="kt">BoolFun</span>
</span></span><span class="line"><span class="cl"><span class="nf">ind2fun</span> <span class="kt">TrueInd</span>  <span class="ow">=</span> <span class="n">trueFun</span>
</span></span><span class="line"><span class="cl"><span class="nf">ind2fun</span> <span class="kt">FalseInd</span> <span class="ow">=</span> <span class="n">falseFun</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">fun2ind</span> <span class="ow">::</span> <span class="kt">BoolFun</span> <span class="ow">-&gt;</span> <span class="kt">BoolInd</span>
</span></span><span class="line"><span class="cl"><span class="nf">fun2ind</span> <span class="n">u</span> <span class="ow">=</span> <span class="n">u</span> <span class="kt">TrueInd</span> <span class="kt">FalseInd</span></span></span></code></pre></div>
<p>Once again the type <code>BoolFun</code> may surprise you. Once again <strong>try</strong> to write a <em>referentially transparent</em> and <em>total</em> instance of <code>BoolFun</code>. You will see there are only two ways to do so.</p>
<p>I could continue forever presenting types with <em>3</em>, <em>4</em>, &hellip; values but by now you must see the same pattern repeating and repeating again.</p>
<h2 id="next-episode-productshttpschrilvesgithubiotypes3-products"><a href="https://chrilves.github.io/types/3-products/" rel="external" target="_self">Next Episode: Products</a></h2>
<p>In the <a href="https://chrilves.github.io/types/3-products/" rel="external" target="_self">next episode</a>, we will a convenient way to combine types: <strong>Products</strong>.</p>

  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="episode-3---products">Episode 3 - Products</h1>

<p>Products, often called <em>tuples</em>, <em>records</em> or <strong>case classes</strong>, are a convenient way to bundle values of different types into a single value. The <strong>product</strong> of <code>n</code> types (with <code>n</code> being <em>0</em>, <em>1</em>, <em>2</em>, etc) <code>A_1</code>, <code>A_2</code>, &hellip;, <code>A_n</code> is precisely the type whose values are formed with exactly one value of each type <code>A_i</code> for <code>1 ‚â§ i ‚â§  n</code>. It is written <code>(A_1, A_2, ..., A_n)</code> in many languages, <code>Product_n[A_1, A_2, ..., A_n]</code> in <em>Scala</em> and <code>A_1 √ó ... √ó A_n</code> in <em>Type Theory</em>. As an example, the product of two types <code>A</code> and <code>B</code> would be defined as</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Product2</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">R</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">R</span><span class="o">)</span><span class="k">:</span> <span class="kt">R</span> <span class="o">=</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">data</span> <span class="kt">Product2</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Constructor</span> <span class="n">a</span> <span class="n">b</span></span></span></code></pre></div>
<p>Although in practice this is the preferred way to define the product of two types <code>A</code> and <code>B</code>, we will in this presentation prefer the <strong>equivalent</strong> definition below:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Product2</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">C</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">C</span><span class="o">)</span><span class="k">:</span> <span class="kt">C</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">Constructor</span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Constructor</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Product2</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span></span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">data</span> <span class="kt">Product2</span> <span class="n">a</span> <span class="n">b</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  <span class="kt">Constructor</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Product2</span> <span class="n">a</span> <span class="n">b</span></span></span></code></pre></div>
<p>This <em>equivalent definition</em> makes clear the distinction between the type <code>Product2[A,B]</code> and the <strong>constructor</strong> <code>Constructor[A,B]</code>.  the constructor is a <strong>function</strong> taking as argument one value of type <code>A</code>, another value of type <code>B</code> and returning a value of type <code>Product2[A,B]</code>. Its type in <em>Haskell</em> is <code>A -&gt; B -&gt; Product2 A B</code> and in <em>Scala</em> <code>(A, B) =&gt; Product2[A,B]</code>. Note than in <em>Scala</em> functions of type <code>(A, B) =&gt; C</code> are functions of <strong>two arguments</strong> (precisely <code>Function2[A,B,C]</code>) and <strong>not of one argument</strong> <code>(A,B)</code> (which would be <code>Function1[(A,B), C]</code>):</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Constructor</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">_</span> <span class="k">:</span> <span class="o">(</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">String</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="nc">Product2</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">]</span> <span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="n">res0</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Product2</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">$$Lambda$1620</span><span class="o">/</span><span class="mi">2032136633</span><span class="k">@</span><span class="mi">55</span><span class="n">be2608</span></span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">Constructor</span>
</span></span><span class="line"><span class="cl"><span class="kt">Constructor</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Product2</span> <span class="n">a</span> <span class="n">b</span></span></span></code></pre></div>
<p>Besides, by definition <strong>constructors are injective functions</strong>, which means that for any values <code>a1:A</code>, <code>a2:A</code>, <code>b1:B</code> and <code>b2:B</code>, <code>Constructor[A,B](a1,b1) == Constructor[A,B](a2,b2)</code> <em>if and only if</em> <code>a1 == a2</code> and <code>b1 == b2</code>
</p>
$$\forall a1,\ a2:\texttt{A},\ b1,\ b2:\texttt{B},\quad \texttt{Constructor[A,B]}(a1,b1) = \texttt{Constructor[A,B]}(a2,b2) \Longleftrightarrow a1 = a2 \textbf{ and } b1 = b2$$<p>Besides, <code>Constructor[A,B]</code> being the <em>only constructor</em> of <code>Product2[A,B]</code> then for any value <code>v</code> of type <code>Product2[A,B]</code>, there is a unique value <code>a</code> of type <code>A</code> and a unique value <code>b</code> of type <code>B</code> such that <code>v = Constructor[A,B](a,b)</code>
</p>
$$\forall v:\texttt{Product2[A,B]}\ \exists!\ (a:\texttt{A} \textrm{ and } b:\texttt{B}),\quad v = \texttt{Constructor[A,B]}(a,b)$$<h2 id="equivalence-of-inductive-and-functional-forms">Equivalence of inductive and functional forms</h2>
<p>Once again any product can be <em>equivalently expressed</em> as a <em>data type</em> <code>Product_n_Ind[A_1, ..., A_n]</code> and as a <em>function type</em> <code>Product_n_Fun[A_1, ..., A_n]</code> with <em>inverse functions</em> <code>ind2fun</code> and <code>fun2ind</code> converting back and forth types <code>Product_n_Ind[A_1, ..., A_n]</code> and <code>Product_n_Fun[A_1, ..., A_n]</code>. For example with <code>n = 2</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Product2Ind</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">ConstructorInd</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Product2Ind</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">trait</span> <span class="nc">Product2Fun</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">C</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">C</span><span class="o">)</span><span class="k">:</span> <span class="kt">C</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">constructorFun</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Product2Fun</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="k">new</span> <span class="nc">Product2Fun</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">C</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">C</span><span class="o">)</span><span class="k">:</span> <span class="kt">C</span> <span class="o">=</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">ind2fun</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span><span class="k">:</span> <span class="kt">Product2Ind</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Product2Fun</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Product2Ind</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">])</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="n">i</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">ConstructorInd</span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">constructorFun</span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">fun2ind</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span><span class="k">:</span> <span class="kt">Product2Fun</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Product2Ind</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Product2Fun</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">fold</span><span class="o">[</span><span class="kt">Product2Ind</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]](</span><span class="nc">ConstructorInd</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">_</span><span class="o">)</span></span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">data</span> <span class="kt">Product2Ind</span> <span class="n">a</span> <span class="n">b</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  <span class="kt">ConstructorInd</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Product2Ind</span> <span class="n">a</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">type</span> <span class="kt">Product2Fun</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">forall</span> <span class="n">c</span><span class="o">.</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">c</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">constructorFun</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Product2Fun</span> <span class="n">a</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl"><span class="nf">constructorFun</span> <span class="n">a</span> <span class="n">b</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">ind2fun</span> <span class="ow">::</span> <span class="kt">Product2Ind</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Product2Fun</span> <span class="n">a</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl"><span class="nf">ind2fun</span> <span class="p">(</span><span class="kt">ConstructorInd</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="n">constructorFun</span> <span class="n">a</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">fun2ind</span> <span class="ow">::</span> <span class="kt">Product2Fun</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Product2Ind</span> <span class="n">a</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl"><span class="nf">fun2ind</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">f</span> <span class="kt">ConstructorInd</span></span></span></code></pre></div>
<h2 id="generalization-to-a-product-of-any-number-of-types">Generalization to a product of any number of types</h2>
<p>The definition of <code>Product2</code> above can be adapted to <code>Product_n[A_1, ..., A_n]</code> for any value of <code>n</code> (i.e. <em>0</em>, <em>1</em>, <em>2</em>, <em>3</em>, <em>4</em>, &hellip;). With <code>n = 0</code>, which means a product of zero types, the constructor takes zero argument, which means it is a constant. Thus <code>Product_0</code> is equivalent to <code>Unit</code> (i.e. <code>Product_0 ‚âÖ Unit</code>). This is the reason why <code>Unit</code> is sometimes written <code>()</code>. With <code>n = 1</code>, <code>Product_n[A] ‚âÖ A</code>.</p>
<p>Further more for any types <code>A</code>, <code>B</code> and <code>C</code> we have the following properties</p>
<ul>
<li><code>(A , B)</code> is equivalent to <code>(B , A)</code></li>
<li><code>((A, B), C)</code> and <code>(A, (B, C))</code> and <code>(A, B, C)</code> are all equivalent</li>
<li><code>(Unit, A)</code> and  <code>(A, Unit)</code> and <code>A</code> are all equivalent</li>
<li><code>(A)</code> is equivalent to <code>A</code></li>
<li><code>(False, A)</code> and <code>(A, False)</code> and <code>False</code> are all equivalent</li>
</ul>
<p><em>Exercise: write conversion functions <code>from</code> and <code>to</code>for each of these equivalence, such that <code>from</code> and <code>to</code> are inverse functions.</em></p>
<h2 id="next-episode-coproductshttpschrilvesgithubiotypes4-coproducts"><a href="https://chrilves.github.io/types/4-coproducts/" rel="external" target="_self">Next Episode: CoProducts</a></h2>
<p>In the <a href="https://chrilves.github.io/types/4-coproducts/" rel="external" target="_self">next episode</a>, we will a convenient way to express alternatives: <strong>CoProducts</strong>.</p>

  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="episode-4---coproducts">Episode 4 - CoProducts</h1>

<p>CoProducts, often called <em>sum types</em>, <em>discriminated unions</em> or <em>disjoint unions</em>, are a convenient way to express an alternative between different types. The <strong>coproduct</strong> of <code>n</code> types (with <code>n</code> being <em>0</em>, <em>1</em>, <em>2</em>, etc) <code>A_1</code>, <code>A_2</code>, &hellip;, <code>A_n</code> is precisely the type whose values are <code>(i, a_i)</code> where <code>i</code> is a number, called the <strong>tag</strong>, between <code>1</code> and <code>n</code> both included (<code>1 ‚â§ i ‚â§  n</code>) and <code>a_i</code> is a value of type <code>A_i</code> (the actual type then depends on the value of <code>i</code>). Is is often written <code>Either[A_1, ..., A_n]</code> in programming and <code>A_1 + ... + A_n</code> in <em>Type Theory</em>.</p>
<p>Let&rsquo;s take, as an example, <code>n = 4</code>, <code>A_1 = Char</code>, <code>A_2 = Boolean</code>, <code>A_3 = Char</code> and <code>A_4 = Double</code>. The following values are all <strong>valid and distinct</strong> values of type <code>Either4[Char, Boolean, Char, Double]</code>: <code>(1, 'C')</code>, <code>(2, true)</code>, <code>(3, 'D')</code>, <code>(4, 3.2)</code>, <code>(3, 'C')</code>. Note that <code>(1, 'C')</code> and <code>(3, 'C')</code> are different values because the <em>tag</em> is different.</p>
<p>Instead of writing the <em>tag</em> explicitly, programming languages often let us write <code>n</code> <strong>constructors</strong>: <code>Inj_i: A_i =&gt; Either_n[A_1, ..., A_n]</code> such that
</p>
$$\forall i\in{1,\dots,n},\quad \texttt{Inj}_i : \texttt{A}_i \rightarrow \texttt{Either}_n[\texttt{A}_1,\dots,\texttt{A}_n]$$$$\forall i\in{1,\dots,n},\quad \forall a_i:\texttt{A}_i,\quad \texttt{Inj}_i(a_i) = (i, a_i)$$<p>Note that:</p>
<ul>
<li>As usual <strong>constructors are injective</strong> functions
$$\forall i\in{1,\dots,n},\quad \forall a_i,a'_i:\texttt{A}_i,\quad \texttt{Inj}_i(a_i) = \texttt{Inj}_i(a'_i) \Leftrightarrow a_i = a'_i$$</li>
<li>The <strong>only way to get a value</strong> of type <code>Either_n[A_1, ... , A_n]</code> is by using one of the constructors
$$\forall v:\texttt{Either}_n[\texttt{A}_1,\dots,\texttt{A}_n],\quad \exists! i\in{1,\dots,n},\quad \texttt{Inj}_i(a_i) = v$$</li>
<li>Two <strong>different constructors produce different values</strong> (hense the <em>disjoint</em> and <em>discriminated</em> unions)
$$\forall i,j\in{1,\dots,n},\quad \forall a_i:\texttt{A}_i,\quad \forall a_j:\texttt{A}_j,\quad \texttt{Inj}_i(a_i) = \texttt{Inj}_j(a_j) \Leftrightarrow i = j \textbf{ and } a_i = a_j$$</li>
</ul>
<p>For example with <code>n = 2</code>, the <em>coproduct</em> of two types <code>A</code> and <code>B</code> is defined as</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Either2</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">R</span><span class="o">](</span><span class="n">inj1</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">R</span><span class="o">,</span> <span class="n">inj2</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">R</span><span class="o">)</span><span class="k">:</span> <span class="kt">R</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">Inj1</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">inj1</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">Inj2</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">inj2</span><span class="o">(</span><span class="n">b</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Inj1</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Either2</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Inj2</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Either2</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span></span></span></code></pre></div>
<p>Saying the pattern matching above is exhaustive is exactly equivalent to say a value of type <code>Either2[A,B]</code> has to be either <code>Inj1(a)</code> for some <code>a:A</code> or <code>Inj2(b)</code> for some <code>b:B</code>. Requiring that <code>Inj1</code> and <code>Inj2</code> produce different values is also mandatory as <code>Eirher2[Error, Result]</code> is often used to model computation that may fail. A failed computation would produce a <code>Inj1(e)</code> with <code>e</code> being the error that occurred while a successful computation would produce a <code>Inj2(r)</code> with <code>r</code> the result of the computation. We want to be able to discriminate these two cases, even when the types <code>Error</code> and <code>Result</code> are the same as it is usually the case when the computation need to compute a string or fail with an error message. Likewise, the injectivity of the constructors is mandatory to be able to the result produced <code>r</code> or the error that occurred <code>e</code>.</p>
<h2 id="equivalence-of-inductive-and-functional-forms">Equivalence of inductive and functional forms</h2>
<p>Once again any *coproduct√π can be <em>equivalently expressed</em> as a <em>data type</em> <code>Either_n_Ind[A_1, ..., A_n]</code> and as a <em>function type</em> <code>Either_n_Fun[A_1, ..., A_n]</code> with <em>inverse functions</em> <code>ind2fun</code> and <code>fun2ind</code> converting back and forth types <code>Either_n_Ind[A_1, ..., A_n]</code> and <code>Either_n_Fun[A_1, ..., A_n]</code>. For example with <code>n = 2</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Either2Ind</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Inj1_Ind</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Either2Ind</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Inj2_Ind</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Either2Ind</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">trait</span> <span class="nc">Either2Fun</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">R</span><span class="o">](</span><span class="n">inj1</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">R</span><span class="o">,</span> <span class="n">inj2</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">R</span><span class="o">)</span><span class="k">:</span> <span class="kt">R</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">inj1_fun</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Either2Fun</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="k">new</span> <span class="nc">Either2Fun</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">R</span><span class="o">](</span><span class="n">inj1</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">R</span><span class="o">,</span> <span class="n">inj2</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">R</span><span class="o">)</span><span class="k">:</span> <span class="kt">R</span> <span class="o">=</span> <span class="n">inj1</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">inj2_fun</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="nc">Either2Fun</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="k">new</span> <span class="nc">Either2Fun</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">R</span><span class="o">](</span><span class="n">inj1</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">R</span><span class="o">,</span> <span class="n">inj2</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">R</span><span class="o">)</span><span class="k">:</span> <span class="kt">R</span> <span class="o">=</span> <span class="n">inj2</span><span class="o">(</span><span class="n">b</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">ind2fun</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span><span class="k">:</span> <span class="kt">Either2Ind</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Either2Fun</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Either2Ind</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">])</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="n">i</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">Inj1_Ind</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">inj1_fun</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">Inj2_Ind</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">inj2_fun</span><span class="o">(</span><span class="n">b</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">fun2ind</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span><span class="k">:</span> <span class="kt">Either2Fun</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Either2Ind</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Either2Fun</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">])</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="n">f</span><span class="o">.</span><span class="n">fold</span><span class="o">[</span><span class="kt">Either2Ind</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]](</span><span class="nc">Inj1_Ind</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">_</span><span class="o">,</span> <span class="nc">Inj2_Ind</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">_</span><span class="o">)</span></span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">data</span> <span class="kt">Either2Ind</span> <span class="n">a</span> <span class="n">b</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl"> <span class="kt">Inj1_Ind</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Either2Ind</span> <span class="n">a</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl"> <span class="kt">Inj2_Ind</span> <span class="ow">::</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Either2Ind</span> <span class="n">a</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">type</span> <span class="kt">Either2Fun</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">forall</span> <span class="n">c</span><span class="o">.</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">c</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">inj1_fun</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Either2Fun</span> <span class="n">a</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl"><span class="nf">inj1_fun</span> <span class="n">a</span> <span class="n">f</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">inj2_fun</span> <span class="ow">::</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Either2Fun</span> <span class="n">a</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl"><span class="nf">inj2_fun</span> <span class="n">b</span> <span class="kr">_</span> <span class="n">g</span> <span class="ow">=</span> <span class="n">g</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">ind2fun</span> <span class="ow">::</span> <span class="kt">Either2Ind</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Either2Fun</span> <span class="n">a</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl"><span class="nf">ind2fun</span> <span class="p">(</span><span class="kt">Inj1_Ind</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="n">inj1_fun</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl"><span class="nf">ind2fun</span> <span class="p">(</span><span class="kt">Inj2_Ind</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="n">inj2_fun</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">fun2ind</span> <span class="ow">::</span> <span class="kt">Either2Fun</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Either2Ind</span> <span class="n">a</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl"><span class="nf">fun2ind</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">f</span> <span class="kt">Inj1_Ind</span> <span class="kt">Inj2_Ind</span></span></span></code></pre></div>
<h2 id="generalization-to-a-product-of-any-number-of-types">Generalization to a product of any number of types</h2>
<p>The definition of <code>Either2</code> above can be adapted to <code>Either_n[A_1, ..., A_n]</code> for any value of <code>n</code> (i.e. <em>0</em>, <em>1</em>, <em>2</em>, <em>3</em>, <em>4</em>, &hellip;). With <code>n = 0</code>, which means a coproduct of zero types, there is no constructor, which means it is impossible to build a value of this type. Thus <code>Either_0</code> is equivalent to <code>False</code> (i.e. <code>Either_0 ‚âÖ False</code>). With <code>n = 1</code>, <code>Either_n[A] ‚âÖ A</code>.</p>
<p>Further more for any types <code>A</code>, <code>B</code> and <code>C</code> we have the following properties</p>
<ul>
<li><code>Either2[A,B]</code> is equivalent to <code>Either2[B,A]</code></li>
<li><code>Either2[Either2[A,B], C]</code> and <code>Either2[A, Either2[B,C]]</code> and <code>Either3[A,B,C]</code> are all equivalent</li>
<li><code>Eithr2[False,A]</code> and  <code>Either2[A,False]</code> and <code>A</code> are all equivalent</li>
<li><code>Either_1[A]</code> is equivalent to <code>A</code></li>
<li><code>(C, Either2[A,B])</code> is equivalent to <code>Either2[(C,A), (C,B)]</code></li>
</ul>
<p><em>Exercise: write conversion functions <code>from</code> and <code>to</code>for each of these equivalence, such that <code>from</code> and <code>to</code> are inverse functions.</em></p>
<p>Remember that in <em>Type Theory</em>, <code>False</code> is written <code>0</code>, <code>Unit</code> is written <code>1</code>, the <em>product</em> <code>(A_1, ..., A_n)</code> is written <code>A_1 √ó ... A_n</code> and the <em>coproduct</em> <code>Either_n[A_1, ..., A_n]</code> is written <code>A_1 + ... + A_n</code>. If we express the above properties using <em>Type Theory</em> notation, we get</p>
<ul>
<li><code>A + B ‚âÖ B + A</code></li>
<li><code>(A + B) + C ‚âÖ A + (B + C) ‚âÖ A + B + C</code></li>
<li><code>0 + A ‚âÖ A + 0 ‚âÖ A</code></li>
<li><code>C √ó (A + B) ‚âÖ (C √ó A) + (C √ó B)</code></li>
<li><code>1 √ó A ‚âÖ A</code></li>
<li><code>0 √ó A ‚âÖ A √ó 0 ‚âÖ 0</code></li>
</ul>
<p>Is arithmetic familiar to you? If so such equations should be familiar too. But these times there are not between numbers but between equivalent types. If you ever wonder why <a href="https://en.wikipedia.org/wiki/Algebraic_data_type" rel="external" target="_self">Algebraic Data Types</a> are called this way, this should give you some hints.</p>
<h2 id="next-episode-recursive-data-typeshttpschrilvesgithubiotypes5-rectypes"><a href="https://chrilves.github.io/types/5-rectypes/" rel="external" target="_self">Next Episode: Recursive Data Types</a></h2>
<p>In the <a href="https://chrilves.github.io/types/5-rectypes/" rel="external" target="_self">next episode</a>, we will see <strong>Recursive Data Types</strong>.</p>

  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="episode-5---recursive-data-types">Episode 5 - Recursive Data Types</h1>

<p>We have seen many types but we still don&rsquo;t know how to represent numbers, lists, trees, free monads, or any type with an infinite number of values. One again we will start by simple examples. Like always, <strong>do no skim through</strong> them but take the time to <strong>develop a deep understanding</strong>. If you feel uncomfortable with complex examples, it means you missed something important in the simple ones.</p>
<h2 id="a-simple-example">A simple example</h2>
<p>We will take as example an encoding of <em>non-negative</em> integers, also called <strong>natural numbers</strong>, i.e. numbers <em>0</em>, <em>1</em>, <em>2</em>, <em>3</em> and so on. There are actually many encodings possible, but we will take a simple encoding known as <a href="https://wiki.haskell.org/Peano_numbers" rel="external" target="_self">Peano numbers</a>. Did you ever wonder how <em>natural numbers</em> are built? There can actually be built starting from <code>0</code> then adding <code>1</code> to <code>0</code> to make <code>1</code>, then adding <code>1</code> to <code>1</code> to make <code>2</code>, then adding <code>1</code> to <code>2</code> to make <code>3</code>, then adding <code>1</code> to <code>3</code> to make <code>4</code>, and so on. Our encoding will mimic this construction. We need <strong>two constructors</strong>: one of represent <code>0</code> and the other to represent the operation of adding <code>1</code> to the previous number to make a new one.</p>
<p>Let&rsquo;s call <code>Nat</code> the type of natural numbers. The first constructor, representing <code>0</code> should be a constant of type <code>Nat</code> while the second one, representing the operation of adding <code>1</code> should be a function of type <code>Nat =&gt; Nat</code>. Remember that <em>constructors need to be injective</em>, but we are lucky, this operation is actually injective. Let call the first constructor <code>Zero:Nat</code> and the second one <code>Succ:Nat =&gt; Nat</code> (for successor). This is easy to translate into <em>Scala</em> and <em>Haskell</em>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Nat</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">zero</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">succ</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">Zero</span> <span class="k">=&gt;</span> <span class="n">zero</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">Succ</span><span class="o">(</span><span class="n">p</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="n">p</span><span class="o">.</span><span class="n">fold</span><span class="o">(</span><span class="n">zero</span><span class="o">,</span> <span class="n">succ</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">succ</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">Zero</span>         <span class="k">extends</span> <span class="nc">Nat</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">Succ</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Nat</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Nat</span></span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">data</span> <span class="kt">Nat</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  <span class="kt">Zero</span> <span class="ow">::</span> <span class="kt">Nat</span>
</span></span><span class="line"><span class="cl">  <span class="kt">Succ</span> <span class="ow">::</span> <span class="kt">Nat</span> <span class="ow">-&gt;</span> <span class="kt">Nat</span></span></span></code></pre></div>
<p>Note that all the constructors we have seen in the previous episodes took as argument <em>already defined types</em>, but the first argument of <code>Succ</code> is of type <code>Nat</code>, the very <em>same type we are defining</em>. This is the reason why <code>Nat</code> is called a <strong>recursive data type</strong>: some of its constructors take as arguments values of type <code>Nat</code> itself. As usual:</p>
<ul>
<li>constructors are injective</li>
<li>different constructors produces different value</li>
<li>every value of type <code>Nat</code> is either a <code>Zero</code> or a <code>Succ(n)</code> for some <code>n:Nat</code></li>
</ul>
<p>The problem is, unlike <em>enumerations</em>, <em>products</em> and <em>coproducts</em> where these properties are enough to define their respective type (<em>up to equivalence</em>) without ambiguity. With <em>recursive data types</em> there can be several <strong>non-equivalent</strong> types for which these three properties hold. For example, the type <code>{0, 1, 2, ...}</code> of natural numbers and <code>{O, 1, 2,  ..., ‚àû}</code> in which we added one special number called infinity such that <code>Succ(‚àû) = ‚àû</code> both have the three properties above. So wee need to add a new <em>constraint</em>, which is that: <strong>among all the types for which these properties hold, <code>Nat</code> is taken as the smallest one</strong>.</p>
<p><em>Recursive types</em> have amazing properties. For example the types <code>Nat</code> and <code>Option[Nat]</code> are equivalent! Indeed <code>nat2opt</code> and <code>opt2nat</code> are <em>inverse bijections</em>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">opt2nat</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Nat</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Nat</span> <span class="k">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Succ</span><span class="o">(</span><span class="n">n</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nc">Zero</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">nat2opt</span><span class="k">:</span> <span class="kt">Nat</span> <span class="o">=&gt;</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">Nat</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nc">Succ</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="n">n</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nc">Zero</span> <span class="k">=&gt;</span> <span class="nc">None</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">opt2nat</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">Nat</span> <span class="ow">-&gt;</span> <span class="kt">Nat</span>
</span></span><span class="line"><span class="cl"><span class="nf">opt2nat</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Succ</span> <span class="n">n</span>
</span></span><span class="line"><span class="cl"><span class="nf">opt2nat</span> <span class="kt">Nothing</span>  <span class="ow">=</span> <span class="kt">Zero</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">nat2opt</span> <span class="ow">::</span> <span class="kt">Nat</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Nat</span>
</span></span><span class="line"><span class="cl"><span class="nf">nat2opt</span> <span class="p">(</span><span class="kt">Succ</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="n">n</span>
</span></span><span class="line"><span class="cl"><span class="nf">nat2opt</span> <span class="kt">Zero</span>     <span class="ow">=</span> <span class="kt">Nothing</span></span></span></code></pre></div>
<p>It means that <code>Nat ‚âÖ Option[Nat]</code>. Note that <code>Option[T] ‚âÖ Either[Unit, T] ‚âÖ 1 + T</code> in <em>Type Theory</em> notation, so <code>Nat</code> is actually one of the solution of the <strong>type equation</strong> <code>T ‚âÖ 1 + T</code>. Such an equation means we are looking for types <code>T</code> such that <code>T</code> and <code>Option[T]</code> are equivalent. Regarding <code>Option</code> as a function from types to type, where the type <code>Option[T]</code> is the one obtained by applying the argument <code>T</code> to the function <code>Option</code>, <code>Nat</code> is one of the <a href="https://en.wikipedia.org/wiki/Fixed_point_(mathematics)" rel="external" target="_self">fixed-point</a> of this function. More precisely, <code>Nat</code> is the least fixed-point of <code>Option</code>.</p>
<blockquote>
<p>Let <code>Œº: (Type -&gt; Type) -&gt; Type</code> be the operator taking a type function <code>F</code> as argument (written <code>F[_]</code> in <em>Scala</em> and <code>f :: * -&gt; *</code> in <em>haskell</em>) and returning the <strong>least fixed-point</strong> of <code>F</code>, which is defined as the smallest type <code>T</code> (up to equivalence) which is solution of the equation <code>T ‚âÖ F[T]</code>. To simplify the notations, we may also write <code>ŒºT.F[T]</code> instead of <code>Œº(F)</code>.</p>
</blockquote>
<p>As an example <code>Nat = Œº(Option)</code> which we also write <code>Nat = ŒºT.Either[Unit, T]</code> and also  <code>Nat = ŒºT.(1 + T)</code>.</p>
<p>Another solution to the equation, which is, this time the <em>greatest fixed-point</em> of <code>Option</code> is the type <code>NatInf</code>, representing <code>{0, 1, 2, ..., ‚àû}</code>, defined as below. It is the <em>biggest type</em> which is solution (up to equivalence) of the equation <code>T ‚âÖ 1 + T</code>. The two <em>inverse functions</em> <code>opt2natInf</code> and <code>natInf2opt</code> proves the equivalence:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">trait</span> <span class="nc">NatInf</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">unfold</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">NatInf</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">zero</span><span class="k">:</span> <span class="kt">NatInf</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="k">new</span> <span class="nc">NatInf</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="n">unfold</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">NatInf</span><span class="o">]</span> <span class="k">=</span> <span class="nc">None</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">succ</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">NatInf</span><span class="o">)</span><span class="k">:</span> <span class="kt">NatInf</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="k">new</span> <span class="nc">NatInf</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="n">unfold</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">NatInf</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="n">n</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="o">‚àû</span> <span class="k">:</span> <span class="kt">NatInf</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="k">new</span> <span class="nc">NatInf</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="n">unfold</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">NatInf</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(‚àû)</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">opt2natInf</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">NatInf</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">NatInf</span> <span class="k">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">succ</span><span class="o">(</span><span class="n">n</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nc">None</span>    <span class="k">=&gt;</span> <span class="n">zero</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">natInf2opt</span><span class="k">:</span> <span class="kt">NatInf</span> <span class="o">=&gt;</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">NatInf</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">NatInf</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">n</span><span class="o">.</span><span class="n">unfold</span></span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">newtype</span> <span class="kt">NatInf</span> <span class="ow">=</span> <span class="kt">NatInf</span> <span class="p">{</span> <span class="n">unfold</span> <span class="ow">::</span>  <span class="kt">Maybe</span> <span class="kt">NatInf</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">zero</span> <span class="ow">::</span> <span class="kt">NatInf</span>
</span></span><span class="line"><span class="cl"><span class="nf">zero</span> <span class="ow">=</span> <span class="kt">NatInf</span> <span class="kt">Nothing</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">succ</span> <span class="ow">::</span> <span class="kt">NatInf</span> <span class="ow">-&gt;</span> <span class="kt">NatInf</span>
</span></span><span class="line"><span class="cl"><span class="nf">succ</span> <span class="n">n</span> <span class="ow">=</span> <span class="kt">NatInf</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">inf</span> <span class="ow">::</span> <span class="kt">NatInf</span>
</span></span><span class="line"><span class="cl"><span class="nf">inf</span> <span class="ow">=</span> <span class="kt">NatInf</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">inf</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">opt2natInf</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">NatInf</span> <span class="ow">-&gt;</span> <span class="kt">NatInf</span>
</span></span><span class="line"><span class="cl"><span class="nf">opt2natInf</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="n">succ</span> <span class="n">n</span>
</span></span><span class="line"><span class="cl"><span class="nf">opt2natInf</span> <span class="kt">Nothing</span>  <span class="ow">=</span> <span class="n">zero</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">natInf2opt</span> <span class="ow">::</span> <span class="kt">NatInf</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">NatInf</span>
</span></span><span class="line"><span class="cl"><span class="nf">natInf2opt</span> <span class="ow">=</span> <span class="n">unfold</span></span></span></code></pre></div>
<h3 id="equivalence-of-inductive-and-functional-definitions">Equivalence of inductive and functional definitions</h3>
<p><code>Nat</code> can be <em>equivalently defined</em> as a <em>data type</em> <code>NatInd</code> as well as a <em>function type</em> <code>NatFun</code>. Inverse bijections <code>ind2fun</code> and <code>fun2ind</code> prove <code>NatInf</code> and <code>NarInd</code> are equivalent:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">NatInd</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">ZeroInd</span> <span class="k">extends</span> <span class="nc">NatInd</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">SuccInd</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">NatInd</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">NatInd</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">trait</span> <span class="nc">NatFun</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">zero</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">succ</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">zeroFun</span> <span class="k">:</span> <span class="kt">NatFun</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="k">new</span> <span class="nc">NatFun</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">zero</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">succ</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">zero</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">succFun</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">NatFun</span><span class="o">)</span> <span class="k">:</span> <span class="kt">NatFun</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="k">new</span> <span class="nc">NatFun</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">zero</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">succ</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="n">n</span><span class="o">.</span><span class="n">fold</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">zero</span><span class="o">,</span> <span class="n">succ</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">succ</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">ind2fun</span><span class="k">:</span> <span class="kt">NatInd</span> <span class="o">=&gt;</span> <span class="nc">NatFun</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">NatInd</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="n">i</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">ZeroInd</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="n">zeroFun</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">SuccInd</span><span class="o">(</span><span class="n">p</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="k">val</span> <span class="n">n</span> <span class="k">=</span> <span class="n">ind2fun</span><span class="o">(</span><span class="n">p</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">succFun</span><span class="o">(</span><span class="n">n</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">fun2ind</span><span class="k">:</span> <span class="kt">NatFun</span> <span class="o">=&gt;</span> <span class="nc">NatInd</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">NatFun</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">n</span><span class="o">.</span><span class="n">fold</span><span class="o">[</span><span class="kt">NatInd</span><span class="o">](</span><span class="nc">ZeroInd</span><span class="o">,</span> <span class="nc">SuccInd</span><span class="o">(</span><span class="k">_</span><span class="o">))</span></span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">data</span> <span class="kt">NatInd</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  <span class="kt">ZeroInd</span> <span class="ow">::</span> <span class="kt">NatInd</span>
</span></span><span class="line"><span class="cl">  <span class="kt">SuccInd</span> <span class="ow">::</span> <span class="kt">NatInd</span> <span class="ow">-&gt;</span> <span class="kt">NatInd</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">type</span> <span class="kt">NatFun</span> <span class="ow">=</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">zeroFun</span> <span class="ow">::</span> <span class="kt">NatFun</span>
</span></span><span class="line"><span class="cl"><span class="nf">zeroFun</span> <span class="n">z</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">z</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">succFun</span> <span class="ow">::</span> <span class="kt">NatFun</span> <span class="ow">-&gt;</span> <span class="kt">NatFun</span>
</span></span><span class="line"><span class="cl"><span class="nf">succFun</span> <span class="n">n</span> <span class="n">z</span> <span class="n">s</span> <span class="ow">=</span> <span class="n">s</span> <span class="p">(</span><span class="n">n</span> <span class="n">z</span> <span class="n">s</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">ind2fun</span> <span class="ow">::</span> <span class="kt">NatInd</span> <span class="ow">-&gt;</span> <span class="kt">NatFun</span>
</span></span><span class="line"><span class="cl"><span class="nf">ind2fun</span>  <span class="kt">ZeroInd</span>    <span class="ow">=</span> <span class="n">zeroFun</span>
</span></span><span class="line"><span class="cl"><span class="nf">ind2fun</span> <span class="p">(</span><span class="kt">SuccInd</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="n">succFun</span> <span class="p">(</span><span class="n">ind2fun</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">fun2ind</span> <span class="ow">::</span> <span class="kt">NatFun</span> <span class="ow">-&gt;</span> <span class="kt">NatInd</span>
</span></span><span class="line"><span class="cl"><span class="nf">fun2ind</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">n</span> <span class="kt">ZeroInd</span> <span class="kt">SuccInd</span></span></span></code></pre></div>
<h2 id="lists">Lists</h2>
<p>Similarly, given a type <code>A</code>, we want to define the the type of lists whose elements are of type <code>A</code>, written <code>List[A]</code>. Let <code>l:List[A]</code> be a list whose elements are of type <code>A</code>. There are two cases: either the list is empty or it is not. Let&rsquo;s call the the empty list <code>Nil</code>. If the list is not empty, let <code>head</code> be its first element and <code>tail</code> the rest of the list (i.e. the same list as <code>l</code> but without the first element <code>head</code>). Then <code>tail</code> is also a list of type <code>List[A]</code> and <code>l</code> can be obtained by prepending <code>head</code> to <code>tail</code>. We will write this prepending operation <code>Cons :: (A, List[A]) =&gt; List[A]</code> such that <code>l = Cons(head, tail)</code>.</p>
<p>Once again we see we have <strong>two constructors</strong>: <code>Nil</code> of type <code>List[A]</code> and <code>Cons</code> of type <code>(A, List[A]) =&gt; List[A]</code>. Besides, these constructors satisfy the usual thee properties:</p>
<ul>
<li>constructors are injective</li>
<li>different constructors produces different value</li>
<li>every value of type <code>List[A]</code> is either a <code>Nil</code> or a <code>Cons(head, tail)</code> for some <code>head:A</code> and some <code>tail:List[A]</code></li>
</ul>
<p>Furthermore <code>List[A]</code> is the smallest type satisfying these properties. It can easily be defined in <em>Scala</em> as</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">List</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">R</span><span class="o">](</span><span class="n">nil</span><span class="k">:</span> <span class="kt">R</span><span class="o">,</span> <span class="n">cons</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span><span class="kt">R</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">R</span><span class="o">)</span><span class="k">:</span> <span class="kt">R</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="n">nil</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">Cons</span><span class="o">(</span><span class="n">head</span><span class="o">,</span><span class="n">tail</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="k">val</span> <span class="n">r</span> <span class="k">=</span> <span class="n">tail</span><span class="o">.</span><span class="n">fold</span><span class="o">[</span><span class="kt">R</span><span class="o">](</span><span class="n">nil</span><span class="o">,</span> <span class="n">cons</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">cons</span><span class="o">(</span><span class="n">head</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">Nil</span> <span class="k">extends</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">Cons</span><span class="o">[</span><span class="kt">+A</span><span class="o">](</span><span class="n">head</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span></span></span></code></pre></div>
<p>Like any recursive data type, <code>List[A]</code> is the smallest solution of a <em>type equation</em>. This time the equation is <code>T ‚âÖ 1 + (A, T)</code> which in a more <em>Scalaish</em> syntax is <code>T ‚âÖ Option[(A, T)]</code>. Equivalently, <code>List[A]</code> is also the <em>least fixed-point</em> of the type-function:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">type</span> <span class="kt">F</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Option</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">T</span><span class="o">)]</span></span></span></code></pre></div>
<p>Which means <code>List[A] = ŒºT.(1 + A √ó T)</code>. The biggest type which is solution (up to equivalence) of the equation, which is the <em>greatest fixed-point</em> of <code>F</code> is the type of streams whose elements are of type <code>A</code>, written <code>Stream[A]</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">trait</span> <span class="kt">Steam</span><span class="p">[</span><span class="kt">A</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">def</span> <span class="n">unfold</span><span class="kt">:</span> <span class="kt">Option</span><span class="p">[(</span><span class="kt">A</span><span class="p">,</span> <span class="kt">Stream</span><span class="p">[</span><span class="kt">A</span><span class="p">])]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">newtype</span> <span class="kt">Stream</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Stream</span> <span class="p">{</span> <span class="n">runStream</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">c</span><span class="o">.</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">Stream</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">c</span> <span class="p">}</span></span></span></code></pre></div>
<p><em>Exercise: write the bijections proving <code>Stream[A] ‚âÖ Option[(A, Stream[A])]</code></em></p>
<h3 id="equivalence-of-inductive-and-functional-definitions-1">Equivalence of inductive and functional definitions</h3>
<p><code>List[A]</code> can equivalently be defined as the <em>data type</em> <code>ListInd[A]</code> as well as the <em>type function</em> <code>ListFun[A]</code>. The two inverse functions <code>ind2fun</code> and <code>fun2ind</code> prove <code>ListInd[A]</code> and <code>ListFun[A]</code> are equivalent:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">ListInd</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">NilInd</span> <span class="k">extends</span> <span class="nc">ListInd</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">ConsInd</span><span class="o">[</span><span class="kt">+A</span><span class="o">](</span><span class="n">head</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">ListInd</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">ListInd</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">trait</span> <span class="nc">ListFun</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">R</span><span class="o">](</span><span class="n">nil</span><span class="k">:</span> <span class="kt">R</span><span class="o">,</span> <span class="n">cons</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span><span class="kt">R</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">R</span><span class="o">)</span><span class="k">:</span> <span class="kt">R</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">nilFun</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">ListFun</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="k">new</span> <span class="nc">ListFun</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">R</span><span class="o">](</span><span class="n">nil</span><span class="k">:</span> <span class="kt">R</span><span class="o">,</span> <span class="n">cons</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span><span class="kt">R</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">R</span><span class="o">)</span><span class="k">:</span> <span class="kt">R</span> <span class="o">=</span> <span class="n">nil</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">consFun</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">head</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">ListFun</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">ListFun</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="k">new</span> <span class="nc">ListFun</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">R</span><span class="o">](</span><span class="n">nil</span><span class="k">:</span> <span class="kt">R</span><span class="o">,</span> <span class="n">cons</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span><span class="kt">R</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">R</span><span class="o">)</span><span class="k">:</span> <span class="kt">R</span> <span class="o">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">r</span> <span class="k">=</span> <span class="n">tail</span><span class="o">.</span><span class="n">fold</span><span class="o">[</span><span class="kt">R</span><span class="o">](</span><span class="n">nil</span><span class="o">,</span> <span class="n">cons</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">cons</span><span class="o">(</span><span class="n">head</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">ind2fun</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">ListInd</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">ListFun</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">ListInd</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="n">i</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">NilInd</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="n">nilFun</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">ConsInd</span><span class="o">(</span><span class="n">head</span><span class="o">,</span> <span class="n">tail</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="k">val</span> <span class="n">tailFun</span> <span class="k">=</span> <span class="n">ind2fun</span><span class="o">(</span><span class="n">tail</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">consFun</span><span class="o">(</span><span class="n">head</span><span class="o">,</span> <span class="n">tailFun</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">fun2ind</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">ListFun</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">ListInd</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">ListFun</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">fold</span><span class="o">[</span><span class="kt">ListInd</span><span class="o">[</span><span class="kt">A</span><span class="o">]](</span><span class="nc">NilInd</span><span class="o">,</span> <span class="nc">ConsInd</span><span class="o">(</span><span class="k">_</span><span class="o">,</span><span class="k">_</span><span class="o">))</span></span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">data</span> <span class="kt">ListInd</span> <span class="n">a</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  <span class="kt">NilInd</span>  <span class="ow">::</span> <span class="kt">ListInd</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl">  <span class="kt">ConsInd</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">ListInd</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">ListInd</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">type</span> <span class="kt">ListFun</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">forall</span> <span class="n">r</span><span class="o">.</span> <span class="n">r</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">r</span> <span class="ow">-&gt;</span> <span class="n">r</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">r</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">nilFun</span> <span class="ow">::</span> <span class="kt">ListFun</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl"><span class="nf">nilFun</span> <span class="n">nil</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">nil</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">consFun</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">ListFun</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">ListFun</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl"><span class="nf">consFun</span> <span class="n">head</span> <span class="n">tail</span> <span class="n">nil</span> <span class="n">cons</span> <span class="ow">=</span> <span class="n">cons</span> <span class="n">head</span> <span class="p">(</span><span class="n">tail</span> <span class="n">nil</span> <span class="n">cons</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">ind2fun</span> <span class="ow">::</span> <span class="kt">ListInd</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">ListFun</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl"><span class="nf">ind2fun</span>  <span class="kt">NilInd</span>             <span class="ow">=</span> <span class="n">nilFun</span>
</span></span><span class="line"><span class="cl"><span class="nf">ind2fun</span> <span class="p">(</span><span class="kt">ConsInd</span> <span class="n">head</span> <span class="n">tail</span><span class="p">)</span> <span class="ow">=</span> <span class="n">consFun</span> <span class="n">head</span> <span class="p">(</span><span class="n">ind2fun</span> <span class="n">tail</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">fun2ind</span> <span class="ow">::</span> <span class="kt">ListFun</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">ListInd</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl"><span class="nf">fun2ind</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">f</span> <span class="kt">NilInd</span> <span class="kt">ConsInd</span></span></span></code></pre></div>
<h2 id="algebraic-data-types">Algebraic Data Types</h2>
<p><a href="https://en.wikipedia.org/wiki/Algebraic_data_type" rel="external" target="_self">Algebraic Data Types</a> are types that can be expressed using only <code>False</code>, <code>Unit</code>, <em>products</em>, <em>coproducts</em> and the <em>least fixed-point</em> operator <code>Œº</code>. For example, binary trees whose elements are of type <code>A</code>, defined in <em>Scala</em> by</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Tree</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">R</span><span class="o">](</span><span class="n">empty</span><span class="k">:</span> <span class="kt">R</span><span class="o">,</span> <span class="n">leaf</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">R</span><span class="o">,</span> <span class="n">node</span><span class="k">:</span> <span class="o">(</span><span class="kt">R</span><span class="o">,</span> <span class="kt">R</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">R</span><span class="o">)</span><span class="k">:</span> <span class="kt">R</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">Empty</span>   <span class="k">=&gt;</span> <span class="n">empty</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">Leaf</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">leaf</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">Node</span><span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="k">val</span> <span class="n">al</span> <span class="k">=</span> <span class="n">l</span><span class="o">.</span><span class="n">fold</span><span class="o">[</span><span class="kt">R</span><span class="o">](</span><span class="n">empty</span><span class="o">,</span> <span class="n">leaf</span><span class="o">,</span> <span class="n">node</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">val</span> <span class="n">ar</span> <span class="k">=</span> <span class="n">r</span><span class="o">.</span><span class="n">fold</span><span class="o">[</span><span class="kt">R</span><span class="o">](</span><span class="n">empty</span><span class="o">,</span> <span class="n">leaf</span><span class="o">,</span> <span class="n">node</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">node</span><span class="o">(</span><span class="n">al</span><span class="o">,</span> <span class="n">ar</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">Empty</span> <span class="k">extends</span> <span class="nc">Tree</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">Leaf</span><span class="o">[</span><span class="kt">+A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Tree</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">Node</span><span class="o">[</span><span class="kt">+A</span><span class="o">](</span><span class="n">left</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">right</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Tree</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span></span></span></code></pre></div>
<p>can be expressed as the type <code>Tree[A] = ŒºT.(1 + A + (T √ó T))</code>, which is the smallest type (up to equivalence) solution of the equation <code>T ‚âÖ Either3[Unit, A, (T, T)]</code>.</p>
<p><em>Exercise: write the bijection proving the equivalence.</em></p>

  <footer class="footline">
  </footer>
</article>
          </section>
        </div>
      </main>
    </div>
    <script src="../js/clipboard.min.js?1729680927" defer></script>
    <script src="../js/perfect-scrollbar.min.js?1729680927" defer></script>
    <script src="../js/theme.js?1729680927" defer></script>
  </body>
</html>
