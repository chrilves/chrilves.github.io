<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Introduction to Types :: @chrilves&#39; Archives</title>
    <link>https://chrilves.github.io/types/index.html</link>
    <description>A short and informal introduction to type theory.</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Sun, 16 Dec 2018 00:05:00 +0000</lastBuildDate>
    <atom:link href="https://chrilves.github.io/types/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Episode 5 - Recursive Data Types</title>
      <link>https://chrilves.github.io/types/5-rectypes/index.html</link>
      <pubDate>Sun, 16 Dec 2018 00:05:00 +0000</pubDate>
      <guid>https://chrilves.github.io/types/5-rectypes/index.html</guid>
      <description>In today&#39;s episodes, let&#39;s see how to type recursive data such as lists and trees.</description>
    </item>
    <item>
      <title>Episode 4 - CoProducts</title>
      <link>https://chrilves.github.io/types/4-coproducts/index.html</link>
      <pubDate>Sun, 16 Dec 2018 00:04:00 +0000</pubDate>
      <guid>https://chrilves.github.io/types/4-coproducts/index.html</guid>
      <description>CoProducts, often called sum types, discriminated unions or disjoint unions, are a convenient way to express an alternative between different types. The coproduct of n types (with n being 0, 1, 2, etc) A_1, A_2, …, A_n is precisely the type whose values are (i, a_i) where i is a number, called the tag, between 1 and n both included (1 ≤ i ≤ n) and a_i is a value of type A_i (the actual type then depends on the value of i). Is is often written Either[A_1, ..., A_n] in programming and A_1 + ... + A_n in Type Theory.</description>
    </item>
    <item>
      <title>Episode 3 - Products</title>
      <link>https://chrilves.github.io/types/3-products/index.html</link>
      <pubDate>Sun, 16 Dec 2018 00:03:00 +0000</pubDate>
      <guid>https://chrilves.github.io/types/3-products/index.html</guid>
      <description>Products, often called tuples, records or case classes, are a convenient way to bundle values of different types into a single value. The product of n types (with n being 0, 1, 2, etc) A_1, A_2, …, A_n is precisely the type whose values are formed with exactly one value of each type A_i for 1 ≤ i ≤ n. It is written (A_1, A_2, ..., A_n) in many languages, Product_n[A_1, A_2, ..., A_n] in Scala and A_1 × ... × A_n in Type Theory. As an example, the product of two types A and B would be defined as</description>
    </item>
    <item>
      <title>Episode 2 - Enumerations</title>
      <link>https://chrilves.github.io/types/2-enums/index.html</link>
      <pubDate>Sun, 16 Dec 2018 00:02:00 +0000</pubDate>
      <guid>https://chrilves.github.io/types/2-enums/index.html</guid>
      <description>This episode is about one of the simplest types: enumeations.</description>
    </item>
    <item>
      <title>Episode 1 - Why Types?</title>
      <link>https://chrilves.github.io/types/1-why/index.html</link>
      <pubDate>Sun, 16 Dec 2018 00:01:00 +0000</pubDate>
      <guid>https://chrilves.github.io/types/1-why/index.html</guid>
      <description>Types are more complex and nuanced than you may think. Let me show you.</description>
    </item>
  </channel>
</rss>