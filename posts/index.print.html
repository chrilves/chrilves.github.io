<!DOCTYPE html>
<html lang="en" dir="ltr" itemscope itemtype="http://schema.org/Article">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.136.3">
    <meta name="generator" content="Relearn 7.1.1">
    <meta name="description" content="Articles about programming, game design and maths.">
    <meta name="author" content="chrilves">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Posts :: @chrilves&#39; Archives">
    <meta name="twitter:description" content="Articles about programming, game design and maths.">
  <meta name="twitter:site" content="@chrilves"/>
    <meta property="og:url" content="https://chrilves.github.io/posts/index.html">
    <meta property="og:site_name" content="@chrilves&#39; Archives">
    <meta property="og:title" content="Posts :: @chrilves&#39; Archives">
    <meta property="og:description" content="Articles about programming, game design and maths.">
    <meta property="og:locale" content="en">
    <meta property="og:type" content="website">
    <meta itemprop="name" content="Posts :: @chrilves&#39; Archives">
    <meta itemprop="description" content="Articles about programming, game design and maths.">
    <meta itemprop="datePublished" content="2024-10-07T00:00:00+02:00">
    <meta itemprop="dateModified" content="2024-10-07T00:00:00+02:00">
    <meta itemprop="wordCount" content="265">
    <title>Posts :: @chrilves&#39; Archives</title>
    <link href="https://chrilves.github.io/posts/index.html" rel="canonical" type="text/html" title="Posts :: @chrilves&#39; Archives">
    <link href="../posts/index.xml" rel="alternate" type="application/rss+xml" title="Posts :: @chrilves&#39; Archives">
    <link href="../css/fontawesome-all.min.css?1731043964" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../css/fontawesome-all.min.css?1731043964" rel="stylesheet"></noscript>
    <link href="../css/nucleus.css?1731043964" rel="stylesheet">
    <link href="../css/auto-complete.css?1731043964" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../css/auto-complete.css?1731043964" rel="stylesheet"></noscript>
    <link href="../css/perfect-scrollbar.min.css?1731043964" rel="stylesheet">
    <link href="../css/fonts.css?1731043964" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../css/fonts.css?1731043964" rel="stylesheet"></noscript>
    <link href="../css/theme.css?1731043964" rel="stylesheet">
    <link href="../css/theme-relearn-auto.css?1731043964" rel="stylesheet" id="R-variant-style">
    <link href="../css/chroma-relearn-auto.css?1731043964" rel="stylesheet" id="R-variant-chroma-style">
    <link href="../css/print.css?1731043964" rel="stylesheet" media="print">
    <link href="../css/format-print.css?1731043964" rel="stylesheet">
    <script src="../js/variant.js?1731043964"></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.relBasePath='..';
      window.relearn.relBaseUri='..';
      window.relearn.absBaseUri='https:\/\/chrilves.github.io';
      window.relearn.disableAnchorCopy=false;
      window.relearn.disableAnchorScrolling=false;
      // variant stuff
      window.variants && variants.init( [ 'relearn-auto', 'relearn-light', 'relearn-dark', 'relearn-bright', 'zen-auto', 'zen-light', 'zen-dark', 'retro-auto', 'neon', 'learn', 'blue', 'green', 'red' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script>
  </head>
  <body class="mobile-support print disableInlineCopyToClipboard" data-url="../posts/index.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide"><button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)"><i class="fa-fw fas fa-bars"></i></button>
            </div>
            <div class="topbar-button topbar-button-toc" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="Table of Contents (CTRL&#43;ALT&#43;t)"><i class="fa-fw fas fa-list-alt"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper"> 
                </div>
              </div>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">Posts</span><meta itemprop="position" content="1"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
            <div class="topbar-button topbar-button-edit" data-content-empty="disable" data-width-s="area-more" data-width-m="show" data-width-l="show"><a class="topbar-control" href="https://github.com/chrilves/chrilves.github.io/edit/master/hugo/content/posts/_index.md" target="_self" title="Edit (CTRL&#43;ALT&#43;w)"><i class="fa-fw fas fa-pen"></i></a>
            </div>
            <div class="topbar-button topbar-button-print" data-content-empty="disable" data-width-s="area-more" data-width-m="show" data-width-l="show"><a class="topbar-control" href="../posts/index.print.html" title="Print whole chapter (CTRL&#43;ALT&#43;p)"><i class="fa-fw fas fa-print"></i></a>
            </div>
            <div class="topbar-button topbar-button-prev" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="../index.html" title="@chrilves&#39; Archives (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a>
            </div>
            <div class="topbar-button topbar-button-next" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="../posts/probability_in_scala_3_all_sides/index.html" title="Playing with Probability in Scala 3 (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a>
            </div>
            <div class="topbar-button topbar-button-more" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="More"><i class="fa-fw fas fa-ellipsis-v"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper">
                  <div class="topbar-area topbar-area-more" data-area="more">
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable posts" tabindex="-1">
        <div class="flex-block-wrapper">
<article class="default">
  <header class="headline">
  </header>

<h1 id="posts">Posts</h1>



<div class="children children-h2 children-sort-">
<h2><a href="../posts/probability_in_scala_3_all_sides/index.html">Playing with Probability in Scala 3</a></h2>
<p class="article-meta default"><em>11 Jul 2020 - 5700 Words</em></p>
<p>Given a fair dice, how many rolls are needed, on average, to observe all the sides? From this simple question, this article explores basic probability theory and statistics in Scala 3, the upcoming major release of the Scala programming language. It shows the new features, their use and benefits.</p>
<a href="../posts/probability_in_scala_3_all_sides/index.html"><nobr>Read more →</nobr></a>
<h2><a href="../posts/les_gadts_par_l_exemple/index.html">Les GADTs Par l&#39;Exemple</a></h2>
<p class="article-meta default"><em>27 Oct 2019 - 7900 Words</em></p>
<p>Découvrez les ADT généralisés en vous amusant.</p>
<a href="../posts/les_gadts_par_l_exemple/index.html"><nobr>Read more →</nobr></a>
<h2><a href="../posts/gadts_by_use_cases/index.html">GADTs By Use Cases</a></h2>
<p class="article-meta default"><em>26 Oct 2019 - 7400 Words</em></p>
<p>Discover Generalized ADT through lots of practical examples.</p>
<a href="../posts/gadts_by_use_cases/index.html"><nobr>Read more →</nobr></a>
<h2><a href="../posts/prime/index.html">Proving Primality with GADTs</a></h2>
<p class="article-meta default"><em>01 Oct 2019 - 1100 Words</em></p>
<p>Let&#39;s do a bit of logic in Scala&#39;s type system.</p>
<a href="../posts/prime/index.html"><nobr>Read more →</nobr></a>
<h2><a href="../posts/recursion_schemes_intro/index.html">Recursion Schemes: the high-school introduction</a></h2>
<p class="article-meta default"><em>22 Mar 2019 - 3600 Words</em></p>
<p>Presentation of recursion schemes from simple examples without the complex vocabulary in the way.</p>
<a href="../posts/recursion_schemes_intro/index.html"><nobr>Read more →</nobr></a>
<h2><a href="../posts/gadts_intro/index.html">Demystifying GADTs</a></h2>
<p class="article-meta default"><em>20 Feb 2019 - 3200 Words</em></p>
<p>Introduction to catamorphisms on Algebraic Data Types</p>
<a href="../posts/gadts_intro/index.html"><nobr>Read more →</nobr></a>
<h2><a href="../posts/folds/index.html">Let&#39;s meet the charming fold family</a></h2>
<p class="article-meta default"><em>30 Nov 2018 - 1800 Words</em></p>
<p>Introduction to catamorphisms on Algebraic Data Types</p>
<a href="../posts/folds/index.html"><nobr>Read more →</nobr></a>
<h2><a href="../posts/slimetrail/index.html">How to make game in the browser thanks to ScalaJS</a></h2>
<p class="article-meta default"><em>18 Sep 2018 - 200 Words</em></p>
<p>ScalaIO.2018 Workshop</p>
<a href="../posts/slimetrail/index.html"><nobr>Read more →</nobr></a>
<h2><a href="../posts/json2xml/index.html">JSON to XML: the probably a tiny bit over engineered way</a></h2>
<p class="article-meta default"><em>18 Sep 2018 - 2200 Words</em></p>
<p>Conversion from/to JSON and XML using advanced concepts</p>
<a href="../posts/json2xml/index.html"><nobr>Read more →</nobr></a>
<h2><a href="../posts/falgebra_scalaio_2017/index.html">F-Algebra talk at ScalaIO 2017: Modéliser astucieusement vos données</a></h2>
<p class="article-meta default"><em>18 Sep 2017 - 100 Words</em></p>
<p>ScalaIO.2017 Talk</p>
<a href="../posts/falgebra_scalaio_2017/index.html"><nobr>Read more →</nobr></a>
</h2>

  <footer class="footline">
  </footer>
</article>
          <section>
            <h1 class="a11y-only">Subsections of Posts</h1>
<article class="default">
  <header class="headline">
  </header>

<h1 id="playing-with-probability-in-scala-3">Playing with Probability in Scala 3</h1>
    <p class="article-meta default"><em>11 Jul 2020 - 5700 Words</em></p>

<p>Here is a simple experiment: take a <strong>fair</strong> dice (or a coin) and roll it until every
side of the dice has been observed <strong>at least once</strong>. Write down the number of
rolls and repeat the operation several times.
<em>On average, how many rolls does it take to observe every side of the dice at
least once?</em>
This is precisely the question we are about to answer together.</p>
<p>Solving Maths puzzle is fun. Solving them using the shiniest features of
<a href="https://dotty.epfl.ch/" rel="external" target="_self">Scala 3</a> is even amazingly funnier! If you do not have
<em>Scala 3</em> installed yet:</p>
<ul>
<li>on <strong>Arch Linux</strong>, as usual there is an <a href="https://aur.archlinux.org/packages/scala-dotty/" rel="external" target="_self">AUR package</a>
: <code>aur/scala-dotty</code>. Install it via <code>yay -S aur/scala-dotty</code> or any other <em>AUR</em> helper.</li>
<li>on other <em>Linux</em> distributions, download <a href="https://github.com/lampepfl/dotty/releases/download/0.25.0-RC2/dotty-0.25.0-RC2.tar.gz" rel="external" target="_self">https://github.com/lampepfl/dotty/releases/download/0.25.0-RC2/dotty-0.25.0-RC2.tar.gz</a> , extract it and make sure the executables are in your <code>$PATH</code>.</li>
<li>on other systems, follow the instructions <a href="https://dotty.epfl.ch/#getting-started" rel="external" target="_self">here</a>.</li>
</ul>
<p>You should now be able to run the <em>Scala 3 REPL</em> via the command:</p>
<div class="highlight wrap-code"><pre tabindex="0"><code class="language-prompt" data-lang="prompt">[shell prompt]$ dotr -new-syntax -Yexplicit-nulls -Yerased-terms -indent -version
Starting dotty REPL...
Dotty compiler version 0.25.0-RC2 -- Copyright 2002-2020, LAMP/EPFL
scala&gt;</code></pre></div>
<p><strong>An Important Note:</strong> Please refrain from starting your favourite IDE or
starting a new project. It will only make experimenting harder and painful.
All you need is the <em>Scala 3 REPL</em>, any basic text editor and knowing how to
copy-paste on your system.</p>
<h2 id="understanding-the-problem">Understanding the Problem</h2>
<p>Let us start by modelling a dice. The sides of a dice will be numbered starting
from <em>1</em>. We consider a coin as a 2-sided dice whose sides are <em>1</em> and <em>2</em>.
The sides of an usual 6-sided dice are <em>1</em>, <em>2</em>, <em>3</em>, <em>4</em>, <em>5</em> and <em>6</em>.</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Dice</span><span class="o">(</span><span class="n">sides</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">roll</span><span class="o">()</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="n">scala</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">Random</span><span class="o">.</span><span class="n">nextInt</span><span class="o">(</span><span class="n">sides</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">d2</span>   <span class="k">=</span> <span class="nc">Dice</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">d6</span>   <span class="k">=</span> <span class="nc">Dice</span><span class="o">(</span><span class="mi">6</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">d10</span>  <span class="k">=</span> <span class="nc">Dice</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">d20</span>  <span class="k">=</span> <span class="nc">Dice</span><span class="o">(</span><span class="mi">20</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">d100</span> <span class="k">=</span> <span class="nc">Dice</span><span class="o">(</span><span class="mi">100</span><span class="o">)</span></span></span></code></pre></div>
<p><code>d2</code> models a coin, <code>d6</code> models a usual 6-sided dice, etc. The method <code>roll</code>
, as its name suggest, simulates rolling the dice. On each invocation it gives
a random side (its number).
The first question to answer is: <em>is such a dice fair ?</em> Remember that a fair
dice is one for which every side is equally likely to be observed. For a coin,
it means getting <em>1</em> is as likely as getting <em>2</em>. To check empirically that
a dice is fair, or at least not loaded, we will roll it many times and count
how often we observe its sides:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="o">(</span><span class="n">dice</span><span class="k">:</span> <span class="kt">Dice</span><span class="o">)</span> <span class="n">frequencies</span><span class="o">(</span><span class="n">rolls</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Double</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Stores how many times we observed each side
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">val</span> <span class="n">arr</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">.</span><span class="n">fill</span><span class="o">(</span><span class="n">dice</span><span class="o">.</span><span class="n">sides</span><span class="o">)(</span><span class="mi">0</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">1L</span> <span class="n">to</span> <span class="n">rolls</span> <span class="k">do</span>
</span></span><span class="line"><span class="cl">    <span class="n">arr</span><span class="o">(</span><span class="n">dice</span><span class="o">.</span><span class="n">roll</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Transforms counters into ratio
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">val</span> <span class="n">probability</span><span class="k">:</span> <span class="kt">IndexedSeq</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Double</span><span class="o">)]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">dice</span><span class="o">.</span><span class="n">sides</span> <span class="k">yield</span>
</span></span><span class="line"><span class="cl">      <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">arr</span><span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">).</span><span class="n">toDouble</span> <span class="o">/</span> <span class="n">rolls</span>
</span></span><span class="line"><span class="cl">  <span class="n">probability</span><span class="o">.</span><span class="n">toMap</span></span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">d2</span><span class="o">.</span><span class="n">frequencies</span><span class="o">(</span><span class="mi">1000000000L</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">res0</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="mf">0.499985517</span><span class="o">,</span> <span class="mi">2</span> <span class="o">-&gt;</span> <span class="mf">0.500014483</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">d6</span><span class="o">.</span><span class="n">frequencies</span><span class="o">(</span><span class="mi">1000000000L</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">res1</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="nc">HashMap</span><span class="o">(</span>
</span></span><span class="line"><span class="cl">  <span class="mi">1</span> <span class="o">-&gt;</span> <span class="mf">0.166669596</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">  <span class="mi">2</span> <span class="o">-&gt;</span> <span class="mf">0.166660131</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">  <span class="mi">3</span> <span class="o">-&gt;</span> <span class="mf">0.166664591</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">  <span class="mi">4</span> <span class="o">-&gt;</span> <span class="mf">0.166654524</span>
</span></span><span class="line"><span class="cl">  <span class="mi">5</span> <span class="o">-&gt;</span> <span class="mf">0.166665811</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">  <span class="mi">6</span> <span class="o">-&gt;</span> <span class="mf">0.166685347</span><span class="o">)</span></span></span></code></pre></div>
<p>This <a href="https://dotty.epfl.ch/docs/reference/contextual/extension-methods.html" rel="external" target="_self">extension method</a>
can be called like any method of <code>Dice</code>.
As you can see, the frequencies are very close to each other. In addition, the
more rolls we perform, the closer they are.
We can conclude that these dice are fair enough.
We are finally ready for our big adventure: finding the so desired average!
We call an <strong>experiment</strong> the action of rolling the dice until every side has
been observed <em>at least once</em> and the <strong>length</strong> of the experiment its number of
rolls.
The method <code>rollUntilAllSeen</code> simulates an experiment and return its length.</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="o">(</span><span class="n">dice</span><span class="k">:</span> <span class="kt">Dice</span><span class="o">)</span> <span class="n">rollUntilAllSeen</span><span class="o">()</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="k">var</span> <span class="n">rolls</span>     <span class="k">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">  <span class="k">val</span> <span class="n">seen</span>      <span class="k">=</span> <span class="nc">Array</span><span class="o">.</span><span class="n">fill</span><span class="o">(</span><span class="n">dice</span><span class="o">.</span><span class="n">sides</span><span class="o">)(</span><span class="kc">false</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="k">var</span> <span class="n">remaining</span> <span class="k">=</span> <span class="n">dice</span><span class="o">.</span><span class="n">sides</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="n">remaining</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">do</span>
</span></span><span class="line"><span class="cl">    <span class="k">val</span> <span class="n">outcome</span> <span class="k">=</span> <span class="n">dice</span><span class="o">.</span><span class="n">roll</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">rolls</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">!</span><span class="n">seen</span><span class="o">(</span><span class="n">outcome</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="n">then</span>
</span></span><span class="line"><span class="cl">      <span class="n">seen</span><span class="o">(</span><span class="n">outcome</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="k">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">      <span class="n">remaining</span> <span class="o">-=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">  <span class="n">rolls</span></span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">d6</span><span class="o">.</span><span class="n">rollUntilAllSeen</span><span class="o">()</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">res2</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">12</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">d6</span><span class="o">.</span><span class="n">rollUntilAllSeen</span><span class="o">()</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">res3</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">15</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">d6</span><span class="o">.</span><span class="n">rollUntilAllSeen</span><span class="o">()</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">res4</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">8</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">d6</span><span class="o">.</span><span class="n">rollUntilAllSeen</span><span class="o">()</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">res5</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">9</span></span></span></code></pre></div>
<p>Based on the four experiments above, we get the impression that the average
should be close to <em>11</em>, but four experiments are not a lot to get an accurate
estimation of the real average.
Fortunately, the more experiments we run, the closer we get to it.
We need to compute the average over a large number of experiments.
We will actually be a bit smarter.
Instead of limiting ourselves to computing the average, we will count, for every
observed length, the number of its experiments.
It will give us how often a length is observed, i.e. its <em>frequency</em>.</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Histogram</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">values</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">BigInt</span><span class="o">])</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">average</span><span class="o">(</span><span class="n">using</span> <span class="nc">Accumulable</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="nc">Ratio</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="k">var</span> <span class="n">acc</span>   <span class="k">:</span> <span class="kt">A</span>      <span class="o">=</span> <span class="n">summon</span><span class="o">[</span><span class="kt">Accumulable</span><span class="o">[</span><span class="kt">A</span><span class="o">]].</span><span class="n">zero</span>
</span></span><span class="line"><span class="cl">    <span class="k">var</span> <span class="n">total</span> <span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span> <span class="nc">BigInt</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">count</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">values</span> <span class="k">do</span>
</span></span><span class="line"><span class="cl">      <span class="n">acc</span> <span class="o">+=</span> <span class="n">a</span><span class="o">*</span><span class="n">count</span>
</span></span><span class="line"><span class="cl">      <span class="n">total</span> <span class="o">+=</span> <span class="n">count</span>
</span></span><span class="line"><span class="cl">    <span class="n">acc</span> <span class="o">/</span> <span class="n">total</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">frequencies</span><span class="o">(</span><span class="n">using</span> <span class="nc">Ratio</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">BigDecimal</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="k">val</span> <span class="n">total</span> <span class="k">=</span> <span class="n">values</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">sum</span>
</span></span><span class="line"><span class="cl">    <span class="n">values</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">count</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="nc">BigDecimal</span><span class="o">(</span><span class="n">count</span><span class="o">)</span> <span class="o">/</span> <span class="nc">BigDecimal</span><span class="o">(</span><span class="n">total</span><span class="o">)</span> <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Histogram</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="k">var</span> <span class="n">histoB</span> <span class="k">=</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">Map</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">BigInt</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">count</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">values</span> <span class="k">do</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">b</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">histoB</span><span class="o">.</span><span class="n">update</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">histoB</span><span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="nc">BigInt</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span> <span class="o">+</span> <span class="n">count</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">new</span> <span class="nc">Histogram</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">histoB</span><span class="o">.</span><span class="n">toMap</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">object</span> <span class="nc">Histogram</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">iterations</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)(</span><span class="n">value</span> <span class="k">:</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Histogram</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="k">var</span> <span class="n">histo</span> <span class="k">=</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">Map</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">BigInt</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">1L</span> <span class="n">to</span> <span class="n">iterations</span> <span class="k">do</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="n">value</span>
</span></span><span class="line"><span class="cl">      <span class="n">histo</span><span class="o">.</span><span class="n">update</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">histo</span><span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="nc">BigInt</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">new</span> <span class="nc">Histogram</span><span class="o">(</span><span class="n">histo</span><span class="o">.</span><span class="n">toMap</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p>The class <code>Histogram[A]</code> is essentially a key-value store where the value
is the number of times the key has been observed, also known as its
<em>multiplicity</em>.
You may also wonder how <em>Scala</em> can accept adding two values of type <code>A</code> and
multiplying/dividing a value of type <code>A</code> by a <code>BigInt</code> in <code>average</code>.
It works thanks to the magic of
<a href="https://dotty.epfl.ch/docs/reference/contextual/type-classes.html" rel="external" target="_self">Type Classes in Scala 3</a>.
<code>Accumulable</code> and <code>Ratio</code> are two type classes defined by:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">trait</span> <span class="nc">Accumulable</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">zero</span><span class="k">:</span> <span class="kt">A</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span><span class="kt">A</span><span class="o">)+(</span><span class="n">y</span><span class="k">:</span><span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span><span class="kt">A</span><span class="o">)*(</span><span class="n">m</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">trait</span> <span class="nc">Ratio</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span><span class="kt">A</span><span class="o">)</span> <span class="o">/</span> <span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p>Note that, unlike <em>Scala 2</em>, no weird implicit conversion is required to support
infix syntax for <code>+</code>, <code>*</code> and <code>/</code>. These methods are just defined as extension
methods.</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">h6</span> <span class="k">=</span> <span class="nc">Histogram</span><span class="o">(</span><span class="mi">100000000L</span><span class="o">)(</span><span class="n">d6</span><span class="o">.</span><span class="n">rollUntilAllSeen</span><span class="o">())</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">h6</span><span class="k">:</span> <span class="kt">Histogram</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Histogram</span><span class="o">(</span><span class="nc">HashMap</span><span class="o">(</span><span class="mi">73</span> <span class="o">-&gt;</span> <span class="mi">202</span><span class="o">,</span> <span class="mi">69</span> <span class="o">-&gt;</span> <span class="mi">385</span><span class="o">,</span> <span class="mi">88</span> <span class="o">-&gt;</span> <span class="mi">17</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">  <span class="mi">10</span> <span class="o">-&gt;</span> <span class="mi">8298014</span><span class="o">,</span> <span class="mi">56</span> <span class="o">-&gt;</span> <span class="mi">4403</span><span class="o">,</span> <span class="mi">42</span> <span class="o">-&gt;</span> <span class="mi">56557</span><span class="o">,</span> <span class="mi">24</span> <span class="o">-&gt;</span> <span class="mi">1462064</span><span class="o">,</span> <span class="mi">37</span> <span class="o">-&gt;</span> <span class="mi">140975</span><span class="o">,</span> <span class="o">...))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">h6</span><span class="o">.</span><span class="n">average</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="o">|</span><span class="n">h6</span><span class="o">.</span><span class="n">average</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span>          <span class="o">^</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span><span class="n">no</span> <span class="k">implicit</span> <span class="n">argument</span> <span class="n">of</span> <span class="k">type</span> <span class="kt">Accumulable</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="n">was</span> <span class="n">found</span> <span class="k">for</span> <span class="n">parameter</span> <span class="n">x$1</span> <span class="n">of</span> <span class="n">method</span> <span class="n">average</span> <span class="n">in</span> <span class="k">class</span> <span class="nc">Histogram</span></span></span></code></pre></div>
<p>If your first reaction is to implement an instance of <code>Accumulable</code> for <code>Int</code>,
ask yourself how you could be confident that the computed values are correct when
adding two positive numbers can result into a negative one:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="mi">1990000000</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1990000000</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">res0</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">314967296</span></span></span></code></pre></div>
<p>I am well aware that most use cases using <code>Int</code> is perfectly fine,
because they never have numbers big enough to reach this limit.
After all, 10 digits ought to be enough for anybody, right?
In the next sections, you will see that we will reach this limit very often!
Writing an instance of <code>Accumulable</code> for <code>Int</code> is a catastrophic idea.
Instead we will write instances for <code>BigInt</code> and <code>BigDecimal</code>.</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">given</span> <span class="nc">Accumulable</span><span class="o">[</span><span class="kt">BigInt</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">zero</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span> <span class="nc">BigInt</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span><span class="kt">BigInt</span><span class="o">)+(</span><span class="n">y</span><span class="k">:</span><span class="kt">BigInt</span><span class="o">)</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span><span class="kt">BigInt</span><span class="o">)*(</span><span class="n">m</span><span class="k">:</span><span class="kt">BigInt</span><span class="o">)</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="n">m</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">given</span> <span class="nc">Accumulable</span><span class="o">[</span><span class="kt">BigDecimal</span><span class="o">]</span> <span class="k">with</span> <span class="nc">Ratio</span><span class="o">[</span><span class="kt">BigDecimal</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">zero</span><span class="k">:</span> <span class="kt">BigDecimal</span> <span class="o">=</span> <span class="nc">BigDecimal</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span><span class="kt">BigDecimal</span><span class="o">)+(</span><span class="n">y</span><span class="k">:</span><span class="kt">BigDecimal</span><span class="o">)</span><span class="k">:</span> <span class="kt">BigDecimal</span> <span class="o">=</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span><span class="kt">BigDecimal</span><span class="o">)*(</span><span class="n">m</span><span class="k">:</span><span class="kt">BigInt</span><span class="o">)</span><span class="k">:</span> <span class="kt">BigDecimal</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="nc">BigDecimal</span><span class="o">(</span><span class="n">m</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span><span class="kt">BigDecimal</span><span class="o">)/(</span><span class="n">m</span><span class="k">:</span><span class="kt">BigInt</span><span class="o">)</span><span class="k">:</span> <span class="kt">BigDecimal</span> <span class="o">=</span> <span class="n">x</span><span class="o">/</span><span class="nc">BigDecimal</span><span class="o">(</span><span class="n">m</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p>Now we can get out much awaited average:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">h6</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="nc">BigDecimal</span><span class="o">(</span><span class="k">_</span><span class="o">)).</span><span class="n">average</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">res0</span><span class="k">:</span> <span class="kt">BigDecimal</span> <span class="o">=</span> <span class="mf">14.69830127</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Histogram</span><span class="o">(</span><span class="mi">10000000L</span><span class="o">)(</span><span class="nc">BigDecimal</span><span class="o">(</span><span class="n">d6</span><span class="o">.</span><span class="n">rollUntilAllSeen</span><span class="o">())).</span><span class="n">average</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">res1</span><span class="k">:</span> <span class="kt">BigDecimal</span> <span class="o">=</span> <span class="mf">14.6949955</span></span></span></code></pre></div>
<p>As you can see, the average is never far from <em>14.69</em>. Knowing the average is
nice but it does not tell us much about how the length is distributed among
the experiments. This is precisely the reason why we kept counters!
To visualize this data, we can export the histogram as a
<a href="https://en.wikipedia.org/wiki/Comma-separated_values" rel="external" target="_self">CSV file</a>.</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="o">(</span><span class="n">histogram</span><span class="k">:</span> <span class="kt">Histogram</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="n">toCSV</span><span class="o">(</span><span class="n">fileName</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="k">import</span> <span class="nn">java.io._</span>
</span></span><span class="line"><span class="cl">    <span class="k">val</span> <span class="n">pw</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PrintWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="n">fileName</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">    <span class="n">pw</span><span class="o">.</span><span class="n">println</span><span class="o">(</span><span class="s">&#34;value,count&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">length</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">to</span> <span class="n">histogram</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">keySet</span><span class="o">.</span><span class="n">max</span> <span class="k">do</span>
</span></span><span class="line"><span class="cl">      <span class="n">pw</span><span class="o">.</span><span class="n">println</span><span class="o">(</span><span class="s">s&#34;</span><span class="si">$length</span><span class="s">,</span><span class="si">${</span><span class="n">histogram</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="n">length</span><span class="o">,</span> <span class="nc">BigInt</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span><span class="si">}</span><span class="s">&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">pw</span><span class="o">.</span><span class="n">close</span><span class="o">()</span></span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">h6</span><span class="o">.</span><span class="n">toCSV</span><span class="o">(</span><span class="s">&#34;d6.csv&#34;</span><span class="o">)</span></span></span></code></pre></div>
<p>Opening the file <code>d6.csv</code> with <a href="https://www.libreoffice.org/" rel="external" target="_self">LibreOffice</a>
and plotting the data as a <em>XY Chart</em> using the <code>value</code> column as <em>X</em> and <code>count</code>
as <em>Y</em> gives this chart:</p>
<p><a href="#R-image-fb029c0aba1a3ebad655c7aa53224463" class="lightbox-link"><img alt="d6 distribution length/count" class="bg-white border lazy lightbox noshadow figure-image" loading="lazy" src="../assets/posts/probability_in_scala_3_all_sides/d6.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-fb029c0aba1a3ebad655c7aa53224463"><img alt="d6 distribution length/count" class="bg-white border lazy lightbox noshadow lightbox-image" loading="lazy" src="../assets/posts/probability_in_scala_3_all_sides/d6.svg"></a></p>
<p>As you can see, after length 15, there is a huge decrease in the number of
experiments. And after length 50, the number of experiment is almost neglectable.
The situation is similar for other dice. For example, here is the curve for <code>d100</code>:</p>
<p><a href="#R-image-aae1300cb6320887be15a1e7d6a8d90c" class="lightbox-link"><img alt="d100 distribution length/count" class="bg-white border lazy lightbox noshadow figure-image" loading="lazy" src="../assets/posts/probability_in_scala_3_all_sides/d100_distrib.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-aae1300cb6320887be15a1e7d6a8d90c"><img alt="d100 distribution length/count" class="bg-white border lazy lightbox noshadow lightbox-image" loading="lazy" src="../assets/posts/probability_in_scala_3_all_sides/d100_distrib.svg"></a></p>
<p>By running enough experiment, we can get an pretty close estimation of the
average. But an experiment is by nature random, every measure we perform is very
likely to give a (close but still) different estimation of the average. We need
a more reliable way to approximate the average.</p>
<h2 id="modelling-the-problem">Modelling the Problem</h2>
<p>To get a more reliable approximation of the average, or the exact value, we can
not rely on random experiments. We need to use maths! Remember that an experiment
is a sequence of dice rolls such that, as soon as every side of the dice have been
observed at least once, the sequence is over. <em>Given a dice</em>, we will call a
sequence of sides <strong>valid</strong> when it follows these rules.</p>
<p>Using a 3-sided dice:</p>
<ul>
<li>The sequence <code>2→2→1→2</code> is invalid because the side <code>3</code> has not been observed.</li>
<li>The sequence <code>2→2→1→2→3→3</code> is invalid because the sequence needs to stop as
soon as every side has been observed so the last roll is not required.</li>
<li>The sequence <code>2→2→1→2→3</code> is valid: every side has been observed and it was not
possible to stop earlier.</li>
</ul>
<p>Note that the validity depends on the dice used! The sequence <code>2→2→1→2→3</code> is
valid for a 3-sided dice but invalid for a 4-sided dice. To compute the average,
we will: (1) enumerate all valid sequences (up to a certain length), then (2)
sum their length and finally (3) divide by the number of values in the sum.</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">enumerate</span><span class="o">(</span><span class="n">sides</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">depth</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">LazyList</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">aux</span><span class="o">(</span><span class="n">revSeq</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">LazyList</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">revSeq</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">depth</span>
</span></span><span class="line"><span class="cl">    <span class="n">then</span> <span class="nc">LazyList</span><span class="o">.</span><span class="n">empty</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="k">if</span> <span class="n">revSeq</span><span class="o">.</span><span class="n">toSet</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">sides</span>
</span></span><span class="line"><span class="cl">          <span class="n">then</span> <span class="nc">LazyList</span><span class="o">(</span><span class="n">revSeq</span><span class="o">.</span><span class="n">reverse</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">          <span class="k">else</span> <span class="nc">LazyList</span><span class="o">.</span><span class="n">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">sides</span><span class="o">+</span><span class="mi">1</span><span class="o">).</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">next</span> <span class="k">=&gt;</span> <span class="n">aux</span><span class="o">(</span><span class="n">next</span> <span class="k">:</span><span class="kt">:</span> <span class="kt">revSeq</span><span class="o">)</span> <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">aux</span><span class="o">(</span><span class="nc">List</span><span class="o">.</span><span class="n">empty</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">average</span><span class="o">(</span><span class="n">sides</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">depth</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="k">val</span> <span class="n">validSequences</span> <span class="k">=</span> <span class="n">enumerate</span><span class="o">(</span><span class="n">sides</span><span class="o">,</span> <span class="n">depth</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="n">validSequences</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">length</span><span class="o">.</span><span class="n">toDouble</span><span class="o">).</span><span class="n">sum</span> <span class="o">/</span> <span class="n">validSequences</span><span class="o">.</span><span class="n">size</span></span></span></code></pre></div>
<p>For a 3-sided dice, the list of all valid sequences up to length 5 is:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">enumerate</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">mkString</span><span class="o">(</span><span class="s">&#34;→&#34;</span><span class="o">)).</span><span class="n">toList</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">res26</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span>
</span></span><span class="line"><span class="cl">  <span class="mi">1</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">3</span><span class="o">,</span>   <span class="mi">1</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">2</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">  <span class="mi">1</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">3</span><span class="o">,</span>   <span class="mi">1</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">3</span><span class="o">,</span>   <span class="mi">1</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">3</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">  <span class="mi">1</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">2</span><span class="o">,</span>   <span class="mi">1</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">2</span><span class="o">,</span>     <span class="mi">1</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">2</span><span class="o">,</span>   <span class="mi">1</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">2</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">  <span class="mi">2</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">3</span><span class="o">,</span>   <span class="mi">2</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">3</span><span class="o">,</span>   <span class="mi">2</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">3</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">  <span class="mi">2</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">3</span><span class="o">,</span>   <span class="mi">2</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">1</span><span class="o">,</span>   <span class="mi">2</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">1</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">  <span class="mi">2</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">1</span><span class="o">,</span>     <span class="mi">2</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">1</span><span class="o">,</span>   <span class="mi">2</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">1</span><span class="o">,</span>   <span class="mi">2</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">1</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">  <span class="mi">3</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">2</span><span class="o">,</span>   <span class="mi">3</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">2</span><span class="o">,</span>     <span class="mi">3</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">2</span><span class="o">,</span>   <span class="mi">3</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">2</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">  <span class="mi">3</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">1</span><span class="o">,</span>     <span class="mi">3</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">1</span><span class="o">,</span>   <span class="mi">3</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">1</span><span class="o">,</span>   <span class="mi">3</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">1</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">  <span class="mi">3</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">2</span><span class="o">,</span>   <span class="mi">3</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">1</span><span class="o">,</span>   <span class="mi">3</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">1</span><span class="o">→</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">3</span><span class="o">→</span><span class="mi">2</span><span class="o">→</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">  <span class="o">)</span></span></span></code></pre></div>
<p>That&rsquo;s awesome! We just have to average all the lengths:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">average</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">res27</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">4.545454545454546</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">average</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="mi">10</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">res32</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">9.071713147410359</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">average</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="mi">14</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">res36</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">13.00953778429934</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">average</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="mi">16</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">res39</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">15.003205911089399</span></span></span></code></pre></div>
<p>Apparently, computing the average for sequences up to length 16 does not
converge yet. Unfortunately our implementation is to slow for large sequences.
The number of valid sequences grows exponentially over length.
We need a much faster algorithm.</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">aggregate</span><span class="o">[</span><span class="kt">A:Accumulable</span><span class="o">](</span><span class="n">sides</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">depth</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="k">var</span> <span class="n">current</span> <span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">BigInt</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">.</span><span class="n">fill</span><span class="o">(</span><span class="n">sides</span><span class="o">+</span><span class="mi">1</span><span class="o">)(</span><span class="nc">BigInt</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">  <span class="k">var</span> <span class="n">next</span>    <span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">BigInt</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">.</span><span class="n">fill</span><span class="o">(</span><span class="n">sides</span><span class="o">+</span><span class="mi">1</span><span class="o">)(</span><span class="nc">BigInt</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">  <span class="k">var</span> <span class="n">agg</span>     <span class="k">:</span> <span class="kt">A</span>             <span class="o">=</span> <span class="n">summon</span><span class="o">[</span><span class="kt">Accumulable</span><span class="o">[</span><span class="kt">A</span><span class="o">]].</span><span class="n">zero</span>
</span></span><span class="line"><span class="cl">  <span class="k">var</span> <span class="n">length</span>  <span class="k">:</span> <span class="kt">Int</span>           <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">current</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="k">=</span> <span class="nc">BigInt</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="c1">// The empty sequence is the unique sequence where 0 sides have been seen
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="n">length</span> <span class="o">&lt;=</span> <span class="n">depth</span> <span class="k">do</span>
</span></span><span class="line"><span class="cl">    <span class="n">agg</span> <span class="o">+=</span> <span class="n">f</span><span class="o">(</span><span class="n">length</span><span class="o">)</span> <span class="o">*</span> <span class="n">current</span><span class="o">(</span><span class="n">sides</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">seen</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">to</span> <span class="n">sides</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
</span></span><span class="line"><span class="cl">      <span class="n">next</span><span class="o">(</span><span class="n">seen</span><span class="o">)</span>     <span class="o">+=</span> <span class="n">current</span><span class="o">(</span><span class="n">seen</span><span class="o">)</span> <span class="o">*</span> <span class="n">seen</span>
</span></span><span class="line"><span class="cl">      <span class="n">next</span><span class="o">(</span><span class="n">seen</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+=</span> <span class="n">current</span><span class="o">(</span><span class="n">seen</span><span class="o">)</span> <span class="o">*</span> <span class="o">(</span><span class="n">sides</span> <span class="o">-</span> <span class="n">seen</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">length</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="n">current</span> <span class="k">=</span> <span class="n">next</span>
</span></span><span class="line"><span class="cl">    <span class="n">next</span>    <span class="k">=</span> <span class="nc">Array</span><span class="o">.</span><span class="n">fill</span><span class="o">(</span><span class="n">sides</span><span class="o">+</span><span class="mi">1</span><span class="o">)(</span><span class="nc">BigInt</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">agg</span></span></span></code></pre></div>
<p>This is a generic aggregation function that, given a <code>sides</code>-sided dice,
gives to every valid sequence a value that depends only on its length (via <code>f</code>)
and aggregate them over all valid sequences up to a certain length called the
<code>depth</code>. We can use it to compute the average for sequences up to length
<em>100000</em>).</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">depth</span> <span class="k">=</span> <span class="mi">100000</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">depth</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">100000</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">sides</span> <span class="k">=</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">sides</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">sumOfLengths</span> <span class="k">=</span> <span class="n">aggregate</span><span class="o">(</span><span class="n">sides</span><span class="o">,</span><span class="n">depth</span><span class="o">)(</span><span class="n">length</span> <span class="k">=&gt;</span> <span class="nc">BigInt</span><span class="o">(</span><span class="n">length</span><span class="o">))</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">sumOfLengths</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span> <span class="n">A</span> <span class="mi">30109</span> <span class="n">digits</span> <span class="n">positive</span> <span class="n">integer</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">numberOfSeqs</span> <span class="k">=</span> <span class="n">aggregate</span><span class="o">(</span><span class="n">sides</span><span class="o">,</span><span class="n">depth</span><span class="o">)(</span><span class="n">length</span> <span class="k">=&gt;</span> <span class="nc">BigInt</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">numberOfSeqs</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span>  <span class="n">A</span> <span class="mi">30104</span> <span class="n">digits</span> <span class="n">positive</span> <span class="n">integer</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">avegrageUpTo100000</span> <span class="k">=</span> <span class="o">(</span><span class="nc">BigDecimal</span><span class="o">(</span><span class="n">sumOfLengths</span><span class="o">)/</span><span class="n">numberOfSeqs</span><span class="o">).</span><span class="n">toDouble</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">avegrageUpTo100000</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">99999.0</span></span></span></code></pre></div>
<p>The average does not seem to converge. Have a look at previous estimations of the
averages for depths <em>5</em>, <em>10</em>, <em>14</em> and <em>16</em>. The average seem very close to
<em>depth - 1</em>. It seem to indicate that, on average, you need to roll a 3-sided
dice an infinity of times to obverse every side at least once. It means that,
regardless the number of rolls you perform, it is almost certain that you will
never see at least once side. Let&rsquo;s confirm that using the methods of the
previous section:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">d3</span> <span class="k">=</span> <span class="nc">Dice</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">d3</span><span class="k">:</span> <span class="kt">Dice</span> <span class="o">=</span> <span class="nc">Dice</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">h3</span> <span class="k">=</span> <span class="nc">Histogram</span><span class="o">(</span><span class="mi">100000000L</span><span class="o">)(</span><span class="n">d3</span><span class="o">.</span><span class="n">rollUntilAllSeen</span><span class="o">())</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">h3</span><span class="k">:</span> <span class="kt">Histogram</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Histogram</span><span class="o">(</span><span class="nc">HashMap</span><span class="o">(...))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">h3</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="nc">BigDecimal</span><span class="o">(</span><span class="k">_</span><span class="o">)).</span><span class="n">average</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">res6</span><span class="k">:</span> <span class="kt">BigDecimal</span> <span class="o">=</span> <span class="mf">5.5003517</span></span></span></code></pre></div>
<p>The experience shows that, on average, <em>5.5</em> rolls are enough to see every side
of a 3-sided dice. The only possible conclusion is that our modeling is very
wrong.
The problem is we consider every sequence to be equally likely. But the sequence
<code>1→2→3</code> is much likelier to happen than <code>1→2→2→1→2→1→2→1→1→2→1→3</code>. We can plot
the <code>h3</code> histogram to check that the longer a sequence is, the less likely it
is to happen:</p>
<p><a href="#R-image-2e3f8c450b3b63d356128b4c3c27b5a4" class="lightbox-link"><img alt="d3 distribution length/count" class="bg-white border lazy lightbox noshadow figure-image" loading="lazy" src="../assets/posts/probability_in_scala_3_all_sides/d3_distrib.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-2e3f8c450b3b63d356128b4c3c27b5a4"><img alt="d3 distribution length/count" class="bg-white border lazy lightbox noshadow lightbox-image" loading="lazy" src="../assets/posts/probability_in_scala_3_all_sides/d3_distrib.svg"></a></p>
<p>Our real big mistake is our mathematical modeling does not model the real
problem. This is a very important rule in modeling: <strong>models much match
closely the things they are supposed to model</strong>.</p>
<h2 id="understanding-the-experiment">Understanding the Experiment</h2>
<p>To get a mathematical model that closely match the experience, we need to have a
deeper understanding of the problem. When we perform 10000000 experiments, we get
as many valid sequences of sides. But taking the hypothesis that theses sequences
are all distinct is wrong. An experiment is a random process, you may get the
same sequence several times. We need to take into account how often a sequence
is likely to happen.</p>
<p>Given a \(n\)-sided fair dice, by definition of fairness, every time we roll
the dice, for any side, there is exactly \(\frac{1}{n}\) chance to observe this
side. Each roll being independent from other ones, for every sequence of \(m\)
rolls, there is \((\frac{1}{n})^m\) chance to observe this sequence.</p>
<p>Do not jump on the conclusion that the probability of a valid sequence of
length \(m\) in our problem is \((\frac{1}{n})^m\) yet! If we change the
problem slightly by requiring that every side is observed <strong>exactly</strong> once
(ignoring sequences where one side is observed several times). Then for a coin
there is only 2 valid sequences <code>1→2</code> and <code>2→1</code>, each equally likely so they both
have probability \(\frac{1}{2}\), not \(\frac{1}{4}\). The good way to
proceed is finding a probability space that models correctly the problem.</p>
<p>Remember that the dice used has been fixed as a \(n\)-sided fair dice.
The first step in defining a probability space is defining the outcomes. Outcomes
are the results of statistical experiments. It our problem, outcomes are the
valid sequences of dice rolls. Then we need to define the set of events. Events
are the things whose likelihood we want to measure! For example: what is the
probability that a valid sequence starts with <code>1</code>, or what is the probability
that a valid sequence is a palindrome (i.e. the reverse of the sequence is the
sequence itself),etc. It feels natural, in our situation, to consider as event,
any set of valid sequences. Last but not least, we need the probability function.
Its purpose is to give, for any event, the likelihood of this event. Informally,
a probability function must satisfy 3 properties:</p>
<ol>
<li>the likelihood of any event must be <strong>positive or null</strong> but never negative!</li>
<li>the likelihood of <strong>distinct</strong> events is the sum of the likelihood of every event.</li>
<li>the likelihood of the set of <strong>all</strong> valid sequences must be <em>1</em>.</li>
</ol>
<p>This is where things get complicated. We can decide to give to any valid sequence
of size \(m\) the the probability (\((\frac{1}{n})^m\)), but we need to prove
that this function satisfies all the conditions above to be a probability
function.
In addition, the set of valid sequences is not that trivial to work with (at
least for me!). Fortunately working in this probability space is not mandatory.
We can work in more comfortable probability space as long as we are able to
transpose results into this one.</p>
<p>Remember that the dice being used is a \(n\)-sided fair dice. Let us start by
some definitions:</p>
<ul>
<li>
<p>Let \(\mathcal{C}_n=\{1,\dots,n\}\) be the set of the dice&rsquo;s sides.</p>
</li>
<li>
<p>The set of <em>countably infinite sequences of sides</em> is written \(\Omega\).</p>
</li>
<li>
<p>The set of <em>finite sequences of sides</em> is written \(\mathcal{F}\).</p>
</li>
<li>
<p>For any <em>finite sequence of sides</em> \(f \in \mathcal{F}\), its length is written \(|f|\).</p>
</li>
<li>
<p>For any sequence \(s \in \mathcal{F} \cup \Omega\) of sides (finite or infinite),
let \(\diamond s\) be the set of sides observed in \(s\)
and \(\sharp s\) be the number of distinct sides observed in \(s\), i.e.
\(\sharp s = |\diamond s|\).</p>
</li>
<li>
<p>For any sequence \(s \in \mathcal{F} \cup \Omega\) of sides (finite or infinite),
and any \(i \in \{1,\dots,|s]\}\), let \(s_{[i]}\) be the sides observed at
the \(i\)-th roll of \(s\), i.e. \(s=(s_{[1]},\dots,s_{[|s|]})\).</p>
</li>
<li>
<p>For any \(f \in \mathcal{F}\) and \(f' \in \mathcal{F}\cup\Omega\),
where \(f = (s_1,\dots,s_i)\) and
\(f' = (s'_1,\dots)\), we write \(f \cdot f' \in \mathcal{F}\cup\Omega\) the
concatenation of \(f\) and \(f'\), i.e. the <em>sequence</em>
\((s_1,\dots,s_i,s'_1,\dots)\).
Furthermore, for any set of <em>prefix</em> \(F \subset \mathcal{F}\),
and any set set of (finite or infinite) sequences \(S\subset \mathcal{F}\cup\Omega\),
we write \(F\cdot S = \{f\cdot s\mid f\in F,\ s\in S\}\) the set of
sequences made of concatenations of \(F\) and \(S\).</p>
</li>
</ul>
<p>For the new probability space, we can take as outcomes \(\Omega\), the set of
all <strong>infinite</strong> (but countable) sequence of sides.
Given a finite sequence of sides \(f \in \mathcal{F}\) (possibly empty),
the set of all outcomes (infinite sequences) that start with \(f\)
is called a <strong>prefix event</strong> and written \(\mathcal{E}(f)\).
The finite sequence \(f \in \mathcal{F}\) is called a <strong>prefix</strong>.
Note that the set of all outcomes, \(\Omega\), is an event because
it is the <em>prefix event</em> of the empty sequence \(\epsilon\).
The set of all <em>prefix events</em> is written \(\mathcal{E}\).
We will take as events the the <a href="https://en.wikipedia.org/wiki/%CE%A3-algebra" rel="external" target="_self">σ-field</a>
\(\sigma(\mathcal{E})\) generated from <em>prefix events</em>, i.e. the smallest
<em>σ-field</em> containing <em>prefix events</em> that is closed under complement, countable
unions and intersections.
It means that any countable union or intersection of events is an event and
the complement of any event is an event.
Let \(F\subset \mathcal{F}\) be a <strong>finite or countable</strong> set of <em>prefixes</em>,
we write \(\mathcal{E}(F)\) the event \(\bigcup_{f\in F} \mathcal{E}(f)\).</p>
<p>The class of sets \(\mathcal{R} = \mathcal{E} \cup \{\emptyset\} \) is a
<a href="https://en.wikipedia.org/wiki/Ring_of_sets" rel="external" target="_self">semiring of sets</a>.
It comes from two facts. Let \(f_1, f_2\in \mathcal{F}\) be two <em>prefixes</em>.
Either \(\mathcal{E}(f_1)\) and \(\mathcal{E}(f_2)\) are disjoint, or one
is contained in the other.
It proves that \(\mathcal{R}\) is table by finite intersection.
If \(\mathcal{E}(f_2) \subset \mathcal{E}(f_1)\) then there exists
\(f_3\in \mathcal{F}\) such that \(f_2 = f_1 \cdot f_3\) and
\(\mathcal{E}(f) = \bigcup_{f_4\in \mathcal{F}, |f_4|=|f_3|} \mathcal{E}(f \cdot f_4)\).
It proves that \(\mathcal{E}(f_1) \setminus \mathcal{E}(f_2)\) can be written
as a finite union of disjoint element of \(\mathcal{R}\).</p>
<p>Instead of defining the probability function \(p\) directly over
\(\sigma(\mathcal{E})\), \(p\) is defined over \(\mathcal{R}\) first and
then extended to \(\sigma(\mathcal{E})\) using
<a href="https://en.wikipedia.org/wiki/Carath%C3%A9odory%27s_extension_theorem" rel="external" target="_self">Carathéodory&rsquo;s extension theorem</a>.
\(p\) is defined on \(\mathcal{R}\) by</p>
$$\begin{aligned}
p(\emptyset)                                          & = 0
\\ \forall f \in \mathcal{F}\quad p(\mathcal{E}(f)) & = (\frac{1}{n})^{|f|}
\end{aligned}$$<p>\(p\) is additive and σ-subadditive because the only way for the union of two
disjoint elements of \(\mathcal{R}\) to be in \(\mathcal{R}\) is if one of
the two is the empty set. It is also σ-finite because
\(p(\Omega) = p(\mathcal{E}(\epsilon)) = (\frac{1}{n})^{0} = 1\).
The function \(p\) can then be uniquely extended into a <em>probability function</em>
over \(\sigma(\mathcal{E})\).</p>
<p>Note that:</p>
$$\begin{aligned}
\forall f_1,f_2\in \mathcal{F},\quad p(\mathcal{E}(f_1\cdot f_2))
    & = p(\mathcal{E}(f_1)) \times p(\mathcal{E}(f_2))
\\    \forall f\in \mathcal{F},\quad p(\mathcal{E}(f))
    & = \prod_{i=1}^{|f|}p(\mathcal{E}(f_{[i]}))
\end{aligned}$$<p>The <em>probability space</em> \((\Omega,\sigma(\mathcal{E}),p)\) has the very
pleasing property that the probability of a <em>prefix event</em> \(\mathcal{E}(f)\)
is exactly the probability of getting the sequence \(f\) with \(|f|\) dice
rolls. There is a problem though: there are outcomes for which not every side
has been observed at least once. The infinite sequence \((1,\dots)\) is such
an outcome.</p>
<p>Let \(M\) the subset of outcomes such that at least one side has not been
observed, i.e. \( M = \{ \omega \in \Omega \mid \sharp \omega < n \} \).
We want to know how likely \(M\) is.
For any \(i \in \mathbb{N} \), let \(M_i\) the set of outcomes such at least
one side has not been observed up to the \(i\)-th roll,
i.e. \(M_i = \mathcal{E}(\{f \in \mathcal{F}\mid |f|=i,\ \sharp f < n\})\).</p>
<p>For any \(i\in \mathbb{N}\),
\(M_i\) is an event because it is a finite union of events.
Not observing at least one side with an infinity of rolls is equivalent to not
observing this side for every \(i\)-th roll, so
\(M = \bigcap_{i\in\mathbb{N}} M_i\).
From the last equation, we can conclude that \(M\) is an event because
it is a countable intersection of events.
Furthermore, given \(i\) dice rolls, the probability of not observing a given
side is \((\frac{n-1}{n})^i\) so
\(p(M_i) \le n \times (\frac{n-1}{n})^i\).
Note that \(M_{i+1} \subset M_i\), so
\(\bigcap_{j=0}^i M_j = M_i\).
We can conclude that the probability, given an infinity of dice rolls, of never
observing one side (anyone) is \(0\):</p>
$$ p(M) =
   p(\bigcap_{i\in\mathbb{N}} M_i) =
   \lim_{i\rightarrow\infty} p(M_i) \le
   \lim_{i\rightarrow\infty} n \times \Bigl(\frac{n-1}{n}\Bigr)^i =
   0 $$<p>Note that it does not mean these outcome are impossible. In theory, if you flip
a coin endlessly, it is possible to always get head (resp. tail), but this is
incredibly unlikely. Let \(\Omega' = \overline{M}\) be set of outcomes such
that every side has been observed at least once. \(\Omega'\) is the complement
of \(M\), written \(\overline{M}\). Its probability is then
\(p(\Omega') = 1\). So for any event \(E\in\sigma(\mathcal{E})\),
\(p(E) = p(E\cap\Omega') + p(E\cap M)\), but \(p(E\cap M) \le p(M) = 0\),
so</p>
$$\forall E\in\sigma(\mathcal{E})\quad p(E) = p(E\cap\Omega')$$<p>Informally, it means we can assume that, in every outcome, every side of the dice
are observed at least once.
More precisely, we take as <em>probability space</em>, the restriction of
\((\Omega,\sigma(\mathcal{E}),p)\) to \(\Omega'\), written
\((\Omega',\sigma(\mathcal{E})|_{\Omega'},p)\).</p>
<p>How does the problem translates into this probability space? Remember that an
outcome \(\omega \in \Omega'\) is an <strong>infinite</strong> sequence
\((s_1,s_2,\dots)\) of sides \(s_i \in \mathcal{C}_n\) such that every
every side is observed at some point.
For any \(m \in \{0,\dots,n\}\) we define the <strong>random variable</strong>
\(X_m\) as the function, from \(\Omega'\) to
\(\mathbb{R}\),  that maps any outcome
\(\omega \in \Omega' = (s_1,s_2,\dots)\) to the first \(i\) such
that \(m\) side has been observed at least once.</p>
$$\forall \omega = (s_i)_{i\ge 1}\in \Omega', \quad
  X_m(\omega) =
  \inf_i \bigl\{ i \mid \sharp (s_1,\dots,s_i) = m \bigr\}$$<p>Note that \(X_n(\omega)\) is the number of rolls needed to observe every side
of the chosen dice at least once. The average we are looking for is actually
the <a href="https://en.wikipedia.org/wiki/Expected_value" rel="external" target="_self">expected value</a>
of \(X_n\). But for the expected value to defined, \(X_m\) has to be a
<a href="https://en.wikipedia.org/wiki/Measurable_function" rel="external" target="_self">measurable function</a> from
\((\Omega',\sigma(\mathcal{E})|_{\Omega'})\)
to
\((\mathbb{R},\mathcal{B}(\mathbb{R}))\).
Let \(F_{m,l}\) be the set of <em>prefixes</em> \(f=(s_1,\dots,s_l)\) of length
\(l\) such that \(l\) is the first roll for which exactly \(m\) sides
have been observed at least once, i.e.
\(l = \inf_i\{i \mid \sharp (s_1,\dots,s_i) = m \}\).
Then
</p>
$$ X_m =
   \sum_{l\in\mathbb{N}}
   \sum_{f \in F_{m,l}} l \times \mathbb{1}_{\mathcal{E}(f)\cap \Omega'} $$<p>
and so \(X_m\) is indeed measurable. The <em>expected value</em> is:</p>
$$\begin{aligned}
\mathbb{E}(X_m) & = \sum_{l\in\mathbb{N}} l\times p(X_m^{-1}(l))
\\             & = \sum_{l\in\mathbb{N}}
                       \sum_{f \in F_{m,l}} l \times p(\mathcal{E}(f))
\\             & = \sum_{l\in\mathbb{N}}
                        \sum_{f \in F_{m,l}} l \times \Bigl(\frac{1}{n}\Bigr)^l
\\             & = \sum_{l\in\mathbb{N}} |F_{m,l}| \times l \times \Bigl(\frac{1}{n}\Bigr)^l
\end{aligned}$$<p>The mistake we did in the last section is now clear. We computed
\(\sum_{l\in\mathbb{N}} |F_{m,l}| \times l\)
instead of
\(\sum_{l\in\mathbb{N}} |F_{m,l}| \times l \times (\frac{1}{n})^l\).
We just have to fix the function used in the aggregation to compute the right
value:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">forOneValidPrefix</span><span class="o">(</span><span class="n">sides</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)(</span><span class="n">length</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">BigDecimal</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="o">(</span><span class="nc">BigDecimal</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="n">sides</span><span class="o">).</span><span class="n">pow</span><span class="o">(</span><span class="n">length</span><span class="o">)</span> <span class="o">*</span> <span class="n">length</span></span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">depth</span> <span class="k">=</span> <span class="mi">100000</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">depth</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">100000</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">sides</span> <span class="k">=</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">sides</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">expectedValueFor100000</span> <span class="k">=</span> <span class="n">aggregate</span><span class="o">(</span><span class="n">sides</span><span class="o">,</span><span class="n">depth</span><span class="o">)(</span><span class="n">forOneValidPrefix</span><span class="o">(</span><span class="n">sides</span><span class="o">))</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">expectedValueFor100000</span><span class="k">:</span> <span class="kt">BigDecimal</span> <span class="o">=</span> <span class="mf">5.499999999999999999999999999999999</span></span></span></code></pre></div>
<p>This time the computed value match what we observed with random experiments,
a value around \(5.5\). It also match the average we got for a 6-sided fair
dice:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">depth</span> <span class="k">=</span> <span class="mi">10000</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">depth</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">10000</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">sides</span> <span class="k">=</span> <span class="mi">6</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">sides</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">6</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">expectedValueFor100000</span> <span class="k">=</span> <span class="n">aggregate</span><span class="o">(</span><span class="n">sides</span><span class="o">,</span><span class="n">depth</span><span class="o">)(</span><span class="n">forOneValidPrefix</span><span class="o">(</span><span class="n">sides</span><span class="o">))</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">expectedValueFor100000</span><span class="k">:</span> <span class="kt">BigDecimal</span> <span class="o">=</span> <span class="mf">14.70000000000000000000000000000001</span></span></span></code></pre></div>
<p>We can actually go a bit deeper by observing that for any \(m \in \{1,\dots,n\}\),
\(\mathbb{E}(X_m) = \mathbb{E}(X_{m-1}) + \mathbb{E}(X_m - X_{m-1})\):</p>
$$\begin{aligned}
     \mathbb{E}(X_m)           & = \sum_{i=0}^{m-1} \mathbb{E}(X_{i+1} - X_i)
\\ \mathbb{E}(X_{i+1}-X_i)  & = \sum_{d\in\mathbb{N}^*} d \times p((X_{i+1}-X_i)^{-1}(d))
\\ p((X_{i+1}-X_i)^{-1}(d)) & = \sum_{k\in\mathbb{N}} p(\mathcal{E}(F_{i+1,k+d})
                                                           \cap \mathcal{E}(F_{i,k}))
\\p(\mathcal{E}(F_{i+1,k+d})\cap \mathcal{E}(F_{i,k}))
    & = p(\mathcal{E}(\{f \cdot f' \cdot c \mid
            f\in F_{i,k},\quad |f'|=d-1,\ \diamond f' \subset \diamond f,\quad c\in \mathcal{C}_n\setminus\diamond f
            \}))
\\& = \sum_{f\in F_{i,k}} \Biggl(
        \sum_{|f'|=d-1,\ \diamond f' \subset \diamond f} \Biggl(
        \sum_{c\in \mathcal{C}_n\setminus \diamond f}
        p(\mathcal{E}(f \cdot f' \cdot c)) \Biggr)\Biggr)
\\& = \sum_{f\in F_{i,k}} \Biggl( p(\mathcal{E}(f)) \times
        \sum_{|f'|=d-1,\ \diamond f' \subset \diamond f} \Biggl( p(\mathcal{E}(f')) \times
        \sum_{c\in \mathcal{C}_n\setminus \diamond f}
        p(\mathcal{E}(c)) \Biggr)\Biggr)
\\& = \sum_{f\in F_{i,k}} \Biggl( p(\mathcal{E}(f)) \times
        |\{f'\in \mathcal{F} \mid |f'|=d-1,\ \diamond f' \subset \diamond f\}|
        \times \Bigl(\frac{1}{n}\Bigr)^{d-1} \times \frac{n-i}{n}
        \Biggr)
\\& = \Bigl(\frac{i}{n}\Bigr)^{d-1} \times \frac{n-i}{n} \times p(\mathcal{E}(F_{i,k}))
\end{aligned}$$<p>So
\(p(\mathcal{E}(F_{i+1,k+d}) | \mathcal{E}(F_{i,k}))
   = (\frac{i}{n})^{d-1}\times \frac{n-1}{n} \). So
\(p(\mathcal{E}(F_{i+1,k+d}) | \mathcal{E}(F_{i,k}))
   = (\frac{i}{n})^{d-1}\times \frac{n-1}{n} \). So
\(\mathbb{E}(X_{i+1} - X_i)
  = \sum_{d\in\mathbb{N}^*} d \times \frac{n-1}{n}\times (\frac{i}{n})^{d-1} \).</p>
<p>We recognize a
<a href="https://en.wikipedia.org/wiki/Geometric_distribution" rel="external" target="_self">Geometric Distribution</a>
whose probability of success is \(p' = \frac{n-i}{n}\). Its expected value is
known to be \(\frac{1}{p'} = \frac{n}{n-i}\). It can be computed by</p>
$$\begin{aligned}
\mathbb{E}(X_{i+1} - X_i) & = \sum_{d\in\mathbb{N}^*} d \times \frac{n-i}{n}\times \Bigl(\frac{i}{n}\Bigr)^{d-1}
\\& = \frac{n-i}{n} \times \sum_{d\in\mathbb{N}^*} d \times \Bigl(\frac{i}{n}\Bigr)^{d-1}
\\& = \frac{n-i}{n} \times \sum_{d\in\mathbb{N}^*} d \times \Bigl(\frac{i}{n}\Bigr)^{d-1}
\end{aligned}$$<p>But
</p>
$$\begin{aligned}
\sum_{d\in\mathbb{N}^\star} d \times x^{d-1} & = \sum_{d\in\mathbb{N}^\star} (x^d)^\prime
\\& = \Bigl(\sum_{d\in\mathbb{N}^\star} x^d\Bigr)^\prime
\\& = \Bigl(\frac{x}{1 - x}\Bigr)^\prime
\\& = \frac{1}{(1 - x)^2}
\end{aligned}$$<p>So
</p>
$$\begin{aligned}
\mathbb{E}(X_{i+1} - X_i) & = \frac{n-i}{n} \times \frac{1}{(1 - \frac{i}{n})^2}
\\& = \frac{n-i}{n} \times \Bigl(\frac{n}{n - i}\Bigr)^2
\\& = \frac{n}{n - i}
\end{aligned}$$<p>Finally we can give the formula for the <em>expected value</em> and check that it gives
the expected values:</p>
$$ \mathbb{E}(X_n) = \sum_{i=0}^{n-1} \frac{n}{n-i} $$<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">expectedValue</span><span class="o">(</span><span class="n">sides</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="n">sides</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">sides</span><span class="o">.</span><span class="n">toDouble</span> <span class="o">/</span> <span class="k">_</span><span class="o">).</span><span class="n">sum</span></span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">expectedValue</span><span class="o">(</span><span class="mi">6</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">res0</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">14.7</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">expectedValue</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">res1</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">5.5</span></span></span></code></pre></div>
<h2 id="understanding-the-probability">Understanding the Probability</h2>
<p>Still given a \(n\)-sided fair dice \(n>0\).
Let \(C \subset \mathcal{C}_n\) be a subset
of the sides of the dice and \(l \in \mathbb{N}\) a non-negative integer.
The event of all outcomes whose <em>prefixes</em> of length \(l\) do not contain any
side in \(C\) is written</p>
$$M_{n,l,C} = \mathcal{E}(\{ f\in \mathcal{F} \mid |f|=l,\quad \diamond f \cap C = \emptyset \}$$<p>Note that for any subsets \(C_1\) and \(C_2\) of \(\mathcal{C}_n\) and
\(l\in\mathbb{N}\), the property
\(M_{n,l,C_1}\cap M_{n,l,C_1} = M_{n,l,C_1\cup C_2}\) holds and
\(p(M_{n,l,C}) = (\frac{n - |C|}{n})^l = (1 - \frac{|C|}{n})^l\).
Let \(A_{n,l}\) be the event of all outcomes whose <em>prefixes</em> of size \(l\)
contain every side of the dice at least once:</p>
$$\begin{aligned}
A_{n,l} & = \mathcal{E}(\{ f\in \mathcal{F} \mid |f|=l,\quad \diamond f = C_n \}
\\      & = \bigcap_{c\in \mathcal{C}_n} \overline{M_{n,l,\{c\}}}
\\      & = \overline{\bigcup_{c\in C} M_{n,l,\{c\}}}
\end{aligned}$$$$\begin{aligned}
p(A_{n,l}) & = 1 - p(\bigcup_{c \in C_n} M_{n,l,\{c\}})
\\         & = 1 - \Biggl[\sum_{C \subset C_n,C\neq\emptyset} -(-1)^{|C|} \times p(\bigcap_{c\in C}
                M_{n,l,\{c\}})\Biggr]
\\         & = 1 - \Biggl[\sum_{C \subset C_n,C\neq\emptyset} -(-1)^{|C|} \times p(M_{n,C,l})\Biggr]
\\         & = 1 + \Biggl[\sum_{C \subset C_n,C\neq\emptyset} (-1)^{|C|} \times \biggl(\frac{1-|C|}{n}\biggr)^{l}\Biggr]
\\          & = 1 + \sum_{k=1}^{n} \binom{n}{k} \times (-1)^k \times \biggl(1 - \frac{k}{n}\biggr)^{l}
\end{aligned}$$<p>We can generalize this result: given a \(n\)-sided fair dice and
\(C \subset \mathcal{C}_n\) a subset of the sides of the dice. Let \(A_{n,l,C}\)
be the set of outcomes whose <em>prefixes</em> of length \(l\) do contain only sides
of \(C\) and every side of \(C\):</p>
$$\begin{aligned}
A_{n,l,C} & = \mathcal{E}(\{f\in \mathcal{F} \mid |f|=n, \quad \diamond f = C\})
\\p(A_{n,l,C}\mid M_{n,l,\overline{C}}) & = p(A_{l,|C|})
\\\                                         & = 1 + \sum_{k=1}^{|C|} \binom{|C|}{k} \times (-1)^k \times \biggl(1 - \frac{k}{|C|}\biggr)^{l}
\end{aligned}$$<p>We found the probability of observing, in \(l\) dice rolls <strong>or less</strong>, a subset
of all the sides. But \(A_{n,l,C}\) is not in general \(X_n^{-1}(\{l\})\)
because outcomes in \(X_n^{-1}(\{l\})\) reach the last observed side at roll
\(l\) while outcomes in \(A_{n,l}\) may have observed every side much before
the \(l\)-th roll.
But we can relate the two.
For any side \(c \in \mathcal{C}_n\) and any non-negative integer \(i\in\mathbb{N}\),
let \(R_{n,i,c}\) the event of observing the side \(c\) at roll \(i\).
Let \(l\in\mathbb{N}^*\):</p>
$$\begin{aligned}
X_n^{-1}(\{l\})        & = \bigcup_{c=1}^n A_{n,l-1,C_n\setminus\{c\}}
                                               \cap M_{n,l-1,\{c\}}
                                               \cap R_{n,l,c}
\\p(X_n^{-1}(\{l\})) & = \sum_{c=1}^n p(A_{n,l-1,C_n\setminus\{c\}}
                                              \cap M_{n,l-1,\{c\}}
                                              \cap R_{n,l,c})
\\                      & = \sum_{c=1}^n p(A_{n,l-1,C_n\setminus\{c\}} \mid M_{n,l-1,\{c\}})
                                            \times p(M_{n,l-1,\{c\}})
                                            \times \frac{1}{n}
\\                      & = \sum_{c=1}^n p(A_{n-1,l-1})
                                            \times \biggl(\frac{n-1}{n}\biggr)^{l-1}
                                            \times \frac{1}{n}
\\                      & = \biggl(\frac{n-1}{n}\biggr)^{l-1} \times p(A_{n-1,l-1})
\\                      & = \biggl(\frac{n - 1}{n}\biggr)^{l-1} \times
                              \Biggl[ 1 + \sum_{k=1}^{n-1} \binom{n-1}{k} \times (-1)^k \times \biggl(\frac{n - 1 - k}{n-1}\biggr)^{l-1} \Biggr]
\\                      & = \biggl(1 - \frac{1}{n}\biggr)^{l-1}
                              +
                              \sum_{k=1}^{n-1} \binom{n-1}{k} \times (-1)^k \times \biggl(1 - \frac{k+1}{n}\biggr)^{l-1}
\end{aligned}$$<p>We need to be careful when translating this formula to avoid computation
approximations to lead to very wrong answers:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">probabilityForLength</span><span class="o">(</span><span class="n">sides</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">length</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">BigDecimal</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">cnk</span><span class="o">(</span><span class="n">k</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="n">dfact</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">k</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">res</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span> <span class="nc">BigInt</span><span class="o">(</span><span class="mi">1L</span><span class="o">))</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">      <span class="n">then</span> <span class="n">res</span>
</span></span><span class="line"><span class="cl">      <span class="k">else</span> <span class="n">dfact</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">res</span><span class="o">*</span><span class="n">n</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">dfact</span><span class="o">(</span><span class="n">f</span><span class="o">,</span><span class="n">k</span><span class="o">)</span> <span class="o">/</span> <span class="n">dfact</span><span class="o">(</span><span class="n">k</span><span class="o">,</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="n">sides</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">length</span> <span class="o">==</span> <span class="mi">0</span> <span class="n">then</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">sides</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">length</span> <span class="o">==</span> <span class="mi">0</span> <span class="n">then</span>
</span></span><span class="line"><span class="cl">      <span class="nc">BigDecimal</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">      <span class="nc">BigDecimal</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="o">((</span><span class="nc">BigDecimal</span><span class="o">(</span><span class="n">sides</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)/</span><span class="n">sides</span><span class="o">).</span><span class="n">pow</span><span class="o">(</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">      <span class="nc">BigDecimal</span><span class="o">(</span>
</span></span><span class="line"><span class="cl">        <span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="o">(</span><span class="n">sides</span><span class="o">-</span><span class="mi">1</span><span class="o">)).</span><span class="n">map</span> <span class="o">{</span> <span class="o">(</span><span class="n">k</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="o">(</span> <span class="n">cnk</span><span class="o">(</span><span class="n">k</span><span class="o">,</span><span class="n">sides</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">            <span class="o">*</span> <span class="o">(</span><span class="k">if</span> <span class="n">k</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="n">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">            <span class="o">*</span> <span class="nc">BigInt</span><span class="o">(</span><span class="n">sides</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">k</span><span class="o">).</span><span class="n">pow</span><span class="o">(</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">          <span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">}.</span><span class="n">sum</span>
</span></span><span class="line"><span class="cl">      <span class="o">)</span> <span class="o">/</span> <span class="nc">BigDecimal</span><span class="o">(</span><span class="n">sides</span><span class="o">).</span><span class="n">pow</span><span class="o">(</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">)</span></span></span></code></pre></div>
<p>We can check that the probability of observing all the sides of a 120-sided dice
in less than 120 rolls is indeed 0:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">probabilityForLength</span><span class="o">(</span><span class="mi">120</span><span class="o">,</span> <span class="mi">13</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">res0</span><span class="k">:</span> <span class="kt">BigDecimal</span> <span class="o">=</span> <span class="mi">4</span><span class="n">E</span><span class="o">-</span><span class="mi">34</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">probabilityForLength</span><span class="o">(</span><span class="mi">120</span><span class="o">,</span> <span class="mi">42</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">res1</span><span class="k">:</span> <span class="kt">BigDecimal</span> <span class="o">=</span> <span class="mf">8.751991852311394833964673845157515E-34</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">probabilityForLength</span><span class="o">(</span><span class="mi">120</span><span class="o">,</span> <span class="mi">99</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">res2</span><span class="k">:</span> <span class="kt">BigDecimal</span> <span class="o">=</span> <span class="mf">1.468941911574859178966522092677385E-33</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">probabilityForLength</span><span class="o">(</span><span class="mi">120</span><span class="o">,</span> <span class="mi">119</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">res3</span><span class="k">:</span> <span class="kt">BigDecimal</span> <span class="o">=</span> <span class="mf">1.529470021201154499656736868919480E-33</span></span></span></code></pre></div>
<p>Note that the very small numbers we get for 42, 99 and 119 rolls instead of 0
are due approximations in computing with so big and small numbers.
To get a better idea of how the probability behaves we can, as usual,
export it as a CSV file. Let us start by defining the probability for every
length using a stream:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">probaD120</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">          <span class="nc">LazyList</span>
</span></span><span class="line"><span class="cl">            <span class="o">.</span><span class="n">iterate</span><span class="o">(</span><span class="mi">0</span><span class="o">)(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">            <span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">length</span> <span class="k">=&gt;</span> <span class="n">length</span> <span class="o">-&gt;</span> <span class="n">probabilityForLength</span><span class="o">(</span><span class="mi">120</span><span class="o">,</span> <span class="n">length</span><span class="o">))</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">probaD120</span><span class="k">:</span> <span class="kt">LazyList</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">BigDecimal</span><span class="o">)]</span> <span class="k">=</span> <span class="nc">LazyList</span><span class="o">(&lt;</span><span class="n">not</span> <span class="n">computed</span><span class="o">&gt;)</span></span></span></code></pre></div>
<p>And write this stream up to some length into a CSV file:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="o">(</span><span class="n">self</span><span class="k">:</span> <span class="kt">LazyList</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">BigDecimal</span><span class="o">)])</span> <span class="n">plot</span><span class="o">(</span><span class="n">depth</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">file</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="k">import</span> <span class="nn">java.io._</span>
</span></span><span class="line"><span class="cl">  <span class="k">val</span> <span class="n">pw</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PrintWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="n">file</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">  <span class="n">pw</span><span class="o">.</span><span class="n">println</span><span class="o">(</span><span class="s">&#34;length;probability&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="o">(</span><span class="n">length</span><span class="o">,</span> <span class="n">proba</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">self</span><span class="o">.</span><span class="n">take</span><span class="o">(</span><span class="n">depth</span><span class="o">)</span> <span class="k">do</span>
</span></span><span class="line"><span class="cl">    <span class="n">pw</span><span class="o">.</span><span class="n">printf</span><span class="o">(</span><span class="s">&#34;%d;%f\n&#34;</span><span class="o">,</span> <span class="n">length</span><span class="o">,</span> <span class="n">proba</span><span class="o">.</span><span class="n">toDouble</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="n">pw</span><span class="o">.</span><span class="n">close</span></span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">probaD120</span><span class="o">.</span><span class="n">plot</span><span class="o">(</span><span class="mi">1500</span><span class="o">,</span> <span class="s">&#34;/tmp/d120.csv&#34;</span><span class="o">)</span></span></span></code></pre></div>
<p><a href="#R-image-0f36512709e475b02eadebe49f297eee" class="lightbox-link"><img alt="d120 density length/probability" class="bg-white border lazy lightbox noshadow figure-image" loading="lazy" src="../assets/posts/probability_in_scala_3_all_sides/d120_distrib.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0f36512709e475b02eadebe49f297eee"><img alt="d120 density length/probability" class="bg-white border lazy lightbox noshadow lightbox-image" loading="lazy" src="../assets/posts/probability_in_scala_3_all_sides/d120_distrib.svg"></a></p>
<p>There is a lot of things we can do thanks to this probability like asking how
many rolls we need to observe all the sides of dice 9 times out of 10.
The probability of observing all the sides of the dice in <strong>exactly or less than</strong>
\(l\) rolls is given by</p>
$$p(X_n \le l) = \sum_{l'=0}^{l} p(X_n = l')$$<p>All we need to do is transform the stream <code>probaD120</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span>,<span class="kt">C</span><span class="o">](</span><span class="n">ll</span><span class="k">:</span> <span class="kt">LazyList</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="n">foldP</span><span class="o">(</span><span class="n">z</span><span class="k">:</span> <span class="kt">B</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">B</span><span class="o">,</span><span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">B</span><span class="o">,</span><span class="n">C</span><span class="o">))</span><span class="k">:</span> <span class="kt">LazyList</span><span class="o">[</span><span class="kt">C</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="nc">LazyList</span><span class="o">.</span><span class="n">unfold</span><span class="o">((</span><span class="n">ll</span><span class="o">,</span><span class="n">z</span><span class="o">))</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">l0</span><span class="o">,</span> <span class="n">z0</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="n">l0</span><span class="o">.</span><span class="n">isEmpty</span> <span class="n">then</span>
</span></span><span class="line"><span class="cl">        <span class="nc">None</span>
</span></span><span class="line"><span class="cl">      <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="k">val</span> <span class="o">(</span><span class="n">z1</span><span class="o">,</span><span class="n">c0</span><span class="o">)</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="n">z0</span><span class="o">,</span><span class="n">l0</span><span class="o">.</span><span class="n">head</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="nc">Some</span><span class="o">((</span><span class="n">c0</span><span class="o">,</span> <span class="o">(</span><span class="n">l0</span><span class="o">.</span><span class="n">tail</span><span class="o">,</span><span class="n">z1</span><span class="o">)))</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="o">(</span><span class="n">self</span><span class="k">:</span> <span class="kt">LazyList</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">BigDecimal</span><span class="o">)])</span> <span class="n">cumul</span><span class="k">:</span> <span class="kt">LazyList</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">BigDecimal</span><span class="o">)]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">self</span><span class="o">.</span><span class="n">foldP</span><span class="o">(</span><span class="nc">BigDecimal</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="o">(</span><span class="n">l</span><span class="o">,</span><span class="n">p</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">s</span><span class="o">+</span><span class="n">p</span><span class="o">,</span> <span class="n">l</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">s</span><span class="o">+</span><span class="n">p</span><span class="o">))</span> <span class="o">}</span></span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">distribD120</span> <span class="k">=</span> <span class="n">probaD120</span><span class="o">.</span><span class="n">cumul</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">distribD120</span><span class="k">:</span> <span class="kt">LazyList</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">BigDecimal</span><span class="o">)]</span> <span class="k">=</span> <span class="nc">LazyList</span><span class="o">(&lt;</span><span class="n">not</span> <span class="n">computed</span><span class="o">&gt;)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">distribD120</span><span class="o">.</span><span class="n">dropWhile</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">_2</span> <span class="o">&lt;</span> <span class="mf">0.9</span><span class="o">).</span><span class="n">head</span><span class="o">.</span><span class="n">_1</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">res5</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">842</span></span></span></code></pre></div>
<p>There is 90% chance that we observe all sides of the 120-sided fair dice with 842
rolls. Once again, we can get a better idea of how the distribution behaves by
plotting it</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">distribD120</span><span class="o">.</span><span class="n">plot</span><span class="o">(</span><span class="mi">1500</span><span class="o">,</span> <span class="s">&#34;/tmp/d120_cumul.csv&#34;</span><span class="o">)</span></span></span></code></pre></div>
<p><a href="#R-image-f15d4636e171db07d37d901320b9f246" class="lightbox-link"><img alt="d120 distribution length/probability" class="bg-white border lazy lightbox noshadow figure-image" loading="lazy" src="../assets/posts/probability_in_scala_3_all_sides/d120_cumul.svg" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f15d4636e171db07d37d901320b9f246"><img alt="d120 distribution length/probability" class="bg-white border lazy lightbox noshadow lightbox-image" loading="lazy" src="../assets/posts/probability_in_scala_3_all_sides/d120_cumul.svg"></a></p>
<h2 id="conclusion">Conclusion</h2>
<p>The initial question was simple:</p>
<blockquote>
<p>how many rolls are needed, on average, with a \(n\) sided fair dice, to observe all of its sides.</p>
</blockquote>
<p>But the answer was not! We have seen how to check, empirically, that the <em>Scala</em>
<code>Random.nextInt</code> function correctly simulates a fair dice. From there we run
(many) experiments to get an approximation of the answer.
We experienced how easy but disastrous it can be to build a model disconnected
from reality.
We learned that building a valid model requires a deep understanding of the
problem and the experiments.
We had to put a <strong>lot</strong> of care into the construction of the model to be sure
it is a valid formalization of the problem.
The maths were not easy, but they were right.
And in the end, maths lead us to a very simple formula.
Was all this formal brutality useful? Yes, it was.
The simple formula gives the exact answer and is by far the most efficient
implementation.
Going deeper we found how to answer more questions like the chance we have to
observe all sides in \(l\) rolls or less. We even were able to get a precise
idea of how the probability behaves by plotting it.</p>
<p>All along this journey, we used many of the new <em>Scala 3</em> features among which
<a href="https://dotty.epfl.ch/docs/reference/contextual/extension-methods.html" rel="external" target="_self">extensions methods</a>
and
<a href="https://dotty.epfl.ch/docs/reference/contextual/type-classes.html" rel="external" target="_self">Type Classes</a>.
We saw how easy they were to use and the great benefits they offer.
<em>Extensions methods</em> let us add methods to objects without any boilerplate,
<em>Type Classes</em> let us write generic function, etc.</p>
<p>I hope you enjoyed this journey as much as I loved writing it. Have a look at
<a href="https://dotty.epfl.ch/docs/reference/overview.html" rel="external" target="_self">all the <em>Scala 3</em> features</a>.
Many of them are not covered here but are truly amazing (Polymorphic Functions,
Dependent Function Types, Match Types, Intersection and Union Types, etc).
The list is pretty large.</p>

  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="les-gadts-par-lexemple">Les GADTs Par l&#39;Exemple</h1>
    <p class="article-meta default"><em>27 Oct 2019 - 7900 Words</em></p>

<p>Soyez les bienvenu·e·s! Cette session a le dessein de vous présenter
un outil de programmation très puissant. Alors que la plupart des
introductions sur le sujet commencent par une présentation de ses
fondements théoriques d&rsquo;une manière très formelle, nous avons choisi
de vous le présenter à travers de courts exemples et des cas
d&rsquo;utilisation concrets.</p>
<p>Cet atelier est composé de trois parties. La dernière présente trois
des cas d&rsquo;utilisation des plus utiles. Ils forment les usages majeurs
en pratique. Mais ne vous y aventurez pas sans préparation! Cette partie
est la dernière pour une bonne raison: elle s&rsquo;appuie massivement sur
les leçons des parties précédentes.
Commencez par <a href="../posts/les_gadts_par_l_exemple/index.html#premier-contact">Premier Contact</a>, elle vous exposera,
via les plus simples exemples, les idées clefs. Son but est
d&rsquo;ouvrir votre esprit à des manières d&rsquo;utiliser les types et données
que vous n&rsquo;avez vraisemblablement jamais soupçonnées.
Arpentez ensuite
<a href="../posts/les_gadts_par_l_exemple/index.html#cas-d-utilisation-simples-et-utiles-relations-sur-les-types">Cas d’utilisation simples et utiles: relations sur les types</a>,
pour un premier défi devant un usage pratique.
Après cela seulement vous serez prêt·e pour
<a href="../posts/les_gadts_par_l_exemple/index.html#cas-d-utilisation-plus-avancés">Cas d’Utilisation Plus Avancés</a>.</p>
<p>Assurez vous de <strong>lire <a href="../posts/les_gadts_par_l_exemple/index.html#lisez-moi">LISEZ-MOI</a></strong>, cette section contient de précieuses
astuces pour faciliter votre parcours.</p>
<h2 id="remerciements">Remerciements</h2>
<p>Nous tenons à remercier <a href="http://www.laure-juglaret.fr/" rel="external" target="_self">Laure Juglaret</a> pour
ses nombreuses relectures, ses précieuses remarques et corrections.</p>
<h2 id="lisez-moi">LISEZ-MOI</h2>
<p>Durant toute cette présentation, nous considérerons que:</p>
<ul>
<li><code>null</code> <strong>n&rsquo;existe pas!</strong></li>
<li><strong>La réflexion au runtime n&rsquo;existe pas!</strong> (c.-à-d. <code>isInstanceOf</code>, <code>getClass</code>, etc)</li>
</ul>
<p>Cette présentation considère que <em>ces fonctionnalités n&rsquo;existent pas du tout!</em>.</p>
<p><strong>Leur utilisation n&rsquo;amènera jamais à une réponse correcte aux questions.</strong>.</p>
<p>Pour faire cet atelier vous devez disposez du nécessaire pour écrire, compiler et
exécuter rapidement du code <em>Scala</em>. Le meilleur moyen est d&rsquo;ouvrir une session
interactive (<em>R.E.P.L.</em>). Si vous avez <em>Scala</em> d&rsquo;installé sur votre système, vous
pouvez facilement en démarrer une via la ligne de commande en exécutant le programme
<code>scala</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">system</span><span class="o">-</span><span class="n">command</span><span class="o">-</span><span class="n">line</span><span class="k">#</span> <span class="n">scala</span>
</span></span><span class="line"><span class="cl"><span class="nc">Welcome</span> <span class="n">to</span> <span class="nc">Scala</span> <span class="mf">2.13</span><span class="o">.</span><span class="mi">1</span> <span class="o">(</span><span class="nc">OpenJDK</span> <span class="mi">64</span><span class="o">-</span><span class="nc">Bit</span> <span class="nc">Server</span> <span class="nc">VM</span><span class="o">,</span> <span class="nc">Java</span> <span class="mf">1.8</span><span class="o">.</span><span class="mi">0</span><span class="n">_222</span><span class="o">).</span>
</span></span><span class="line"><span class="cl"><span class="nc">Type</span> <span class="n">in</span> <span class="n">expressions</span> <span class="k">for</span> <span class="n">evaluation</span><span class="o">.</span> <span class="nc">Or</span> <span class="k">try</span> <span class="k">:</span><span class="kt">help.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">scala&gt;</span></span></span></code></pre></div>
<p>Pour rappel, dans une session interactive (<em>R.E.P.L.</em>),
la commande <code>:paste</code> permet de copier du code dans la session
et la commande <code>:reset</code> de repartir d&rsquo;un environnement vierge.</p>
<p>Si vous n&rsquo;avez pas <em>Scala</em> d&rsquo;installé, <strong>vous pouvez utiliser</strong> le
site <a href="https://scastie.scala-lang.org/" rel="external" target="_self">https://scastie.scala-lang.org/</a> .</p>
<h2 id="échauffements">Échauffements</h2>
<p>Cette section est un bref rappel de quelques définitions et propriétés sur
les types et les valeurs.</p>
<h3 id="valeurs-et-types"><em>Valeurs</em> et <em>Types</em>?</h3>
<p>Les <strong>valeurs</strong> sont les <em>données concrètes que vos programmes manipulent</em>
comme l&rsquo;entier <code>5</code>, le booléen <code>true</code>, la chaîne <code>&quot;Hello World!&quot;</code>,
la fonction <code>(x: Double) =&gt; x / 7.5</code>, la liste <code>List(1,2,3)</code>, etc.
Il est souvent pratique de classer les valeurs en groupes. Ces groupes sont appelés
des <strong>types</strong>. Par exemple:</p>
<ul>
<li><code>Int</code> est le groupe des valeurs entières, c.-à-d. les valeurs telles que <code>1</code>, <code>-7</code>, <code>19</code>, etc.</li>
<li><code>Boolean</code> est le groupe contenant exactement les valeurs
<code>true</code> et <code>false</code> (ni plus, ni moins!).</li>
<li><code>String</code> est le groupe dont les valeurs sont <code>&quot;Hello World!&quot;</code>, <code>&quot;&quot;</code>, <code>&quot;J' ❤️ les GADTs&quot;</code>, etc.</li>
<li><code>Double =&gt; Double</code> est le groupe dont les valeurs sont les fonctions prenant en argument
n&rsquo;importe quel <code>Double</code> et renvoyant également un double <code>Double</code>.</li>
</ul>
<p>Pour indiquer que la valeur <code>v</code> appartient au type (c.-à-d. groupe de valeurs) <code>T</code>,
la notation est <code>v : T</code>. En <em>Scala</em>, tester si une valeur <code>v</code> appartient au type <code>T</code>
est très simple: il suffit de taper <code>v : T</code> dans la session interactive (<em>REPL</em>):</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="mi">5</span> <span class="k">:</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl"><span class="n">res7</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">5</span></span></span></code></pre></div>
<p>Si <em>Scala</em> l&rsquo;accepte, alors <code>v</code> appartient bien au type <code>T</code>. Si <em>Scala</em> râle,
ce n&rsquo;est probablement pas le cas:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="mi">5</span> <span class="k">:</span> <span class="kt">String</span>
</span></span><span class="line"><span class="cl">       <span class="o">^</span>
</span></span><span class="line"><span class="cl">       <span class="n">error</span><span class="k">:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">found</span>   <span class="k">:</span> <span class="kt">Int</span><span class="o">(</span><span class="err">5</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="kt">required:</span> <span class="kt">String</span></span></span></code></pre></div>
<h3 id="combien-de-types">Combien de types?</h3>
<p>Créons maintenant quelques types et quelques unes de leurs valeurs (quand cela est possible!).</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">UnType</span></span></span></code></pre></div>
<ul>
<li>
<p><strong>Question 1:</strong> Combien de types la ligne <code>class UnType</code> définit-elle?</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<p>Comme son nom le suggère, la ligne <code>class UnType</code> définit seulement un type, nommé <code>UnType</code>.</p>
  </details>
</li>
</ul>
<p>Passons maintenant à:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">UnTypePourChaque</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span></span></span></code></pre></div>
<ul>
<li>
<p><strong>Question 2:</strong> Combien de types la ligne <code>class UnTypePourChaque[A]</code> définit-elle?</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<p>Comme son nom le suggère, chaque type concret <code>A</code> donne lieu à
un type distinct <code>UnTypePourChaque[A]</code>.</p>
<p>Par exemple, une liste d&rsquo;entiers n&rsquo;est ni une liste de booléens,
ni une liste de chaîne de caractères, ni une liste de fonctions, ni &hellip;
En effet les types <code>List[Int]</code>, <code>List[Boolean]</code>,
<code>List[Int =&gt; Int]</code>, etc sont tous des types distincts.</p>
<p>la ligne <code>class UnTypePourChaque[A]</code> définit
<strong>un type distinct pour chaque type concret</strong> <code>A</code>.
Il y a une infinité de types concrets <code>A</code>,
donc une infinité de de types distincts <code>UnTypePourChaque[A]</code>.</p>
  </details>
</li>
<li>
<p><strong>Question 3:</strong> Donnez une valeur qui appartient à la fois aux types
<code>UnTypePourChaque[Int]</code> et <code>UnTypePourChaque[Boolean]</code>.</p>
<p><strong>Pour rappel, <code>null</code> n&rsquo;existe pas!</strong></p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<p>C&rsquo;est en fait impossible. Chaque type concret <code>A</code> donne lieu
à un type distinct <code>UnTypePourChaque[A]</code> qui n&rsquo;a aucune valeur en commun
avec les autres types de la forme <code>UnTypePourChaque[B]</code> avec <code>B ≠ A</code>.</p>
  </details>
</li>
</ul>
<h3 id="combien-de-valeurs">Combien de valeurs?</h3>
<p>En considérant le type suivant:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">final</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">PasDeValeurPourCeType</span></span></span></code></pre></div>
<ul>
<li>
<p><strong>Question 1:</strong> Donnez une valeur appartenant au type <code>PasDeValeurPourCeType</code>?
Combien de valeurs appartiennent au type <code>PasDeValeurPourCeType</code>?</p>
  <details>
    <summary><em>Astuce (cliquer pour dévoiler)</em></summary>
<ul>
<li>Qu&rsquo;est ce qu&rsquo;une classe <code>final</code>? En quoi est-ce qu&rsquo;elle diffère d&rsquo;une classe normale (non finale)?</li>
<li>Qu&rsquo;est ce qu&rsquo;une classe <code>abstract</code>? En quoi est-ce qu&rsquo;elle diffère d&rsquo;une classe concrète?</li>
</ul>
  </details>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<p>La classe <code>PasDeValeurPourCeType</code> est déclarée comme <code>abstract</code>.
Cela signifie qu&rsquo;il est interdit de créer des instances directes de cette classe:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="k">new</span> <span class="nc">PasDeValeurPourCeType</span>
</span></span><span class="line"><span class="cl">       <span class="o">^</span>
</span></span><span class="line"><span class="cl">       <span class="n">error</span><span class="k">:</span> <span class="kt">class</span> <span class="kt">PasDeValeurPourCeType</span> <span class="kt">is</span> <span class="kt">abstract</span><span class="o">;</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">instantiated</span></span></span></code></pre></div>
<p>La seule manière de créer une instance d&rsquo;une classe abstraite est de créer une
une sous-classe concrète. Mais le mot clef <code>final</code> interdit la création de
telles sous-classes:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">SousClasseConcrete</span> <span class="k">extends</span> <span class="nc">PasDeValeurPourCeType</span>
</span></span><span class="line"><span class="cl">                                        <span class="o">^</span>
</span></span><span class="line"><span class="cl">        <span class="n">error</span><span class="k">:</span> <span class="kt">illegal</span> <span class="kt">inheritance</span> <span class="kt">from</span> <span class="kt">final</span> <span class="kt">class</span> <span class="kt">PasDeValeurPourCeType</span></span></span></code></pre></div>
<p>Il n&rsquo;existe aucun moyen de créer une instance pour <code>PasDeValeurPourCeType</code>.</p>
  </details>
</li>
</ul>
<p>Prenons un autre exemple:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">ExactementUneValeur</span>
</span></span><span class="line"><span class="cl"><span class="k">case</span> <span class="k">object</span> <span class="nc">LaSeuleValeur</span> <span class="k">extends</span> <span class="nc">ExactementUneValeur</span></span></span></code></pre></div>
<ul>
<li>
<p><strong>Question 2:</strong> Donnez une valeur appartenant au type <code>ExactementUneValeur</code>?</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<p>Par définition, <code>LaSeuleValeur</code> est une valeur du type <code>ExactementUneValeur</code>.</p>
  </details>
</li>
<li>
<p><strong>Question 3:</strong> Combien de valeurs appartiennent à <code>ExactementUneValeur</code>?</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<p>Comme ci-dessus, <code>ExactementUneValeur</code>, étant un <code>trait</code>, est <em>abstrait</em>. Étant <code>sealed</code>,
l&rsquo;étendre en dehors de son fichier source est interdit.
Donc <code>LaSeuleValeur</code> est la seule valeur du type <code>ExactementUneValeur</code>.</p>
  </details>
</li>
</ul>
<h2 id="premier-contact">Premier Contact</h2>
<p>Cette partie présente les idées clefs. Il y a en fait seulement
deux idées! Vous trouverez ici des exemples épurés illustrant chacune
de ces deux idées.</p>
<h3 id="cas-dutilisation-preuve-dune-propriété">Cas d&rsquo;Utilisation: Preuve d&rsquo;une propriété</h3>
<p>Définissons un simple <em>sealed trait</em>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">ATrait</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">case</span> <span class="k">object</span> <span class="nc">AValue</span> <span class="k">extends</span> <span class="nc">ATrait</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span></span></span></code></pre></div>
<ul>
<li>
<p><strong>Question 1:</strong> Donnez une valeur du type <code>ATrait[Char]</code>.</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<p>Par définition, <code>AValue</code> est une valeur du type <code>ATrait[Char]</code>.</p>
  </details>
</li>
<li>
<p><strong>Question 2:</strong> Donnez une valeur du type <code>ATrait[Double]</code>.</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<p>Il n&rsquo;existe aucun moyen d&rsquo;obtenir une instance du type <code>ATrait[Double]</code>.
Il n&rsquo;existe en fait aucun moyen d&rsquo;obtenir une instance de <code>ATrait[B]</code> pour <code>B ≠ Char</code>
parce que la seule valeur possible est <code>AValue</code> qui est de type <code>ATrait[Char]</code>.</p>
  </details>
</li>
<li>
<p><strong>Question 3:</strong> Que pouvez vous conclure sur le type <code>A</code> si vous avez une valeur
<code>ev</code> de type <code>ATrait[A]</code> (c.-à-d. <code>ev: ATrait[A]</code>)?</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<p>La seule valeur possible est <code>AValue</code>, donc <code>ev == AValue</code>.
De plus <code>AValue</code> est de type <code>ATrait[Char]</code> donc <code>A = Char</code>.</p>
  </details>
</li>
<li>
<p><strong>Question 4:</strong> Dans la session interactive (<em>REPL</em>), entrez le code suivant:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">f</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">ATrait</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Char</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">x</span></span></span></code></pre></div>
</li>
<li>
<p><strong>Question 5:</strong> Essayez maintenant en utilisant un filtrage par motif
(pattern matching) sur <code>ev: ATrait[A]</code></p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">f</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">ATrait</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Char</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">ev</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">AValue</span> <span class="k">=&gt;</span> <span class="n">x</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
<p>Le filtrage par motif (pattern-matching) est il exhaustif?</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<p>Le filtrage par motif est exhaustif parce la seule et unique valeur possible
pour <code>ev</code> est en fait <code>AValue</code>. De plus <code>AValue</code> est de type <code>ATrait[Char]</code> ce qui signifie
que <code>ev : ATrait[Char]</code> parce que <code>ev == AValue</code>. Donc <code>A = Char</code> et <code>x : Char</code>.</p>
  </details>
</li>
<li>
<p><strong>Question 6:</strong> Appelez <code>f</code> avec <code>x = 'w' : Char</code>.</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">[</span><span class="kt">Char</span><span class="o">](</span><span class="sc">&#39;w&#39;</span><span class="o">,</span> <span class="nc">AValue</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="n">res0</span><span class="k">:</span> <span class="kt">Char</span> <span class="o">=</span> <span class="n">w</span></span></span></code></pre></div>
  </details>
</li>
<li>
<p><strong>Question 7:</strong> Appelez <code>f</code> avec <code>x =  5.2 : Double</code>.</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<p>C&rsquo;est impossible parce que cela demenderait de fournir une valeur
<code>ev : ATrait[Double]</code>, ce qui n&rsquo;existe pas!</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">[</span><span class="kt">Double</span><span class="o">](</span><span class="mi">5</span><span class="o">,</span> <span class="nc">AValue</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">                    <span class="o">^</span>
</span></span><span class="line"><span class="cl">          <span class="n">error</span><span class="k">:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">found</span>   <span class="k">:</span> <span class="kt">AValue.type</span>
</span></span><span class="line"><span class="cl">            <span class="n">required</span><span class="k">:</span> <span class="kt">ATrait</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span></span></span></code></pre></div>
  </details>
</li>
</ul>
<details>
  <summary><strong>Remarque pour les personnes à l'aise en <em>Scala</em></strong> <em>(cliquer pour dévoiler)</em></summary>
<p>En utilisant toutes les chouettes fonctionnalités syntaxiques de <em>Scala</em>,
la version satisfaisante en production du code ci-dessus est:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">IsChar</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">object</span> <span class="nc">IsChar</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">implicit</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">Evidence</span> <span class="k">extends</span> <span class="nc">IsChar</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">implicit</span> <span class="n">evidence</span><span class="k">:</span> <span class="kt">IsChar</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">IsChar</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="n">evidence</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">f</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">IsChar</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Char</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="nc">IsChar</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">IsChar</span><span class="o">.</span><span class="nc">Evidence</span> <span class="k">=&gt;</span> <span class="n">x</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
</details>
<h3 id="cas-dutilisation-la-seule-chose-que-je-sais-est-quil-existe">Cas d&rsquo;Utilisation: La seule chose que je sais, est qu&rsquo;il existe</h3>
<p>Que feriez vous si vous vouliez que votre application tienne un journal d’évènements (c.-à-d. un <em>log</em>),
mais que vous vouliez être sur qu&rsquo;elle ne dépende d&rsquo;aucun détail d&rsquo;implémentation de la méthode
de journalisation (c.-à-d. du <em>logger</em>), de telle manière que vous puissiez changer son implémentation
sans risquer de casser votre application?</p>
<p>En considérant le type suivant, <code>UnknownLogger</code>, des méthodes de journalisation:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">UnknownLogger</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">LogWith</span><span class="o">[</span><span class="kt">X</span><span class="o">](</span><span class="n">logs</span> <span class="k">:</span> <span class="kt">X</span><span class="o">,</span> <span class="n">appendMessage</span><span class="k">:</span> <span class="o">(</span><span class="kt">X</span><span class="o">,</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">X</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">UnknownLogger</span></span></span></code></pre></div>
<p>La première méthode (c.-à-d. *<em>logger</em>) que nous créons stocke les messages dans une <code>String</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">loggerStr</span> <span class="k">:</span> <span class="kt">UnknownLogger</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="nc">LogWith</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">&#34;&#34;</span><span class="o">,</span> <span class="o">(</span><span class="n">logs</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">message</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">logs</span> <span class="o">++</span> <span class="n">message</span><span class="o">)</span></span></span></code></pre></div>
<p>La seconde méthode les stocke dans une <code>List[String]</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">loggerList</span> <span class="k">:</span> <span class="kt">UnknownLogger</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="nc">LogWith</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]](</span><span class="nc">Nil</span><span class="o">,</span> <span class="o">(</span><span class="n">logs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span> <span class="n">message</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">message</span> <span class="k">:</span><span class="kt">:</span> <span class="kt">logs</span><span class="o">)</span></span></span></code></pre></div>
<p>La troisième méthode de journalisation imprime directement les messages sur la sortie standard:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">loggerStdout</span> <span class="k">:</span> <span class="kt">UnknownLogger</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="nc">LogWith</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]((),</span> <span class="o">(</span><span class="n">logs</span><span class="k">:</span> <span class="kt">Unit</span><span class="o">,</span> <span class="n">message</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">message</span><span class="o">))</span></span></span></code></pre></div>
<p>Notez que ces trois méthodes de journalisation ont toutes le même type
(c.-à-d. <code>UnknownLogger</code>) mais qu&rsquo;elles stockent les messages en utilisant
différents types <code>X</code> (<code>String</code>, <code>List[String]</code> et <code>Unit</code>).</p>
<ul>
<li>
<p><strong>Question 1:</strong> Soit <code>v</code> une valeur de type <code>UnknownLogger</code>.
Clairement <code>v</code> doit être une instance de la classe <code>LogWith[X]</code> pour un certain <code>X</code>.
Que pouvez vous dire sur le type <code>X</code>? Pouvez-vous deviner quel type concret est <code>X</code>?</p>
<p><strong>Pour rappel, il est interdit d&rsquo;utiliser la réflexion au runtime!</strong> (c.-à-d. <code>isInstanceOf</code>, <code>getClass</code>, etc)</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<p>Nous ne savons presque rien sur <code>X</code>. La seule chose que nous avons est qu&rsquo;il existe au
moins une valeur (<code>v.logs</code>) de type <code>X</code>. À part cela, <code>X</code> peut être n&rsquo;importe quel type.</p>
<p>Ne pas savoir quel type concret est <code>X</code> est très utile pour garantir que le code qui utilisera
<code>v : UnknownLogger</code> ne dépendra pas de la nature de <code>X</code>. Si ce code savait que <code>X</code> était
<code>String</code> par exemple, il pourrait exécuter des opérations que nous voulons interdir comme inverser
la liste, ne retenir que les <em>n</em> premiers caractères, etc. En cachant la nature de<code>X</code>, nous forçons
notre application à ne pas dépendre du type concret derrière<code>X</code> mais de n&rsquo;utiliser que la
fonnction fournie <code>v.appendMessage</code>.
Ainsi changer l&rsquo;implémentation réelle de la méthode de journalisation ne cassera aucun code.</p>
  </details>
</li>
<li>
<p><strong>Question 2:</strong> Écrivez la fonction <code>def log(message: String, v: UnknownLogger): UnknownLogger</code>
qui utilise <code>v.appendMessage</code> pour ajouter le <code>message</code> au journal <code>v.logs</code>
et retourne un nouvel <code>UnknownLogger</code> contenant le nouveau journal (c.-à-d. le nouveau <code>log</code>).</p>
<p>Pour rappel, en <em>Scala</em>, le motif (c.-à-d. pattern) <code>case ac : AClass[t] =&gt;</code>
est possible dans les expressions de type <code>match/case</code> comme alternative au motif
<code>case AClass(v) =&gt; </code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">AClass</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">value</span> <span class="k">:</span> <span class="kt">A</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">f</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">v</span><span class="k">:</span> <span class="kt">AClass</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">v</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="n">ac</span> <span class="k">:</span> <span class="kt">AClass</span><span class="o">[</span><span class="kt">t</span><span class="o">]</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// La variable `t` is une variable de type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// Le type `t` est `A`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">val</span> <span class="n">r</span> <span class="k">:</span> <span class="kt">t</span> <span class="o">=</span> <span class="n">ac</span><span class="o">.</span><span class="n">value</span>
</span></span><span class="line"><span class="cl">      <span class="n">r</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
<p>Son principal avantage est d&rsquo;introduire la variable de type <code>t</code>.
Les variables de type se comportent comme des variables de motif classiques
(c.-à-d. pattern variables) à l&rsquo;exception prés qu&rsquo;elles représentent des
types et non des valeurs.
Avoir <code>t</code> sous la main nous permet d&rsquo;aider le compilateur en donnant
explicitement certains types (comme ci-dessus, expliciter que <code>r</code> est de type <code>t</code>).</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">log</span><span class="o">(</span><span class="n">message</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">v</span><span class="k">:</span> <span class="kt">UnknownLogger</span><span class="o">)</span><span class="k">:</span> <span class="kt">UnknownLogger</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">v</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="n">vx</span> <span class="k">:</span> <span class="kt">LogWith</span><span class="o">[</span><span class="kt">x</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">LogWith</span><span class="o">[</span><span class="kt">x</span><span class="o">](</span><span class="n">vx</span><span class="o">.</span><span class="n">appendMessage</span><span class="o">(</span><span class="n">vx</span><span class="o">.</span><span class="n">logs</span><span class="o">,</span> <span class="n">message</span><span class="o">),</span> <span class="n">vx</span><span class="o">.</span><span class="n">appendMessage</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
  </details>
</li>
<li>
<p><strong>Question 3:</strong> Exécutez <code>log(&quot;Hello World&quot;, loggerStr)</code> et <code>log(&quot;Hello World&quot;, loggerList)</code>
et <code>log(&quot;Hello World&quot;, loggerStdout)</code></p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">log</span><span class="o">(</span><span class="s">&#34;Hello World&#34;</span><span class="o">,</span> <span class="n">loggerStr</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="n">res0</span><span class="k">:</span> <span class="kt">UnknownLogger</span> <span class="o">=</span> <span class="nc">LogWith</span><span class="o">(</span><span class="nc">Hello</span> <span class="nc">World</span><span class="o">,</span><span class="nc">$$Lambda$988</span><span class="o">/</span><span class="mi">1455466014</span><span class="k">@</span><span class="mi">421</span><span class="n">ead7e</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">log</span><span class="o">(</span><span class="s">&#34;Hello World&#34;</span><span class="o">,</span> <span class="n">loggerList</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="n">res1</span><span class="k">:</span> <span class="kt">UnknownLogger</span> <span class="o">=</span> <span class="nc">LogWith</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="nc">Hello</span> <span class="nc">World</span><span class="o">),</span><span class="nc">$$Lambda$989</span><span class="o">/</span><span class="mi">1705282731</span><span class="k">@</span><span class="mi">655621</span><span class="n">fd</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">log</span><span class="o">(</span><span class="s">&#34;Hello World&#34;</span><span class="o">,</span> <span class="n">loggerStdout</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="nc">Hello</span> <span class="nc">World</span>
</span></span><span class="line"><span class="cl"><span class="n">res2</span><span class="k">:</span> <span class="kt">UnknownLogger</span> <span class="o">=</span> <span class="nc">LogWith</span><span class="o">((),</span><span class="nc">$$Lambda$990</span><span class="o">/</span><span class="mi">1835105031</span><span class="k">@</span><span class="mi">340</span><span class="n">c57e0</span><span class="o">)</span></span></span></code></pre></div>
  </details>
</li>
</ul>
<details>
  <summary><strong>Remarque pour les personnes à l'aise en <em>Scala</em></strong> <em>(cliquer pour dévoiler)</em></summary>
<p>Une fois encore, en utilisant toutes les chouettes fonctionnalités syntaxiques de <em>Scala</em>,
la version satisfaisante en production du code ci-dessus est:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">UnknownLogger</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">type</span> <span class="kt">LogsType</span>
</span></span><span class="line"><span class="cl">  <span class="k">val</span> <span class="n">logs</span> <span class="k">:</span> <span class="kt">LogsType</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">appendMessage</span><span class="o">(</span><span class="n">presentLogs</span><span class="k">:</span> <span class="kt">LogsType</span><span class="o">,</span> <span class="n">message</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">LogsType</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">object</span> <span class="nc">UnknownLogger</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">LogWith</span><span class="o">[</span><span class="kt">X</span><span class="o">](</span><span class="n">logs</span> <span class="k">:</span> <span class="kt">X</span><span class="o">,</span> <span class="n">appendMessage_</span> <span class="k">:</span> <span class="o">(</span><span class="kt">X</span><span class="o">,</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">X</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">UnknownLogger</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">type</span> <span class="kt">LogsType</span> <span class="o">=</span> <span class="n">X</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="n">appendMessage</span><span class="o">(</span><span class="n">presentLogs</span><span class="k">:</span> <span class="kt">LogsType</span><span class="o">,</span> <span class="n">message</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">LogsType</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">appendMessage_</span><span class="o">(</span><span class="n">presentLogs</span><span class="o">,</span> <span class="n">message</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">X</span><span class="o">](</span><span class="n">logs</span><span class="k">:</span> <span class="kt">X</span><span class="o">,</span> <span class="n">appendMessage</span><span class="k">:</span> <span class="o">(</span><span class="kt">X</span><span class="o">,</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">X</span><span class="o">)</span><span class="k">:</span> <span class="kt">UnknownLogger</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="nc">LogWith</span><span class="o">[</span><span class="kt">X</span><span class="o">](</span><span class="n">logs</span><span class="o">,</span> <span class="n">appendMessage</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
</details>
<h3 id="conclusion-intermédiaire">Conclusion Intermédiaire</h3>
<p>Les <em>GADTs</em> ne sont en fait que ceci: de simples <em>sealed trait</em> avec quelques
<em>case object</em> (possiblement aucun) et quelques <em>final case class</em> (également possiblement aucune!).
Dans les parties suivantes, nous explorerons quelques un des cas d&rsquo;utilisation
majeurs des <em>GADTs</em>.</p>
<h2 id="cas-dutilisation-simples-et-utiles-relations-sur-les-types">Cas d&rsquo;utilisation simples et utiles: relations sur les types</h2>
<p>Une faculté simple mais très utile des <em>GADTs</em> est l&rsquo;expression de relations sur les types telles que:</p>
<ul>
<li>Le type <code>A</code> est-il égal au type <code>B</code>?</li>
<li>Le type <code>A</code> est-il un sous-type de <code>B</code>?</li>
</ul>
<p>Notez bien que, par définition, tout type <code>A</code> est sous-type de lui-même (c.-à-d. <code>A &lt;: A</code>),
tout comme tout entier <code>x</code> est également inférieur ou égal à lui-même <code>x ≤ x</code>.</p>
<h3 id="cas-dutilisation-témoin-dégalité-entre-types">Cas d&rsquo;Utilisation: Témoin d&rsquo;Égalité entre Types</h3>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">EqT</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Evidence</span><span class="o">[</span><span class="kt">X</span><span class="o">]()</span> <span class="k">extends</span> <span class="nc">EqT</span><span class="o">[</span><span class="kt">X</span>,<span class="kt">X</span><span class="o">]</span></span></span></code></pre></div>
<ul>
<li>
<p><strong>Question 1:</strong> Donnez une valeur de type <code>EqT[Int, Int]</code></p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Evidence</span><span class="o">[</span><span class="kt">Int</span><span class="o">]()</span> <span class="k">:</span> <span class="kt">EqT</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="n">res0</span><span class="k">:</span> <span class="kt">EqT</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Evidence</span><span class="o">()</span></span></span></code></pre></div>
  </details>
</li>
<li>
<p><strong>Question 2:</strong> Donnez une valeur de type <code>EqT[String, Int]</code></p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<p>La classe <code>Evidence</code> est l&rsquo;unique sous-classe conctrète du trait <code>EqT</code> et il est
impossible d&rsquo;en créer une autre parce que <code>EqT</code> est <code>sealed</code>. Donc une valeur <code>v : EqT[A,B]</code>
ne peut être qu&rsquo;une instance de <code>Evidence[X]</code> pour un certain type <code>X</code>, qui elle-même est
de type <code>EqT[X,X]</code>.
Ainsi il n&rsquo;y a aucun moyen d&rsquo;obtenir une valeur de type <code>EqT[String, Int]</code></p>
  </details>
</li>
<li>
<p><strong>Question 3:</strong> Soient <code>A</code> et <code>B</code> deux types (inconnus).
Si je vous donne une valeur de type <code>EqT[A,B]</code>, que pouvez-vous en déduire sur <code>A</code> et <code>B</code>?</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<p>Si je vous donne une valeur <code>v : EqT[A,B]</code>, alors vous savez que <code>v</code> est une instance
de <code>Evidence[X]</code> pour un certain type <code>X</code> (inconnu). En effet la classe <code>Evidence</code>  est la seule
et unique sous-classe concrète du <code>sealed trait</code> <code>EqT</code>. En fait, <code>Evidence[X]</code> est un sous-type de
<code>EqT[X,X]</code>. Donc <code>v : EqT[X,X]</code>. Les types <code>EqT[A,B]</code> et <code>EqT[X,X]</code> n&rsquo;ont aucune valeur en commun
si <code>A ≠ X</code> ou <code>B ≠ X</code>, donc <code>A = X</code> et <code>B = X</code>. Et donc <code>A = B</code>. CQFD.</p>
  </details>
</li>
</ul>
<details>
  <summary><strong>Remarque pour les personnes à l'aise en <em>Scala</em></strong> <em>(cliquer pour dévoiler)</em></summary>
<p>En production, il est pratique de définir <code>EqT</code> de la manière suivante, qui est bien entendu équivalente:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">EqT</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">object</span> <span class="nc">EqT</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Evidence</span><span class="o">[</span><span class="kt">X</span><span class="o">]()</span> <span class="k">extends</span> <span class="nc">EqT</span><span class="o">[</span><span class="kt">X</span>,<span class="kt">X</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">implicit</span> <span class="k">def</span> <span class="n">evidence</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span> <span class="k">:</span> <span class="kt">EqT</span><span class="o">[</span><span class="kt">X</span>,<span class="kt">X</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Evidence</span><span class="o">[</span><span class="kt">X</span><span class="o">]()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">EqT</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">ev.</span><span class="k">type</span> <span class="o">=</span> <span class="n">ev</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
</details>
<h4 id="passer-dun-type-égal-à-lautre">Passer d&rsquo;un type égal à l&rsquo;autre</h4>
<p>Si <code>A</code> et <code>B</code> sont en fait le même type, alors <code>List[A]</code> est également le même
type que <code>List[B]</code>, <code>Option[A]</code> est également le même type que <code>Option[B]</code>,
etc. De manière générale, pour n&rsquo;importe quel <code>F[_]</code>, <code>F[A]</code> est également le même type
que <code>F[B]</code>.</p>
<ul>
<li>
<p><strong>Question 4:</strong> Écrivez la fonction <code>def coerce[F[_],A,B](eqT: EqT[A,B])(fa: F[A]): F[B]</code>.</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">coerce</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">eqT</span><span class="k">:</span> <span class="kt">EqT</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">])(</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">eqT</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="k">_</span> <span class="k">:</span> <span class="kt">Evidence</span><span class="o">[</span><span class="kt">x</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">fa</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
  </details>
</li>
</ul>
<p>La bibliothèque standard de <em>Scala</em> définit déjà une classe, nommée <code>=:=[A,B]</code>
(son nom est bel et bien <code>=:=</code>), représentant l&rsquo;égalité entre types.
Je vous recommande vivement de jeter un œil
<a href="https://www.scala-lang.org/api/current/scala/$eq$colon$eq.html" rel="external" target="_self">à sa documentation (cliquez ici)</a>.
Fort heureusement, pour plus de lisibilité, <em>Scala</em> nous permet d&rsquo;écrire <code>A =:= B</code> le type <code>=:=[A,B]</code>.</p>
<p>Étant donné deux types <code>A</code> et <code>B</code>, avoir une instance (c.-à-d. objet)
de <code>A =:= B</code> prouve que <code>A</code> et <code>B</code> sont en réalité le même type,
tout comme pour <code>EqT[A,B]</code>.
Pour rappel, <code>A =:= B</code> n&rsquo;est que du sucre syntaxique pour désigner le type <code>=:=[A,B]</code>.</p>
<p>Des instances de <code>A =:= B</code> peuvent êtres crées en utilisant la fonction
<a href="https://www.scala-lang.org/api/current/scala/$less$colon$less$.html#refl[A]:A=:=A" rel="external" target="_self"><code>(&lt;:&lt;).refl[X]: X =:= X</code>
(cliquer pour voir la documentation)</a>.
Le &ldquo;symbole&rdquo; <code>&lt;:&lt;</code> est en effet un nom d&rsquo;objet valide.</p>
<ul>
<li>
<p><strong>Question 5:</strong> En utilisant la fonction <code>coerce</code> ci-dessus,
écrivez la fonction <code>def toScalaEq[A,B](eqT: EqT[A,B]): A =:= B</code>.</p>
  <details>
    <summary><em>Astuce (cliquer pour dévoiler)</em></summary>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">toScalaEq</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">eqT</span><span class="k">:</span> <span class="kt">EqT</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span><span class="k">:</span><span class="o">=</span> <span class="n">B</span> <span class="k">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* Trouver une définition pour:
</span></span></span><span class="line"><span class="cl"><span class="cm">        - le constructeur de type `F`
</span></span></span><span class="line"><span class="cl"><span class="cm">        - la valeur `fa : F[A]`
</span></span></span><span class="line"><span class="cl"><span class="cm">  */</span>
</span></span><span class="line"><span class="cl">  <span class="k">type</span> <span class="kt">F</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</span></span><span class="line"><span class="cl">  <span class="k">val</span> <span class="n">fa</span> <span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Telles que cet appel: */</span>
</span></span><span class="line"><span class="cl">  <span class="n">coerce</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">eqT</span><span class="o">)(</span><span class="n">fa</span><span class="o">)</span> <span class="c1">// soit de type `F[B]`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}</span></span></span></code></pre></div>
  </details>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">toScalaEq</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">eqT</span><span class="k">:</span> <span class="kt">EqT</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span><span class="k">:</span><span class="o">=</span> <span class="n">B</span> <span class="k">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">type</span> <span class="kt">F</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span> <span class="k">=</span> <span class="n">A</span> <span class="o">=:=</span> <span class="n">X</span>
</span></span><span class="line"><span class="cl">  <span class="k">val</span> <span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">(&lt;:&lt;).</span><span class="n">refl</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">  <span class="n">coerce</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">eqT</span><span class="o">)(</span><span class="n">fa</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
  </details>
</li>
<li>
<p><strong>Question 6:</strong> En utilisant la <em>méthode</em> <code>substituteCo[F[_]](ff: F[A]): F[B]</code> des
objets de la classe <code>A =:= B</code>, dont la
<a href="https://www.scala-lang.org/api/current/scala/$eq$colon$eq.html#substituteCo[F[_]](ff:F[From]):F[To]" rel="external" target="_self">documentation est ici</a>,
écrivez la fonction <code>def fromScalaEq[A,B](scala: A =:= B): EqT[A,B]</code>.</p>
  <details>
    <summary><em>Astuce (cliquer pour dévoiler)</em></summary>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">fromScalaEq</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">scala</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span><span class="k">:</span><span class="o">=</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">EqT</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* Trouver une définition pour:
</span></span></span><span class="line"><span class="cl"><span class="cm">        - le constructeur de type `F`
</span></span></span><span class="line"><span class="cl"><span class="cm">        - la valeur `fa : F[A]`
</span></span></span><span class="line"><span class="cl"><span class="cm">  */</span>
</span></span><span class="line"><span class="cl">  <span class="k">type</span> <span class="kt">F</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</span></span><span class="line"><span class="cl">  <span class="k">val</span> <span class="n">fa</span> <span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Telles que cet appel: */</span>
</span></span><span class="line"><span class="cl">  <span class="n">scala</span><span class="o">.</span><span class="n">substituteCo</span><span class="o">[</span><span class="kt">F</span><span class="o">](</span><span class="n">fa</span><span class="o">)</span> <span class="c1">// soit de type `F[B]`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}</span></span></span></code></pre></div>
  </details>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">fromScalaEq</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">scala</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span><span class="k">:</span><span class="o">=</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">EqT</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">type</span> <span class="kt">F</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span> <span class="k">=</span> <span class="nc">EqT</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">X</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">  <span class="k">val</span> <span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Evidence</span><span class="o">[</span><span class="kt">A</span><span class="o">]()</span>
</span></span><span class="line"><span class="cl">  <span class="n">scala</span><span class="o">.</span><span class="n">substituteCo</span><span class="o">[</span><span class="kt">F</span><span class="o">](</span><span class="n">fa</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
  </details>
</li>
</ul>
<h3 id="cas-dutilisation-témoin-de-sous-typage">Cas d&rsquo;Utilisation: Témoin de Sous-Typage</h3>
<p>Dans cette section, nous voulons créer les types <code>SubTypeOf[A,B]</code> dont les valeurs
prouvent que le type <code>A</code> est un sous-type de <code>B</code> (c.-à-d. <code>A &lt;: B</code>).
Une classe similaire, <em>mais différente</em>, est déjà définie dans la
bibliothèque standard de <em>Scala</em>.
Il s&rsquo;agit de la classe <code>&lt;:&lt;[A,B]</code>, qui est le plus souvent écrite <code>A &lt;:&lt; B</code>. Sa
<a href="https://www.scala-lang.org/api/current/scala/$less$colon$less.html" rel="external" target="_self">documentation est ici</a>.
Cette section étant dédiée à l&rsquo;implémentation d&rsquo;une variante de cette classe,
veuillez <strong>ne pas utiliser</strong> <code>&lt;:&lt;[A,B]</code> pour implémenter <code>SubTypeOf</code>.</p>
<ul>
<li>
<p><strong>Question 1:</strong> En utilisant uniquement des <em>bornes supérieures</em> (c.-à-d. <code>A &lt;: B</code>)
ou <em>bornes inférieures</em> (c.-à-d. <code>A &gt;: B</code>) et <strong>aucune</strong> <em>annotation de variance</em>
(c.-à-d. <code>[+A]</code> et <code>[-A]</code>),
créez le trait <code>SubTypeOf[A,B]</code> (et tout ce qui est nécessaire) tel que:</p>
<blockquote>
<p>Il existe une valeur de type <code>SubType[A,B]</code> <strong>si et seulement si</strong>
<code>A</code> est un sous-type de <code>B</code> (c.-à-d. <code>A &lt;: B</code>).</p>
</blockquote>
<p>Pour rappel, par définition, un type <code>A</code> est un sous-type de lui-même (c.-à-d. <code>A &lt;: A</code>).</p>
<p>Pour rappel, n&rsquo;utilisez pas la classe <code>&lt;:&lt;[A,B]</code>.</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">SubTypeOf</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">SubTypeEvidence</span><span class="o">[</span><span class="kt">A</span> <span class="k">&lt;:</span> <span class="kt">B</span>, <span class="kt">B</span><span class="o">]()</span> <span class="k">extends</span> <span class="nc">SubTypeOf</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span></span></span></code></pre></div>
  <details>
    <summary><strong>Remarque pour les personnes à l'aise en <em>Scala</em></strong> <em>(cliquer pour dévoiler)</em></summary>
<p>En production, il est pratique de définir <code>SubTypeOf</code> de la manière équivalente suivante:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">SubTypeOf</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">object</span> <span class="nc">SubTypeOf</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Evidence</span><span class="o">[</span><span class="kt">A</span> <span class="k">&lt;:</span> <span class="kt">B</span>, <span class="kt">B</span><span class="o">]()</span> <span class="k">extends</span> <span class="nc">SubTypeOf</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">implicit</span> <span class="k">def</span> <span class="n">evidence</span><span class="o">[</span><span class="kt">A</span> <span class="k">&lt;:</span> <span class="kt">B</span>, <span class="kt">B</span><span class="o">]</span><span class="k">:</span> <span class="kt">SubTypeOf</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Evidence</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">SubTypeOf</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">ev.</span><span class="k">type</span> <span class="o">=</span> <span class="n">ev</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
  </details>
  </details>
</li>
</ul>
<h3 id="cas-dutilisation-éviter-les-messages-derreur-de-scalac-à-propos-des-bornes-non-respectées">Cas d&rsquo;Utilisation: Éviter les messages d&rsquo;erreur de <em>scalac</em> à propos des bornes non respectées</h3>
<p>Dans cet exemple, nous voulons modéliser le régime alimentaire de certains animaux.
Commençons par définir le type <code>Food</code> (c.-à-d. nourriture) et quelques-uns de ces sous-types:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">trait</span> <span class="nc">Food</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Vegetable</span> <span class="k">extends</span> <span class="nc">Food</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Fruit</span> <span class="k">extends</span> <span class="nc">Food</span></span></span></code></pre></div>
<p>et maintenant la classe représentant les animaux mangeant de la nourriture de type <code>A</code>
(c.-à-d. <code>Vegetable</code>, <code>Fruit</code>, etc):</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">AnimalEating</span><span class="o">[</span><span class="kt">A</span> <span class="k">&lt;:</span> <span class="kt">Food</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nc">val</span> <span class="n">elephant</span> <span class="k">:</span> <span class="kt">AnimalEating</span><span class="o">[</span><span class="kt">Vegetable</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="k">new</span> <span class="nc">AnimalEating</span><span class="o">[</span><span class="kt">Vegetable</span><span class="o">]</span></span></span></code></pre></div>
<p>Définissons une fonction comme il en existe tant en <em>Programmation Fonctionnelle</em>
et passons lui <code>elephant</code> comme argument:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">dummy</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">&#34;Ok!&#34;</span></span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">dummy</span><span class="o">[</span><span class="kt">List</span>, <span class="kt">Int</span><span class="o">](</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">))</span>
</span></span><span class="line"><span class="cl"><span class="n">res0</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">Ok</span><span class="o">!</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">dummy</span><span class="o">[</span><span class="kt">Option</span>, <span class="kt">Boolean</span><span class="o">](</span><span class="nc">Some</span><span class="o">(</span><span class="kc">true</span><span class="o">))</span>
</span></span><span class="line"><span class="cl"><span class="n">res1</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">Ok</span><span class="o">!</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">dummy</span><span class="o">[</span><span class="kt">AnimalEating</span>, <span class="kt">Vegetable</span><span class="o">](</span><span class="n">elephant</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">            <span class="o">^</span>
</span></span><span class="line"><span class="cl">       <span class="n">error</span><span class="k">:</span> <span class="kt">kinds</span> <span class="kt">of</span> <span class="kt">the</span> <span class="k">type</span> <span class="kt">arguments</span> <span class="o">(</span><span class="kt">AnimalEating</span><span class="o">,</span><span class="kt">Vegetable</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">       <span class="k">do</span> <span class="n">not</span> <span class="n">conform</span> <span class="n">to</span> <span class="n">the</span> <span class="n">expected</span> <span class="n">kinds</span> <span class="n">of</span> <span class="n">the</span> <span class="k">type</span> <span class="kt">parameters</span> <span class="o">(</span><span class="k">type</span> <span class="kt">F</span><span class="o">,</span><span class="k">type</span> <span class="kt">A</span><span class="o">).</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">       <span class="nc">AnimalEating</span>&#39;s <span class="k">type</span> <span class="kt">parameters</span> <span class="kt">do</span> <span class="kt">not</span> <span class="kt">match</span> <span class="k">type</span> <span class="kt">F</span><span class="err">&#39;</span><span class="kt">s</span> <span class="kt">expected</span> <span class="kt">parameters:</span>
</span></span><span class="line"><span class="cl">       <span class="k">type</span> <span class="kt">A</span><span class="err">&#39;</span><span class="kt">s</span> <span class="kt">bounds</span> <span class="k">&lt;:</span> <span class="kt">Food</span> <span class="kt">are</span> <span class="kt">stricter</span> <span class="kt">than</span>
</span></span><span class="line"><span class="cl">       <span class="k">type</span> <span class="k">_</span><span class="err">&#39;</span><span class="kt">s</span> <span class="kt">declared</span> <span class="kt">bounds</span> <span class="k">&gt;:</span> <span class="kt">Nothing</span> <span class="k">&lt;:</span> <span class="kt">Any</span></span></span></code></pre></div>
<ul>
<li>
<p><strong>Question 1:</strong> Pourquoi <em>scalac</em> se plaint il?</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<p>La fonction <code>dummy</code> requiert que son argument <code>F</code>, qui est un constructeur
de type comme le sont <code>List</code>, <code>Option</code>, <code>Future</code>, etc, accepte n&rsquo;importe quel type
en argument afin qu&rsquo;il soit toujours possible d&rsquo;écrire <code>F[A]</code> pour n&rsquo;importe quel type <code>A</code>.
Hors <code>AnimalEating</code> impose que son argument soit un sous-type de <code>Food</code>.
Donc <code>AnimalEating</code> ne peut être utilisé comme argument <code>F</code> de <code>dummy</code>.</p>
  </details>
</li>
</ul>
<p>Le problème est que, en définissant <code>class AnimalEating[A &lt;: Food]</code>,
nous avons imposé à <code>A</code> d&rsquo;être un sous-type de <code>Food</code>. Donc <em>Scala</em>, tout comme <em>Java</em>,
nous interdit de donner à <code>AnimalEating</code>, en tant qu&rsquo;argument <code>A</code>, autre chose
qu&rsquo;un sous-type de <code>Food</code> (en incluant <code>Food</code> lui-même):</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="k">type</span> <span class="kt">T1</span> <span class="o">=</span> <span class="nc">AnimalEating</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">                 <span class="o">^</span>
</span></span><span class="line"><span class="cl">       <span class="n">error</span><span class="k">:</span> <span class="k">type</span> <span class="kt">arguments</span> <span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">do</span> <span class="n">not</span> <span class="n">conform</span>
</span></span><span class="line"><span class="cl">       <span class="n">to</span> <span class="k">class</span> <span class="nc">AnimalEating</span>&#39;s <span class="k">type</span> <span class="kt">parameter</span> <span class="kt">bounds</span> <span class="o">[</span><span class="kt">A</span> <span class="k">&lt;:</span> <span class="kt">Food</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="k">type</span> <span class="kt">T2</span> <span class="o">=</span> <span class="nc">AnimalEating</span><span class="o">[</span><span class="kt">Food</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="n">defined</span> <span class="k">type</span> <span class="kt">alias</span> <span class="kt">T2</span></span></span></code></pre></div>
<p>Nous sommes face à un dilemme: afin d&rsquo;utiliser la fonction <code>dummy</code>, que nous tenons
beaucoup à utiliser parce c&rsquo;est une fonction très utile, il nous faut supprimer la
contrainte <code>A &lt;: Food</code> de la définition <code>class AnimalEating[A &lt;: Food]</code>.
Mais nous tenons également au fait que les animaux ne mangent que de la nourriture (<code>Food</code>)
et pas des entiers, ni des booléens et encore moins des chaînes de caractères!</p>
<ul>
<li>
<p><strong>Question 2:</strong> Comment pouvez vous adapter la définition de <code>AnimalEating</code> telle que:</p>
<ul>
<li>
<p>Il soit possible d&rsquo;appeler <code>dummy</code> avec comme argument <code>elephant</code>! Nous voulons:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">dummy</span><span class="o">[</span><span class="kt">AnimalEating</span>, <span class="kt">Vegetable</span><span class="o">](</span><span class="n">elephant</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="n">res0</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">Ok</span><span class="o">!</span></span></span></code></pre></div>
</li>
<li>
<p><em>Si</em> <code>A</code> <strong>n&rsquo;est pas un sous-type</strong> de <code>Food</code> (<code>Food</code> lui-même inclus),
<em>alors</em> il doit être <strong>impossible</strong> de créer une instance de <code>AnimalEating[A]</code>.</p>
</li>
<li>
<p>La classe <code>AnimalEating</code> <strong>doit</strong> rester une classe ouverte
(c.-à-d. non <code>sealed</code> ou <code>final</code>)! Il doit toujours être possible pour n&rsquo;importe qui,
n&rsquo;importe quand, de créer librement des sous-classes de <code>AnimalEating</code>.
Bien évidemment, ces sous-classes doivent respecter les deux contraintes
ci-dessus.</p>
<details>
  <summary><em>Astuce (cliquer pour dévoiler)</em></summary>
<p>En <em>Scala</em>, <code>Nothing</code> est un type ne contenant aucune valeur.
Pouvez vous créer une valeur de type <code>(Nothing, Int)</code>? Pourquoi?</p>
</details>
<details>
  <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<p>Si, afin de créer une instance de <code>AnimalEating[A]</code>, nous forçons <strong>chaque</strong>
méthode créant des valeurs à prendre un paramètre supplémentaire de type <code>SubTypeOf[A, Food]</code>,
alors il sera uniquement possible de créer une instance de <code>AnimalEating[A]</code>
quand <code>A</code> sera un sous-type de <code>Food</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">AnimalEating</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">ev</span> <span class="k">:</span> <span class="kt">SubTypeOf</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">Food</span><span class="o">])</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">elephant</span> <span class="k">:</span> <span class="kt">AnimalEating</span><span class="o">[</span><span class="kt">Vegetable</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="k">new</span> <span class="nc">AnimalEating</span><span class="o">[</span><span class="kt">Vegetable</span><span class="o">](</span><span class="nc">SubTypeEvidence</span><span class="o">[</span><span class="kt">Vegetable</span>, <span class="kt">Food</span><span class="o">])</span></span></span></code></pre></div>
<p>Pour créer une valeur de type <code>AnimalEating[A]</code>, nous avons besoin d&rsquo;appeler
le constructeur d&rsquo;<code>AnimalEating</code>. Pour appeler ce constructeur,
il nous faut fournir <code>ev : SubTypeOf[A, Food]</code>.</p>
<p>Il nous est désormais possible d&rsquo;appeler la fonction <code>dummy</code> sur <code>elephant</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">dummy</span><span class="o">[</span><span class="kt">AnimalEating</span>, <span class="kt">Vegetable</span><span class="o">](</span><span class="n">elephant</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="n">res0</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">Ok</span><span class="o">!</span></span></span></code></pre></div>
<p>En pratique, en utilisant des implicites, le compilateur peut
fournir de lui-même le paramètre <code>ev : SubTypeOf[A, Food]</code>.</p>
<p>Notez qu&rsquo;il est désormais possible d&rsquo;écrire le type <code>AnimalEating[Int]</code>
mais vous ne pourrez jamais créer une valeur de ce type.</p>
</details>
</li>
</ul>
</li>
</ul>
<h3 id="cas-dutilisation-fournir-les-bonnes-données-au-bon-diagramme">Cas d&rsquo;Utilisation: Fournir les bonnes données au bon diagramme</h3>
<p>Ce cas d&rsquo;utilisation traite des méthodes pour garantir, à la compilation,
que seulement les valeurs du bon type peuvent être données à une fonction donnée.
L&rsquo;exemple choisi est celui de la conception d&rsquo;une bibliothèque de graphiques.
Afin de simplifier l&rsquo;exemple, nous considèrerons que notre bibliothèque n&rsquo;implémente
que deux types de graphique:
des <a href="https://www.google.com/search?q=pie+chart&tbm=isch" rel="external" target="_self">camemberts (c.-à-d. pie charts)</a>
et des <a href="https://www.google.com/search?q=xy+charts&tbm=isch" rel="external" target="_self">graphiques dit XY (c.-à-d. XY charts)</a>.
Cela s&rsquo;écrit en <em>Scala</em> via l&rsquo;énumération:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">ChartType</span>
</span></span><span class="line"><span class="cl"><span class="k">case</span> <span class="k">object</span> <span class="nc">PieChart</span> <span class="k">extends</span> <span class="nc">ChartType</span>
</span></span><span class="line"><span class="cl"><span class="k">case</span> <span class="k">object</span> <span class="nc">XYChart</span> <span class="k">extends</span> <span class="nc">ChartType</span></span></span></code></pre></div>
<p>Bien évidemment les camemberts (<em>Pie</em>) et graphiques <em>XY</em> s&rsquo;appuient sur des jeux de données de
nature différente. Encore une fois, pour simplifier, nous considèrerons que les deux types
de données sont <code>PieData</code> pour les camemberts et <code>XYData</code> pour les graphiques <em>XY</em>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">PieData</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">XYData</span></span></span></code></pre></div>
<p>Un camembert (<code>PieChart</code>) n&rsquo;affiche <strong>que</strong> des données <code>PieData</code>,
alors qu&rsquo;un graphique <em>XY</em> (<code>XYChart</code>) n&rsquo;affiche <strong>que</strong> des données <code>XYData</code>.
Voici, grandement simplifiée, la fonction d&rsquo;affichage <code>draw</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">draw</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">chartType</span><span class="k">:</span> <span class="kt">ChartType</span><span class="o">)(</span><span class="n">data</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">chartType</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">PieChart</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">pieData</span> <span class="k">=</span> <span class="n">data</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">PieData</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Faire des trucs pour tracer les données pieData
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="o">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">XYChart</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">xyData</span> <span class="k">=</span> <span class="n">data</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">XYData</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Faire des trucs pour tracer les données xyData
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="o">()</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
<p>Cette fonction repose sur l&rsquo;hypothèse que l&rsquo;utilisateur·rice n&rsquo;appellera la
fonction <code>draw</code> que sur le bon type de données.
Quand <code>chartType</code> vaut <code>PieChart</code>, la fonction présuppose, via
<code>data.asInstanceOf[PieData]</code> que <code>data</code> est en fait du type <code>PieData</code>.
Et quand <code>chartType</code> vaut <code>XYChart</code>, elle présuppose que <code>data</code> est en fait
de type <code>XYData</code>.</p>
<p>Le problème est que ces suppositions reposent sur l&rsquo;idée que les utilisateurs·rices et/ou
développeurs·euses s&rsquo;assureront toujours que ces hypothèses soient bien respectées.
Mais <strong>rien</strong> n&rsquo;empêche quelqu&rsquo;un·e d&rsquo;appeler <code>draw</code> sur un camembert (<code>PieChart</code>)
avec des données de type <code>XYData</code> (ou le contraire),
faisant planter le système misérablement en production!</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">draw</span><span class="o">(</span><span class="nc">PieChart</span><span class="o">)(</span><span class="k">new</span> <span class="nc">XYData</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">ClassCastException</span><span class="k">:</span> <span class="kt">XYData</span> <span class="kt">cannot</span> <span class="kt">be</span> <span class="kt">cast</span> <span class="kt">to</span> <span class="kt">PieData</span>
</span></span><span class="line"><span class="cl">  <span class="n">at</span> <span class="o">.</span><span class="n">draw</span><span class="o">(&lt;</span><span class="n">pastie</span><span class="k">&gt;:</span><span class="mi">11</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">...</span> <span class="mi">28</span> <span class="n">elided</span></span></span></code></pre></div>
<p>En tant que développeurs·euses, nous savons que les erreurs, ça arrive!
Nous voulons un moyen d&rsquo;empêcher ces bogues ennuyeux de survenir en production!
Nous voulons imposer, à la compilation, que seulement deux scenarii soit possibles:</p>
<ul>
<li>Quand <code>draw</code> est appelée avec <code>chartType == PieChart</code>:
l&rsquo;argument <code>data</code> doit être de type <code>PieData</code></li>
<li>Quand <code>draw</code> est appelée avec <code>chartType == XYChart</code>:
l&rsquo;argument <code>data</code> doit être de type <code>XYData</code>.</li>
</ul>
<p>Pour rappel, ces deux contraintes doivent être vérifiées à la compilation!</p>
<ul>
<li>
<p><strong>Question 1:</strong> Adaptez les définitions de <code>ChartType</code>, <code>PieChart</code>, <code>XYChart</code> et <code>draw</code> telles que:</p>
<ul>
<li>
<p>Tout scenario différent des deux ci-dessus fera échouer la compilation sur une erreur de type.</p>
</li>
<li>
<p><code>ChartType</code> doit toujours être un <code>sealed trait</code>. Mais il est autorisé à prendre des <em>paramètres de type</em> (c.-à-d. <em>generics</em>).</p>
</li>
<li>
<p><code>PieChart</code> et <code>XYChar</code> doivent toujours être des <code>case object</code>
et ils doivent toujours étendre <code>ChartType</code>.</p>
</li>
<li>
<p>Les déclarations de <code>ChartType</code>, <code>PieChart</code> et <code>XYChar</code>
ne doivent <strong>pas</strong> avoir <strong>de corps</strong> du tout
(c.-à-d. il ne doit pas y avoir d&rsquo;accolades <code>{ ... }</code> dans leurs déclarations);</p>
</li>
</ul>
  <details>
    <summary><em>Astuce (cliquer pour dévoiler)</em></summary>
<p>Le code ressemble à ceci:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">ChartType</span><span class="o">[</span><span class="kt">/*METTRE</span> <span class="kt">LES</span> <span class="kt">GENERICS</span> <span class="kt">ICI*/</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">case</span> <span class="k">object</span> <span class="nc">PieChart</span> <span class="k">extends</span> <span class="nc">ChartType</span><span class="o">[</span><span class="kt">/*Il</span> <span class="kt">y</span> <span class="kt">a</span> <span class="kt">quelque</span> <span class="kt">chose</span> <span class="kt">à</span> <span class="kt">écrire</span> <span class="kt">ici*/</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">case</span> <span class="k">object</span> <span class="nc">XYChart</span> <span class="k">extends</span> <span class="nc">ChartType</span><span class="o">[</span><span class="kt">/*Il</span> <span class="kt">y</span> <span class="kt">a</span> <span class="kt">quelque</span> <span class="kt">chose</span> <span class="kt">à</span> <span class="kt">écrire</span> <span class="kt">ici</span> <span class="kt">aussi*/</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">draw</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">chartType</span><span class="k">:</span> <span class="kt">ChartType</span><span class="o">[</span><span class="kt">/*Ecrire</span> <span class="kt">quelque</span> <span class="kt">chose</span> <span class="kt">ici*/</span><span class="o">])(</span><span class="n">data</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl"> <span class="n">chartType</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">PieChart</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">pieData</span> <span class="k">:</span> <span class="kt">PieData</span> <span class="o">=</span> <span class="n">data</span>
</span></span><span class="line"><span class="cl">      <span class="o">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">XYChart</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">xyData</span><span class="k">:</span> <span class="kt">XYData</span> <span class="o">=</span> <span class="n">data</span>
</span></span><span class="line"><span class="cl">      <span class="o">()</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span></span></span></code></pre></div>
  </details>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">ChartType</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">case</span> <span class="k">object</span> <span class="nc">PieChart</span> <span class="k">extends</span> <span class="nc">ChartType</span><span class="o">[</span><span class="kt">PieData</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">case</span> <span class="k">object</span> <span class="nc">XYChart</span> <span class="k">extends</span> <span class="nc">ChartType</span><span class="o">[</span><span class="kt">XYData</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">draw</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">chartType</span><span class="k">:</span> <span class="kt">ChartType</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">data</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl"> <span class="n">chartType</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">PieChart</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">pieData</span> <span class="k">:</span> <span class="kt">PieData</span> <span class="o">=</span> <span class="n">data</span>
</span></span><span class="line"><span class="cl">      <span class="o">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">XYChart</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">xyData</span><span class="k">:</span> <span class="kt">XYData</span> <span class="o">=</span> <span class="n">data</span>
</span></span><span class="line"><span class="cl">      <span class="o">()</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span></span></span></code></pre></div>
  </details>
</li>
</ul>
<p>Vous pouvez maintenant dormir sur vos deux oreilles avec l&rsquo;assurance que
votre code en production ne plantera pas à cause d&rsquo;une entrée non conforme
à cet endroit 😉</p>
<h2 id="cas-dutilisation-plus-avancés">Cas d&rsquo;Utilisation Plus Avancés</h2>
<p>Maintenant que vous avez vu ce que sont les <em>GADTs</em> et comment les utiliser dans
la vie de tous les jours, vous êtes prêt·e pour les cas d&rsquo;utilisations plus conséquents
ci-dessous.
Il y en a trois. Chacun illustre une manière différente d&rsquo;utiliser la puissance des <em>GADTs</em>.
Le <a href="../posts/les_gadts_par_l_exemple/index.html#cas-d-utilisation-les-effets">premier</a> traite de l&rsquo;expression d&rsquo;effets,
ce qui est très largement utilisé dans chaque monade <em>IO</em> populaire ou effets algébriques.
Ne vous inquiétez pas de ne pas savoir ce que sont ces derniers, cette section l&rsquo;expliquera.
Le <a href="../posts/les_gadts_par_l_exemple/index.html#cas-d-utilisation-s-assurer-que-les-types-sont-pris-en-charge-par-la-base-de-données">second</a>
s&rsquo;attache à montrer comment garantir des propriétés dans le système de types.
Ce point est illustré à travers l&rsquo;exemple de l’accommodation des techniques issues
de la programmation fonctionnelle aux contraintes issues des bases de données.
Le <a href="../posts/les_gadts_par_l_exemple/index.html#cas-d-utilisation-simplifier-les-implicites">troisième</a> offre une manière plus simple
de travailler avec des implicites.</p>
<h3 id="cas-dutilisation-les-effets">Cas d&rsquo;Utilisation: Les Effets!</h3>
<p>Ce qui est appelé un effet est parfois juste une interface déclarant quelques
fonctions dépourvues d&rsquo;implémentation. Par exemple nous pouvons définir le
<code>trait</code> ci-dessous. Notez qu&rsquo;<em>aucune</em> de ces fonctions n&rsquo;a d&rsquo;implémentation.</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">trait</span> <span class="nc">ExampleEffectSig</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">echo</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">randomInt</span> <span class="k">:</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">ignore</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p>Les implémentations de ces interfaces (traits) sont données ailleurs, et il peut en avoir beaucoup!
Cela est utile quand il est désirable de changer facilement d&rsquo;implémentation:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">object</span> <span class="nc">ExampleEffectImpl</span> <span class="k">extends</span> <span class="nc">ExampleEffectSig</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">echo</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">value</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">randomInt</span> <span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">scala</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">Random</span><span class="o">.</span><span class="n">nextInt</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">ignore</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">()</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p>Une manière équivalente de définir <code>ExampleEffectSig</code> est via un <code>sealed trait</code>
muni de quelques <code>final case class</code> (peut-être aucune!) et/ou quelques <code>case object</code> (peut-être aucun!):</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">ExampleEffect</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">Echo</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">ExampleEffect</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">RandomInt</span> <span class="k">extends</span> <span class="nc">ExampleEffect</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">Ignore</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">ExampleEffect</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span></span></span></code></pre></div>
<p>De nouveau, nous avons des déclarations ne fournissant aucune implémentation!
De nouveau, leurs implémentations peuvent être fournies ailleurs et il peut en avoir beaucoup:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">runExampleEffect</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">effect</span><span class="k">:</span> <span class="kt">ExampleEffect</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">effect</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">Echo</span><span class="o">(</span><span class="n">value</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">value</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">RandomInt</span>   <span class="k">=&gt;</span> <span class="n">scala</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">Random</span><span class="o">.</span><span class="n">nextInt</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">Ignore</span><span class="o">(</span><span class="k">_</span><span class="o">)</span>   <span class="k">=&gt;</span> <span class="o">()</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
<p>Prenons un effet plus réaliste ainsi qu&rsquo;une de ses implémentations possibles:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">trait</span> <span class="nc">EffectSig</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">currentTimeMillis</span><span class="k">:</span> <span class="kt">Long</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">printLn</span><span class="o">(</span><span class="n">msg</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">mesure</span><span class="o">[</span><span class="kt">X</span>,<span class="kt">A</span><span class="o">](</span><span class="n">fun</span><span class="k">:</span> <span class="kt">X</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">,</span> <span class="n">arg</span><span class="k">:</span> <span class="kt">X</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">object</span> <span class="nc">EffectImpl</span> <span class="k">extends</span> <span class="nc">EffectSig</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">currentTimeMillis</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">printLn</span><span class="o">(</span><span class="n">msg</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="n">println</span><span class="o">(</span><span class="n">msg</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">mesure</span><span class="o">[</span><span class="kt">X</span>,<span class="kt">A</span><span class="o">](</span><span class="n">fun</span><span class="k">:</span> <span class="kt">X</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">,</span> <span class="n">arg</span><span class="k">:</span> <span class="kt">X</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">val</span> <span class="n">t0</span> <span class="k">=</span> <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">val</span> <span class="n">r</span>  <span class="k">=</span> <span class="n">fun</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">val</span> <span class="n">t1</span> <span class="k">=</span> <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">println</span><span class="o">(</span><span class="s">s&#34;Took </span><span class="si">${</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="si">}</span><span class="s"> milli-seconds&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">r</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<ul>
<li>
<p><strong>Question 1:</strong> Tout comme <code>ExampleEffect</code> est l&rsquo;équivalent de <code>ExampleEffectSig</code>
via la définition d&rsquo;un <code>sealed trait</code> muni de quelques <code>final case class</code> et
<code>case object</code>, écrivez l&rsquo;équivalent de <code>EffectSig</code> de la même manière.
Appelez ce trait <code>Effect</code>.</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">CurrentTimeMillis</span> <span class="k">extends</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">PrintLn</span><span class="o">(</span><span class="n">msg</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">Mesure</span><span class="o">[</span><span class="kt">X</span>,<span class="kt">A</span><span class="o">](</span><span class="n">fun</span><span class="k">:</span> <span class="kt">X</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">,</span> <span class="n">arg</span><span class="k">:</span> <span class="kt">X</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span></span></span></code></pre></div>
  </details>
</li>
<li>
<p><strong>Question 2:</strong> Écrivez la fonction <code>def run[A](effect: Effect[A]): A</code> qui reproduit l&rsquo;implémentation de
<code>EffectImpl</code> tout comme <code>runExampleEffect</code> reproduit celle de <code>ExampleEffectImpl</code>.</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">run</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">effect</span><span class="k">:</span> <span class="kt">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">effect</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">CurrentTimeMillis</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">PrintLn</span><span class="o">(</span><span class="n">msg</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="n">println</span><span class="o">(</span><span class="n">msg</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">Mesure</span><span class="o">(</span><span class="n">fun</span><span class="o">,</span> <span class="n">arg</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">t0</span> <span class="k">=</span> <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">r</span>  <span class="k">=</span> <span class="n">fun</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">t1</span> <span class="k">=</span> <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">      <span class="n">println</span><span class="o">(</span><span class="s">s&#34;Took </span><span class="si">${</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="si">}</span><span class="s"> milli-seconds&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">r</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
  </details>
</li>
</ul>
<p>Le type <code>Effect[A]</code> déclare des effets intéressants (<code>CurrentTimeMillis</code>,
<code>PrintLn</code> et <code>Mesure</code>) mais pour être réellement utile, il doit être possible
de chaîner ces effets! Pour ce faire, nous voulons pouvoir disposer des deux fonctions suivantes:</p>
<ul>
<li><code>def pure[A](value: A): Effect[A]</code></li>
<li><code>def flatMap[X,A](fx: Effect[X], f: X =&gt; Effect[A]): Effect[A]</code></li>
</ul>
<p>De nouveau, nous ne nous intéressons pas à leurs implémentations. Tout ce que nous
voulons, pour le moment, est déclarer ces deux opérations de la même manière que
nous avons déclaré <code>CurrentTimeMillis</code>, <code>PrintLn</code> et <code>Mesure</code>.</p>
<ul>
<li>
<p><strong>Question 3:</strong> Ajoutez deux <em>final case classes</em>, <code>Pure</code> et <code>FlatMap</code>,
à <code>Effect[A]</code> déclarant ces deux opérations.</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">CurrentTimeMillis</span> <span class="k">extends</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">PrintLn</span><span class="o">(</span><span class="n">msg</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">Mesure</span><span class="o">[</span><span class="kt">X</span>,<span class="kt">A</span><span class="o">](</span><span class="n">fun</span><span class="k">:</span> <span class="kt">X</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">,</span> <span class="n">arg</span><span class="k">:</span> <span class="kt">X</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">Pure</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">FlatMap</span><span class="o">[</span><span class="kt">X</span>,<span class="kt">A</span><span class="o">](</span><span class="n">fx</span><span class="k">:</span> <span class="kt">Effect</span><span class="o">[</span><span class="kt">X</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">X</span> <span class="o">=&gt;</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span></span></span></code></pre></div>
  </details>
</li>
<li>
<p><strong>Question 4:</strong> Adaptez la fonction <code>run</code> pour gérer ces deux nouveaux cas.</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">run</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">effect</span><span class="k">:</span> <span class="kt">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">effect</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">CurrentTimeMillis</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">PrintLn</span><span class="o">(</span><span class="n">msg</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="n">println</span><span class="o">(</span><span class="n">msg</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">Mesure</span><span class="o">(</span><span class="n">fun</span><span class="o">,</span> <span class="n">arg</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">t0</span> <span class="k">=</span> <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">r</span>  <span class="k">=</span> <span class="n">fun</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">t1</span> <span class="k">=</span> <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">      <span class="n">println</span><span class="o">(</span><span class="s">s&#34;Took </span><span class="si">${</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="si">}</span><span class="s"> milli-seconds&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">r</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">Pure</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="n">a</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">FlatMap</span><span class="o">(</span><span class="n">fx</span><span class="o">,</span> <span class="n">f</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">x</span>  <span class="k">=</span> <span class="n">run</span><span class="o">(</span><span class="n">fx</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">fa</span> <span class="k">:</span> <span class="kt">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">run</span><span class="o">(</span><span class="n">fa</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
  </details>
</li>
<li>
<p><strong>Question 5:</strong> Ajoutez les deux méthodes suivantes au trait <code>Effect[A]</code> pour obtenir:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">final</span> <span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Effect</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nc">FlatMap</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">f</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="k">final</span> <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Effect</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">]((</span><span class="n">a</span><span class="k">:</span><span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Pure</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)))</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p>Et exécutez le code suivant pour voir s&rsquo;il fonctionne:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">effect1</span><span class="k">:</span> <span class="kt">Effect</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">t0</span> <span class="k">&lt;-</span> <span class="nc">CurrentTimeMillis</span>
</span></span><span class="line"><span class="cl">    <span class="k">_</span>  <span class="k">&lt;-</span> <span class="nc">PrintLn</span><span class="o">(</span><span class="s">s&#34;The current time is </span><span class="si">$t0</span><span class="s">&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span> <span class="k">yield</span> <span class="o">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">run</span><span class="o">(</span><span class="n">effect1</span><span class="o">)</span></span></span></code></pre></div>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">final</span> <span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Effect</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nc">FlatMap</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">f</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="k">final</span> <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Effect</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">]((</span><span class="n">a</span><span class="k">:</span><span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Pure</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)))</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">CurrentTimeMillis</span> <span class="k">extends</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">PrintLn</span><span class="o">(</span><span class="n">msg</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">Mesure</span><span class="o">[</span><span class="kt">X</span>,<span class="kt">A</span><span class="o">](</span><span class="n">fun</span><span class="k">:</span> <span class="kt">X</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">,</span> <span class="n">arg</span><span class="k">:</span> <span class="kt">X</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">Pure</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">FlatMap</span><span class="o">[</span><span class="kt">X</span>,<span class="kt">A</span><span class="o">](</span><span class="n">fx</span><span class="k">:</span> <span class="kt">Effect</span><span class="o">[</span><span class="kt">X</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">X</span> <span class="o">=&gt;</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">run</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">effect</span><span class="k">:</span> <span class="kt">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">effect</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">CurrentTimeMillis</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">PrintLn</span><span class="o">(</span><span class="n">msg</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="n">println</span><span class="o">(</span><span class="n">msg</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">Mesure</span><span class="o">(</span><span class="n">fun</span><span class="o">,</span> <span class="n">arg</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">t0</span> <span class="k">=</span> <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">r</span>  <span class="k">=</span> <span class="n">fun</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">t1</span> <span class="k">=</span> <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">      <span class="n">println</span><span class="o">(</span><span class="s">s&#34;Took </span><span class="si">${</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="si">}</span><span class="s"> milli-seconds&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">r</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">Pure</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="n">a</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">FlatMap</span><span class="o">(</span><span class="n">fx</span><span class="o">,</span> <span class="n">f</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">x</span>  <span class="k">=</span> <span class="n">run</span><span class="o">(</span><span class="n">fx</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">fa</span> <span class="k">:</span> <span class="kt">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">run</span><span class="o">(</span><span class="n">fa</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">effect1</span><span class="k">:</span> <span class="kt">Effect</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">t0</span> <span class="k">&lt;-</span> <span class="nc">CurrentTimeMillis</span>
</span></span><span class="line"><span class="cl">    <span class="k">_</span>  <span class="k">&lt;-</span> <span class="nc">PrintLn</span><span class="o">(</span><span class="s">s&#34;The current time is </span><span class="si">$t0</span><span class="s">&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span> <span class="k">yield</span> <span class="o">()</span></span></span></code></pre></div>
<p>En exécutant <code>run(effect1)</code> on obtient:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">run</span><span class="o">(</span><span class="n">effect1</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="nc">The</span> <span class="n">current</span> <span class="n">time</span> <span class="n">is</span> <span class="mi">1569773175010</span></span></span></code></pre></div>
  </details>
</li>
</ul>
<p>Félicitations! Vous venez d&rsquo;écrire votre première monade <em>IO</em>! Il y
a de nombreux noms scientifiques au <code>sealed trait Effect[A]</code>:
vous pouvez l&rsquo;appeler un <em>effet algébrique</em>, une <em>monade libre</em>, une <em>IO</em>, etc.
Mais au bout du compte, ce n&rsquo;est qu&rsquo;un simple et banal <code>sealed trait</code> pour lequel
nous avons défini quelques <code>final case class</code> et <code>case object</code> afin de
représenter les fonctions dont nous voulions disposer sans fournir
leurs implémentations (<code>CurrentTimeMillis</code>, <code>PrintLn</code>, <code>Mesure</code>,
<code>Pure</code> et <code>FlatMap</code>). Vous pouvez les appeler des <em>méthodes virtuelles</em> si vous voulez.
<strong>Ce qui importe réellement est d&rsquo;avoir isolé la définition de ces fonctions de leurs implémentations.</strong>
Rappelez vous qu&rsquo;un <code>trait</code> est juste une interface après tout.</p>
<h3 id="cas-dutilisation-sassurer-que-les-types-sont-pris-en-charge-par-la-base-de-données">Cas d&rsquo;Utilisation: S&rsquo;assurer que les types sont pris en charge par la Base De Données.</h3>
<p>Les bases de données sont formidables. Nous pouvons y stocker des tables, des documents,
des paires clef/valeur, des graphes, etc.
Mais, pour n&rsquo;importe quelle base de données, il y a malheureusement seulement un nombre limité
de types pris en charge.
Prenez la base de données que vous voulez, je suis sûr de pouvoir trouver des types qu&rsquo;elle
ne prend pas en charge.</p>
<p>Dans cette section, nous allons nous intéresser au cas des structures des données
et du code qui ne marche pas pour tout les types, mais seulement certains! Ce cas d&rsquo;usage
ne se limite pas aux bases de données mais concerne chaque <em>interface de programmation</em> qui ne
supporte qu&rsquo;un nombre limité de types (la vaste majorité des <em>interfaces de programmation</em>).
Comment s&rsquo;assurer du respect de ces contraintes? Comment adapter les techniques que nous aimons
afin qu&rsquo;elles travaillent sous ces contraintes? Voilà ce dont il s&rsquo;agit dans cette section.</p>
<p>Nous considérerons une base de données fictive qui ne prend en charge <strong>que</strong> les types suivants:</p>
<ol>
<li><code>String</code></li>
<li><code>Double</code></li>
<li><code>(A,B)</code> où <code>A</code> et <code>B</code> sont également des types pris en charge par la base de données.</li>
</ol>
<p>Cela signifie que les valeurs stockées dans la base de données (dans des tables, des paires clef/valeur,
etc) <strong>doivent</strong> respecter les règles ci-dessus. Elle peut stocker <code>&quot;Hello World&quot;</code> parce que c&rsquo;est une
<code>String</code>, qui est est un type pris en charge par la base de données en vertu de la règle <em>1</em>.
Pour les mêmes raisons, elle peut stocker <code>5.2</code> parce que c&rsquo;est un <code>Double</code>,
mais elle ne peut <strong>pas</strong> stocker l&rsquo;entier <code>5</code> parce que c&rsquo;est un<code>Int</code>.
Elle peut stocker <code>(&quot;Hello World&quot;, 5.2)</code> grâce à la règle <em>3</em> ainsi que
<code>((&quot;Hello World&quot;, 5.2) , 8.9)</code>, de nouveau grâce à la règle <em>3</em>.</p>
<ul>
<li>
<p><strong>Question 1:</strong> Définissez le type <code>DBType[A]</code> tel que:</p>
<blockquote>
<p>Il existe une valeur de type <code>DBType[A]</code> <strong>si et seulement si</strong> <code>A</code>
est un type pris en charge par la base de données.</p>
</blockquote>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<p>La version simple est:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">DBType</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">DBString</span> <span class="k">extends</span> <span class="nc">DBType</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">DBDouble</span> <span class="k">extends</span> <span class="nc">DBType</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">DBPair</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">first</span><span class="k">:</span> <span class="kt">DBType</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">second</span><span class="k">:</span> <span class="kt">DBType</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">DBType</span><span class="o">[(</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">)]</span></span></span></code></pre></div>
  <details>
  <summary><strong>Remarque pour les personnes à l'aise en <em>Scala</em></strong> <em>(cliquer pour dévoiler)</em></summary>
<p>En utilisant toutes les chouettes fonctionnalités syntaxiques de <em>Scala</em>,
la version satisfaisante en production du code ci-dessus est:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">DBType</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">object</span> <span class="nc">DBType</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">DBString</span> <span class="k">extends</span> <span class="nc">DBType</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">  <span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">DBDouble</span> <span class="k">extends</span> <span class="nc">DBType</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">DBPair</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">first</span><span class="k">:</span> <span class="kt">DBType</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">second</span><span class="k">:</span> <span class="kt">DBType</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">DBType</span><span class="o">[(</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">)]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">implicit</span> <span class="k">val</span> <span class="n">dbString</span> <span class="k">:</span> <span class="kt">DBType</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="nc">DBString</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">implicit</span> <span class="k">val</span> <span class="n">dbDouble</span> <span class="k">:</span> <span class="kt">DBType</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="nc">DBDouble</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">implicit</span> <span class="k">def</span> <span class="n">dbPair</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="k">implicit</span> <span class="n">first</span><span class="k">:</span> <span class="kt">DBType</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">second</span><span class="k">:</span> <span class="kt">DBType</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">DBType</span><span class="o">[(</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">)]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="nc">DBPair</span><span class="o">(</span><span class="n">first</span><span class="o">,</span> <span class="n">second</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">DBType</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">ev.</span><span class="k">type</span> <span class="o">=</span> <span class="n">ev</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
  </details>
  </details>
</li>
</ul>
<p>En utilisant <code>DBType</code>, nous pouvons coupler une valeur de type <code>A</code>
avec une valeur de type <code>DBType[A]</code>, fournissant ainsi la preuve que
le type <code>A</code> est pris en charge par la base de données:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">DBValue</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="k">val</span> <span class="n">dbType</span><span class="k">:</span> <span class="kt">DBType</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span></span></span></code></pre></div>
<p>Notez que le paramètre <code>dbType</code> n&rsquo;a nullement besoin d&rsquo;être implicite!
Ce qui compte est que pour créer une valeur de type <code>DBValue[A]</code>,
nous devons fournir une valeur de type <code>DBType[A]</code>
ce qui force <code>A</code> à être un type pris en charge par la base de données.</p>
<p>Un <em>foncteur</em> est, de manière informelle et approximative, un constructeur de type<code>F</code>,
comme <code>List</code>, <code>Option</code>, <code>DBValue</code>, etc,
pour lequel il est possible de fournir une instance du trait:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">trait</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p>où <code>map(fa)(f)</code> applique la fonction <code>f</code> à chaque valeur de type <code>A</code> contenue dans <code>fa</code>. Par exemple:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">implicit</span> <span class="k">object</span> <span class="nc">OptionFunctor</span> <span class="k">extends</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">Option</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="n">fa</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nc">None</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<ul>
<li>
<p><strong>Question 2:</strong> Écrivez une instance de <code>Functor[DBValue]</code>.</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<p>C&rsquo;est en fait impossible! Si nous tentions de compiler le code suivant:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">object</span> <span class="nc">DBValueFunctor</span> <span class="k">extends</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">DBValue</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">DBValue</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">DBValue</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="nc">DBValue</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="o">(</span><span class="n">fa</span><span class="o">.</span><span class="n">value</span><span class="o">))</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p><em>Scala</em> râlerait: <code>could not find implicit value for parameter dbType: DBType[B]</code>. En effet, les booléens
ne sont pas un type pris en charge par la base de données:
ils ne sont ni des chaînes de caractères, ni des nombres flottants, ni des paires de types pris en charge.</p>
<p>Supposons que nous puissions définir une instance de <code>Funcor</code> pour <code>DBValue</code>
(c.-à-d. que nous puissions définir une fonction <code>map</code> pour <code>DBValue</code>), alors nous pourrions écrire:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">dbValueString</span>  <span class="k">:</span> <span class="kt">DBValue</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>  <span class="k">=</span> <span class="nc">DBValue</span><span class="o">(</span><span class="s">&#34;A&#34;</span><span class="o">)(</span><span class="nc">DBString</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">dbValueBoolean</span> <span class="k">:</span> <span class="kt">DBValue</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="k">=</span> <span class="n">dbValueString</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">true</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">dbTypeBoooean</span>  <span class="k">:</span> <span class="kt">DBType</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span>  <span class="k">=</span> <span class="n">dbValueBoolean</span><span class="o">.</span><span class="n">dbType</span></span></span></code></pre></div>
<p>Nous obtiendrions une valeur (<code>dbTypeBoooean</code>) de type <code>DBType[Boolean]</code>
ce qui signifirait que le type <code>Boolean</code> est pris en charge par la base de données.
Mais il ne l&rsquo;est pas! Hors par définition:</p>
<blockquote>
<p>Il existe une valeur de type <code>DBType[A]</code> <strong>si et seulement si</strong> <code>A</code>
est un type pris en charge par la base de donnée.</p>
</blockquote>
<p>Donc il est impossible d&rsquo;obtenir une valeur de type <code>DBType[Boolean]</code>
et donc il est impossible d&rsquo;écrire une fonction <code>map</code> pout <code>DBValue</code>.
Ainsi il n&rsquo;y a aucun moyen de définir une instance de <code>Functor</code> pour <code>DBValue</code>. CQDF.</p>
  </details>
</li>
</ul>
<p>Un <em>Foncteur Généralisé</em> est très similaire à un <code>Functor</code> classique, à la différence près
que la fonction <code>map</code> ne doit pas obligatoirement être applicable à n&rsquo;importe quels
types <code>A</code> et <code>B</code> mais peut n&rsquo;être applicable qu&rsquo;à certains types <code>A</code> et <code>B</code> particuliers:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">trait</span> <span class="nc">GenFunctor</span><span class="o">[</span><span class="kt">P</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">evA</span><span class="k">:</span> <span class="kt">P</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">evB</span><span class="k">:</span> <span class="kt">P</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p>Par exemple, <code>Set</code> (plus précisément <code>TreeSet</code>) n&rsquo;est pas un foncteur!
En effet il n&rsquo;y a aucun moyen d&rsquo;écrire une fonction <code>map</code> qui fonctionne
pour n&rsquo;importe quel type <code>B</code> (parce qu&rsquo;il est nécessaire d&rsquo;avoir une relation d&rsquo;ordre sur <code>B</code>).
Mais si l&rsquo;on restreint <code>map</code> aux seuls types <code>B</code> disposant d&rsquo;une relation d&rsquo;ordre, alors il devient
possible d&rsquo;écrire:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">import</span> <span class="nn">scala.collection.immutable._</span>
</span></span><span class="line"><span class="cl"><span class="k">object</span> <span class="nc">TreeSetFunctor</span> <span class="k">extends</span> <span class="nc">GenFunctor</span><span class="o">[</span><span class="kt">Ordering</span>, <span class="kt">TreeSet</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">TreeSet</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">evA</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">evB</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">TreeSet</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="nc">TreeSet</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">evB</span><span class="o">)</span> <span class="o">++</span> <span class="n">fa</span><span class="o">.</span><span class="n">toSeq</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">f</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<ul>
<li>
<p><strong>Question 3:</strong> Écrivez une instance de <code>GenFunctor[DBType, DBValue]</code>.</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">object</span> <span class="nc">DBValueGenFunctor</span> <span class="k">extends</span> <span class="nc">GenFunctor</span><span class="o">[</span><span class="kt">DBType</span>, <span class="kt">DBValue</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">DBValue</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">evA</span><span class="k">:</span> <span class="kt">DBType</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">evB</span><span class="k">:</span> <span class="kt">DBType</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">DBValue</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="nc">DBValue</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="o">(</span><span class="n">fa</span><span class="o">.</span><span class="n">value</span><span class="o">))(</span><span class="n">evB</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
  </details>
</li>
</ul>
<p>Ce que nous avons fait ici avec <code>Functor</code> peut être fait avec de nombreuses structures de données et
techniques de programmation. Il est souvent possible de restreindre la plage des types sur lesquels
la structure de donnée ou la classe de types (<em>type class</em>) peut opérer en ajoutant un paramètre
supplémentaire comme <code>ev : DBType[A]</code> aux constructeurs et méthodes.</p>
<h3 id="cas-dutilisation-simplifier-les-implicites">Cas d&rsquo;Utilisation: Simplifier les Implicites</h3>
<p>Ce cas d&rsquo;utilisation est l&rsquo;un des plus intéressants, mais malheureusement, pas l&rsquo;un des plus simples.
Il montre comment il est possible d&rsquo;utiliser les <em>GADTs</em> pour simplifier la création de valeurs implicites.</p>
<p>Des listes de valeurs dont les éléments peuvent être de types différents sont appelées
<em>listes hétérogènes</em>. Elles sont généralement définies en <em>Scala</em> presque comme
les listes classiques:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">HNil</span><span class="o">()</span> <span class="c1">// La liste vide
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">HCons</span><span class="o">[</span><span class="kt">Head</span>,<span class="kt">Tail</span><span class="o">](</span><span class="n">head</span><span class="k">:</span> <span class="kt">Head</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">Tail</span><span class="o">)</span> <span class="c1">// L&#39;operation: `head :: tail`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">empty</span> <span class="k">:</span> <span class="kt">HNil</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="nc">HNil</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">oneTrueToto</span> <span class="k">:</span> <span class="kt">HCons</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">HCons</span><span class="o">[</span><span class="kt">Boolean</span>, <span class="kt">HCons</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">HNil</span><span class="o">]]]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="nc">HCons</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">HCons</span><span class="o">(</span><span class="kc">true</span><span class="o">,</span> <span class="nc">HCons</span><span class="o">(</span><span class="s">&#34;toto&#34;</span><span class="o">,</span> <span class="nc">HNil</span><span class="o">())))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">falseTrueFive</span><span class="k">:</span> <span class="kt">HCons</span><span class="o">[</span><span class="kt">Boolean</span>, <span class="kt">HCons</span><span class="o">[</span><span class="kt">Boolean</span>, <span class="kt">HCons</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">HNil</span><span class="o">]]]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="nc">HCons</span><span class="o">(</span><span class="kc">false</span><span class="o">,</span> <span class="nc">HCons</span><span class="o">(</span><span class="kc">true</span><span class="o">,</span> <span class="nc">HCons</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="nc">HNil</span><span class="o">())))</span></span></span></code></pre></div>
<p>Comme vous pouvez le voir, il n&rsquo;y a rien de vraiment spécial à propos de ces listes.
Nous voulons définir des relations d&rsquo;ordre sur les listes hétérogènes.
Une relation d&rsquo;ordre est une façon de comparer deux valeurs (<strong>du même type!</strong>):
elles peuvent êtres égales ou l&rsquo;une peut être strictement plus petite que l&rsquo;autre.
Une relation d&rsquo;ordre sur le type <code>A</code> peut se définir en <em>Scala</em> comme une instance
de <code>Order[A]</code> défini comme suit:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">trait</span> <span class="nc">Order</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// vrai si et seulement si a1 &lt; a2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">def</span> <span class="n">lesserThan</span><span class="o">(</span><span class="n">a1</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* a1 et a2 sont égales si et seulement si
</span></span></span><span class="line"><span class="cl"><span class="cm">     aucune d&#39;entre elles n&#39;est strictement plus petite que l&#39;autre
</span></span></span><span class="line"><span class="cl"><span class="cm">  */</span>
</span></span><span class="line"><span class="cl">  <span class="k">final</span> <span class="k">def</span> <span class="n">areEqual</span><span class="o">(</span><span class="n">a1</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">!</span><span class="n">lesserThan</span><span class="o">(</span><span class="n">a1</span><span class="o">,</span> <span class="n">a2</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">lesserThan</span><span class="o">(</span><span class="n">a2</span><span class="o">,</span> <span class="n">a1</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// a1 &gt; a2 si et seulement si a2 &lt; a1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">final</span> <span class="k">def</span> <span class="n">greaterThan</span><span class="o">(</span><span class="n">a1</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">lesserThan</span><span class="o">(</span><span class="n">a2</span><span class="o">,</span> <span class="n">a1</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">final</span> <span class="k">def</span> <span class="n">lesserThanOrEqual</span><span class="o">(</span><span class="n">a1</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">!</span><span class="n">lesserThan</span><span class="o">(</span><span class="n">a2</span><span class="o">,</span> <span class="n">a1</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">final</span> <span class="k">def</span> <span class="n">greaterThanOrEqual</span><span class="o">(</span><span class="n">a1</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">!</span><span class="n">lesserThan</span><span class="o">(</span><span class="n">a1</span><span class="o">,</span> <span class="n">a2</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">object</span> <span class="nc">Order</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">ev.</span><span class="k">type</span> <span class="o">=</span> <span class="n">ev</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">make</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">lg_</span> <span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span><span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="k">new</span> <span class="nc">Order</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">def</span> <span class="n">lesserThan</span><span class="o">(</span><span class="n">a1</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">lg_</span><span class="o">(</span><span class="n">a1</span><span class="o">,</span><span class="n">a2</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">implicit</span> <span class="k">val</span> <span class="n">orderInt</span>    <span class="k">=</span> <span class="nc">Order</span><span class="o">.</span><span class="n">make</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="k">_</span> <span class="o">&lt;</span> <span class="k">_</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="k">implicit</span> <span class="k">val</span> <span class="n">orderString</span> <span class="k">=</span> <span class="nc">Order</span><span class="o">.</span><span class="n">make</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="k">_</span> <span class="o">&lt;</span> <span class="k">_</span><span class="o">)</span></span></span></code></pre></div>
<p>Pour rappel, nous ne comparerons que des listes de <em>même type</em>:</p>
<ul>
<li>Les listes de type <code>HNil</code> seront uniquement comparées à d&rsquo;autres listes de type <code>HNil</code>.</li>
<li>Les listes de type <code>HCons[H,T]</code> seront uniquement comparées à d&rsquo;autres listes de type <code>HCons[H,T]</code>.</li>
</ul>
<p>Comparer des listes de type <code>HNil</code> est trivial parce qu&rsquo;il n&rsquo;y a qu&rsquo;une seule et unique valeur
de type <code>HNil</code> (la liste vide <code>HNil()</code>). Mais il existe de nombreuses façon de comparer des listes
de type <code>HCons[H,T]</code>.
Voici deux relations d&rsquo;ordre possibles (il en existe de nombreuses autres!):</p>
<ul>
<li>
<p>L&rsquo;<em>ordre lexicographique</em> (c.-à-d. l&rsquo;ordre du dictionnaire: de la gauche vers la droite)</p>
<blockquote>
<p><code>HCons(h1,t1) &lt; HCons(h2,t2)</code> <strong>si et seulement si</strong>
<code>h1 &lt; h2</code> <em>ou</em> (<code>h1 == h2</code> <em>et</em> <code>t1 &lt; t2</code> <em>par l&rsquo;ordre lexicographique</em>).</p>
</blockquote>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Lex</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">val</span> <span class="n">order</span> <span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">object</span> <span class="nc">Lex</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Lex</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">ev.</span><span class="k">type</span> <span class="o">=</span> <span class="n">ev</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">implicit</span> <span class="k">val</span> <span class="n">lexHNil</span><span class="k">:</span> <span class="kt">Lex</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="k">new</span> <span class="nc">Lex</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">order</span> <span class="k">=</span> <span class="nc">Order</span><span class="o">.</span><span class="n">make</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]((</span><span class="k">_</span><span class="o">,</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="kc">false</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">implicit</span> <span class="k">def</span> <span class="n">lexHCons</span><span class="o">[</span><span class="kt">Head</span>,<span class="kt">Tail</span><span class="o">](</span><span class="k">implicit</span>
</span></span><span class="line"><span class="cl">      <span class="n">orderHead</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">Head</span><span class="o">],</span>
</span></span><span class="line"><span class="cl">      <span class="n">lexTail</span><span class="k">:</span> <span class="kt">Lex</span><span class="o">[</span><span class="kt">Tail</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">    <span class="o">)</span><span class="k">:</span> <span class="kt">Lex</span><span class="o">[</span><span class="kt">HCons</span><span class="o">[</span><span class="kt">Head</span>, <span class="kt">Tail</span><span class="o">]]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="k">new</span> <span class="nc">Lex</span><span class="o">[</span><span class="kt">HCons</span><span class="o">[</span><span class="kt">Head</span>, <span class="kt">Tail</span><span class="o">]]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">orderTail</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">Tail</span><span class="o">]</span> <span class="k">=</span> <span class="n">lexTail</span><span class="o">.</span><span class="n">order</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">order</span> <span class="k">=</span> <span class="nc">Order</span><span class="o">.</span><span class="n">make</span><span class="o">[</span><span class="kt">HCons</span><span class="o">[</span><span class="kt">Head</span>, <span class="kt">Tail</span><span class="o">]]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="o">(</span><span class="nc">HCons</span><span class="o">(</span><span class="n">h1</span><span class="o">,</span><span class="n">t1</span><span class="o">),</span> <span class="nc">HCons</span><span class="o">(</span><span class="n">h2</span><span class="o">,</span><span class="n">t2</span><span class="o">))</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="n">orderHead</span><span class="o">.</span><span class="n">lesserThan</span><span class="o">(</span><span class="n">h1</span><span class="o">,</span><span class="n">h2</span><span class="o">)</span> <span class="o">||</span> <span class="o">(</span><span class="n">orderHead</span><span class="o">.</span><span class="n">areEqual</span><span class="o">(</span><span class="n">h1</span><span class="o">,</span><span class="n">h2</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">orderTail</span><span class="o">.</span><span class="n">lesserThan</span><span class="o">(</span><span class="n">t1</span><span class="o">,</span><span class="n">t2</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">      <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
</li>
<li>
<p>L&rsquo;<em>ordre lexicographique inversé</em> qui est la version à l&rsquo;envers de l&rsquo;ordre lexicographique
(c.-à-d. de droite à gauche)</p>
<blockquote>
<p><code>HCons(h1,t1) &lt; HCons(h2,t2)</code> <strong>si et seulement si</strong>
(<code>t1 &lt; t2</code> <em>par ordre lexicographique inversé</em>) <em>ou</em> (<code>t1 == t2</code> <em>et</em> <code>h1 &lt; h2</code>).</p>
</blockquote>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">RevLex</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">val</span> <span class="n">order</span> <span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">object</span> <span class="nc">RevLex</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">RevLex</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">ev.</span><span class="k">type</span> <span class="o">=</span> <span class="n">ev</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">implicit</span> <span class="k">val</span> <span class="n">revLexHNil</span><span class="k">:</span> <span class="kt">RevLex</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="k">new</span> <span class="nc">RevLex</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">order</span> <span class="k">=</span> <span class="nc">Order</span><span class="o">.</span><span class="n">make</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]((</span><span class="k">_</span><span class="o">,</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="kc">false</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">implicit</span> <span class="k">def</span> <span class="n">revLexHCons</span><span class="o">[</span><span class="kt">Head</span>,<span class="kt">Tail</span><span class="o">](</span><span class="k">implicit</span>
</span></span><span class="line"><span class="cl">      <span class="n">orderHead</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">Head</span><span class="o">],</span>
</span></span><span class="line"><span class="cl">      <span class="n">revLexTail</span><span class="k">:</span> <span class="kt">RevLex</span><span class="o">[</span><span class="kt">Tail</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">    <span class="o">)</span><span class="k">:</span> <span class="kt">RevLex</span><span class="o">[</span><span class="kt">HCons</span><span class="o">[</span><span class="kt">Head</span>, <span class="kt">Tail</span><span class="o">]]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="k">new</span> <span class="nc">RevLex</span><span class="o">[</span><span class="kt">HCons</span><span class="o">[</span><span class="kt">Head</span>, <span class="kt">Tail</span><span class="o">]]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">orderTail</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">Tail</span><span class="o">]</span> <span class="k">=</span> <span class="n">revLexTail</span><span class="o">.</span><span class="n">order</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">order</span> <span class="k">=</span> <span class="nc">Order</span><span class="o">.</span><span class="n">make</span><span class="o">[</span><span class="kt">HCons</span><span class="o">[</span><span class="kt">Head</span>, <span class="kt">Tail</span><span class="o">]]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="o">(</span><span class="nc">HCons</span><span class="o">(</span><span class="n">h1</span><span class="o">,</span><span class="n">t1</span><span class="o">),</span> <span class="nc">HCons</span><span class="o">(</span><span class="n">h2</span><span class="o">,</span><span class="n">t2</span><span class="o">))</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="n">orderTail</span><span class="o">.</span><span class="n">lesserThan</span><span class="o">(</span><span class="n">t1</span><span class="o">,</span><span class="n">t2</span><span class="o">)</span> <span class="o">||</span> <span class="o">(</span><span class="n">orderTail</span><span class="o">.</span><span class="n">areEqual</span><span class="o">(</span><span class="n">t1</span><span class="o">,</span><span class="n">t2</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">orderHead</span><span class="o">.</span><span class="n">lesserThan</span><span class="o">(</span><span class="n">h1</span><span class="o">,</span><span class="n">h2</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">      <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
</li>
</ul>
<p>Comme dit plus haut, il est possible de définir davantage de relations d&rsquo;ordre:</p>
<ul>
<li>
<p><strong>Question 1:</strong> L&rsquo;ordre <code>Alternate</code> est défini par:</p>
<blockquote>
<p><code>HCons(h1,t1) &lt; HCons(h2,t2)</code> <strong>si et seulement si</strong>
<code>h1 &lt; h2</code> <em>ou</em> (<code>h1 == h2</code> <em>et</em> <code>t1 &gt; t2</code> <em>par ordre</em> <code>Alternate</code>).</p>
</blockquote>
<p>En suivant la méthoe employée pour <code>Lex</code> and <code>RevLex</code>,
implémentez l&rsquo;ordre <code>Alternate</code>.</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Alternate</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">val</span> <span class="n">order</span> <span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">object</span> <span class="nc">Alternate</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Alternate</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">ev.</span><span class="k">type</span> <span class="o">=</span> <span class="n">ev</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">implicit</span> <span class="k">val</span> <span class="n">alternateHNil</span><span class="k">:</span> <span class="kt">Alternate</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="k">new</span> <span class="nc">Alternate</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">order</span> <span class="k">=</span> <span class="nc">Order</span><span class="o">.</span><span class="n">make</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]((</span><span class="k">_</span><span class="o">,</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="kc">false</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">implicit</span> <span class="k">def</span> <span class="n">alternateHCons</span><span class="o">[</span><span class="kt">Head</span>,<span class="kt">Tail</span><span class="o">](</span><span class="k">implicit</span>
</span></span><span class="line"><span class="cl">      <span class="n">orderHead</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">Head</span><span class="o">],</span>
</span></span><span class="line"><span class="cl">      <span class="n">alternateTail</span><span class="k">:</span> <span class="kt">Alternate</span><span class="o">[</span><span class="kt">Tail</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">    <span class="o">)</span><span class="k">:</span> <span class="kt">Alternate</span><span class="o">[</span><span class="kt">HCons</span><span class="o">[</span><span class="kt">Head</span>, <span class="kt">Tail</span><span class="o">]]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="k">new</span> <span class="nc">Alternate</span><span class="o">[</span><span class="kt">HCons</span><span class="o">[</span><span class="kt">Head</span>, <span class="kt">Tail</span><span class="o">]]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">orderTail</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">Tail</span><span class="o">]</span> <span class="k">=</span> <span class="n">alternateTail</span><span class="o">.</span><span class="n">order</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">order</span> <span class="k">=</span> <span class="nc">Order</span><span class="o">.</span><span class="n">make</span><span class="o">[</span><span class="kt">HCons</span><span class="o">[</span><span class="kt">Head</span>, <span class="kt">Tail</span><span class="o">]]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="o">(</span><span class="nc">HCons</span><span class="o">(</span><span class="n">h1</span><span class="o">,</span><span class="n">t1</span><span class="o">),</span> <span class="nc">HCons</span><span class="o">(</span><span class="n">h2</span><span class="o">,</span><span class="n">t2</span><span class="o">))</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="n">orderHead</span><span class="o">.</span><span class="n">lesserThan</span><span class="o">(</span><span class="n">h1</span><span class="o">,</span><span class="n">h2</span><span class="o">)</span> <span class="o">||</span> <span class="o">(</span><span class="n">orderHead</span><span class="o">.</span><span class="n">areEqual</span><span class="o">(</span><span class="n">h1</span><span class="o">,</span><span class="n">h2</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">orderTail</span><span class="o">.</span><span class="n">greaterThan</span><span class="o">(</span><span class="n">t1</span><span class="o">,</span><span class="n">t2</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">      <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
  </details>
</li>
</ul>
<p>Il existe de nombreuses manières de définir une relation d&rsquo;ordre valide sur les listes hétérogènes!
Créer une classe de type (<em>type class</em>) comme <code>Lex</code>, <code>RevLex</code> et <code>Alternate</code> pour chaque relation
d&rsquo;ordre voulue est fatigant et propice aux erreurs. Nous pouvons faire bien mieux &hellip;
avec un <em>GADT</em> 😉</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">HListOrder</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">object</span> <span class="nc">HListOrder</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">HNilOrder</span> <span class="k">extends</span> <span class="nc">HListOrder</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">HConsOrder</span><span class="o">[</span><span class="kt">Head</span>,<span class="kt">Tail</span><span class="o">](</span>
</span></span><span class="line"><span class="cl">      <span class="n">orderHead</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">Head</span><span class="o">],</span>
</span></span><span class="line"><span class="cl">      <span class="n">hlistOrderTail</span><span class="k">:</span> <span class="kt">HListOrder</span><span class="o">[</span><span class="kt">Tail</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">    <span class="o">)</span> <span class="k">extends</span> <span class="nc">HListOrder</span><span class="o">[</span><span class="kt">HCons</span><span class="o">[</span><span class="kt">Head</span>,<span class="kt">Tail</span><span class="o">]]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Définitions des Implicites
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="k">implicit</span> <span class="k">val</span> <span class="n">hnilOrder</span> <span class="k">:</span> <span class="kt">HListOrder</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="nc">HNilOrder</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">implicit</span> <span class="k">def</span> <span class="n">hconsOrder</span><span class="o">[</span><span class="kt">Head</span>,<span class="kt">Tail</span><span class="o">](</span><span class="k">implicit</span>
</span></span><span class="line"><span class="cl">      <span class="n">orderHead</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">Head</span><span class="o">],</span>
</span></span><span class="line"><span class="cl">      <span class="n">hlistOrderTail</span><span class="k">:</span> <span class="kt">HListOrder</span><span class="o">[</span><span class="kt">Tail</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">    <span class="o">)</span><span class="k">:</span> <span class="kt">HListOrder</span><span class="o">[</span><span class="kt">HCons</span><span class="o">[</span><span class="kt">Head</span>,<span class="kt">Tail</span><span class="o">]]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="nc">HConsOrder</span><span class="o">(</span><span class="n">orderHead</span><span class="o">,</span> <span class="n">hlistOrderTail</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">HListOrder</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">ev.</span><span class="k">type</span> <span class="o">=</span> <span class="n">ev</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p>Il est à noter que la définition de ces implicites est du pur boilerplate. Leur seule
raison d&rsquo;être est de passer leurs arguments au constructeur correspondant
(c.-à-d. <code>final case class</code> ou <code>case object</code>):
<code>hnilOrder</code> à <code>HListOrder</code> (O arguments) et <code>hconsOrder</code> à <code>HConsOrder</code> (2 arguments).</p>
<ul>
<li>
<p><strong>Question 2:</strong> Écrivez une fonction <code>def lex[A](implicit v : HListOrder[A]): Order[A]</code>
qui retourne l&rsquo;ordre lexicographique à partir d&rsquo;une valeur de type <code>HListOrder[A]</code>.</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">lex</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">implicit</span> <span class="n">v</span> <span class="k">:</span> <span class="kt">HListOrder</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">v</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">HListOrder</span><span class="o">.</span><span class="nc">HNilOrder</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nc">Order</span><span class="o">.</span><span class="n">make</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]((</span><span class="k">_</span><span class="o">,</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="kc">false</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="n">hc</span> <span class="k">:</span> <span class="kt">HListOrder.HConsOrder</span><span class="o">[</span><span class="kt">head</span>,<span class="kt">tail</span><span class="o">]</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">orderHead</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">head</span><span class="o">]</span> <span class="k">=</span> <span class="n">hc</span><span class="o">.</span><span class="n">orderHead</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">orderTail</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">tail</span><span class="o">]</span> <span class="k">=</span> <span class="n">lex</span><span class="o">(</span><span class="n">hc</span><span class="o">.</span><span class="n">hlistOrderTail</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="nc">Order</span><span class="o">.</span><span class="n">make</span><span class="o">[</span><span class="kt">HCons</span><span class="o">[</span><span class="kt">head</span>, <span class="kt">tail</span><span class="o">]]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="o">(</span><span class="nc">HCons</span><span class="o">(</span><span class="n">h1</span><span class="o">,</span><span class="n">t1</span><span class="o">),</span> <span class="nc">HCons</span><span class="o">(</span><span class="n">h2</span><span class="o">,</span><span class="n">t2</span><span class="o">))</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="n">orderHead</span><span class="o">.</span><span class="n">lesserThan</span><span class="o">(</span><span class="n">h1</span><span class="o">,</span><span class="n">h2</span><span class="o">)</span> <span class="o">||</span> <span class="o">(</span><span class="n">orderHead</span><span class="o">.</span><span class="n">areEqual</span><span class="o">(</span><span class="n">h1</span><span class="o">,</span><span class="n">h2</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">orderTail</span><span class="o">.</span><span class="n">lesserThan</span><span class="o">(</span><span class="n">t1</span><span class="o">,</span><span class="n">t2</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">      <span class="o">}</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
  </details>
</li>
<li>
<p><strong>Question 3:</strong> Écrivez une fonction <code>def revLex[A](implicit v : HListOrder[A]): Order[A]</code>
qui retourne l&rsquo;ordre lexicographique inversé à partir d&rsquo;une valeur de type <code>HListOrder[A]</code>.</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">revLex</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">implicit</span> <span class="n">v</span> <span class="k">:</span> <span class="kt">HListOrder</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">v</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">HListOrder</span><span class="o">.</span><span class="nc">HNilOrder</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nc">Order</span><span class="o">.</span><span class="n">make</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]((</span><span class="k">_</span><span class="o">,</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="kc">false</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="n">hc</span> <span class="k">:</span> <span class="kt">HListOrder.HConsOrder</span><span class="o">[</span><span class="kt">head</span>,<span class="kt">tail</span><span class="o">]</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">orderHead</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">head</span><span class="o">]</span> <span class="k">=</span> <span class="n">hc</span><span class="o">.</span><span class="n">orderHead</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">orderTail</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">tail</span><span class="o">]</span> <span class="k">=</span> <span class="n">revLex</span><span class="o">(</span><span class="n">hc</span><span class="o">.</span><span class="n">hlistOrderTail</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="nc">Order</span><span class="o">.</span><span class="n">make</span><span class="o">[</span><span class="kt">HCons</span><span class="o">[</span><span class="kt">head</span>, <span class="kt">tail</span><span class="o">]]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="o">(</span><span class="nc">HCons</span><span class="o">(</span><span class="n">h1</span><span class="o">,</span><span class="n">t1</span><span class="o">),</span> <span class="nc">HCons</span><span class="o">(</span><span class="n">h2</span><span class="o">,</span><span class="n">t2</span><span class="o">))</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="n">orderTail</span><span class="o">.</span><span class="n">lesserThan</span><span class="o">(</span><span class="n">t1</span><span class="o">,</span><span class="n">t2</span><span class="o">)</span> <span class="o">||</span> <span class="o">(</span><span class="n">orderTail</span><span class="o">.</span><span class="n">areEqual</span><span class="o">(</span><span class="n">t1</span><span class="o">,</span><span class="n">t2</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">orderHead</span><span class="o">.</span><span class="n">lesserThan</span><span class="o">(</span><span class="n">h1</span><span class="o">,</span><span class="n">h2</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">      <span class="o">}</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
  </details>
</li>
</ul>
<p>Cette approche a de nombreux avantages. Alors que l&rsquo;approche initiale devait effectuer
une recherche d&rsquo;implicites pour chaque relation d&rsquo;ordre, l&rsquo;approche par <em>GADT</em> n&rsquo;a besoin
de faire cette recherche qu&rsquo;une seule fois!
Sachant que la résolution d&rsquo;implicites est une opération gourmande, la réduire signifie des
temps de compilation plus courts.
Lire le code des fonctions <code>lex</code> et <code>revLex</code> est également plus simple que comprendre
comment la résolution d&rsquo;implicites fonctionne pour les traits <code>Lex</code> et <code>RevLex</code>.
De plus, ce ne sont que des fonctions, vous pouvez y utiliser tout ce que vous pouvez
programmer afin de construire les instances de <code>Order[A]</code>.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Pas si trivial, n&rsquo;est-ce pas? 😉 En fait, une grande part de la complexité
à laquelle vous venez de faire face vient du triste fait que les techniques
de raisonnements sur les types et valeurs ne sont presque jamais enseignées dans
les cours de programmation.
Ce que vous trouvez simple maintenant (API Web, Streaming, Bases De Données, etc)
terrifierait probablement la/le jeune programmeuse·eur que vous étiez à votre
premier &ldquo;Hello World!&rdquo;.
Vous n&rsquo;avez probablement pas appris tout ce que vous savez en programmation en
trois heures, donc n&rsquo;attendez pas des techniques de raisonnement sur des programmes
d&rsquo;êtres magiquement plus simples.</p>
<p>Cet atelier avait pour but de vous inspirer, d&rsquo;ouvrir votre esprit à ce nouvel univers
de possibilités. Si vous trouvez ces cas d&rsquo;utilisation intéressants, alors prenez le temps
de comprendre les techniques.</p>
<p>Amusez vous bien et prenez bien soin de vous ❤️</p>

  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="gadts-by-use-cases">GADTs By Use Cases</h1>
    <p class="article-meta default"><em>26 Oct 2019 - 7400 Words</em></p>

<p><strong>This workshop will be presented at <a href="https://scala.io/" rel="external" target="_self">ScalaIO 2019</a>,
in <em>Lyon</em> (<em>France</em>), on <a href="https://schedule.scala.io/#/day/1" rel="external" target="_self"><em>Tuesday the 29th of October</em> at 9am</a>.</strong></p>
<p>Welcome. This session will introduce you to a very powerful tool in
programming. Whereas most introduction start by presenting its
theoretical foundations in a very formal way, we chose to present
it via short examples and practical use cases.</p>
<p>This workshop is made of three parts. The last one presents three
of the most valuable use cases. They are the real big powerful use cases.
But do not go there unprepared! This is the last part for a reason:
they rely massively on lessons you will learn in the previous parts.
Start by <a href="../posts/gadts_by_use_cases/index.html#first-contact">First Contact</a>, it will show
you, via the simplest examples, the core ideas. Its goal is to open your
mind to ways of using types and data you may have never imagined possible.
Then go to
<a href="../posts/gadts_by_use_cases/index.html#easy-useful-use-cases-relations-on-types">Easy Useful Use Cases: Relations on Types</a>,
for the first real-life challenge.
Then, you are ready for <a href="../posts/gadts_by_use_cases/index.html#more-advanced-use-cases">More Advanced Use Cases</a>.</p>
<p>Be sure to <strong>read <a href="../posts/gadts_by_use_cases/index.html#readme">README</a></strong>, it contains precious tips to ease your
journey.</p>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>We would like to thank <a href="http://www.laure-juglaret.fr/" rel="external" target="_self">Laure Juglaret</a> for
having reviewed this presentation many times, for her precious remarks and
corrections.</p>
<h2 id="readme">README</h2>
<p>In this presentation we will assume that:</p>
<ul>
<li><code>null</code> <strong>does not exists!</strong></li>
<li><strong>runtime-reflection does not exist!</strong> (i.e. <code>isInstanceOf</code>, <code>getClass</code>, etc)</li>
</ul>
<p>This presentation considers that <em>these features do not exists at all</em>.</p>
<p><strong>Using these features will never lead to a valid answer</strong>.</p>
<p>This presentation expects you to have access to something where
you can easily write, compile and run <em>Scala</em> code. The best way to do so
is opening a <em>R.E.P.L.</em> session. If you have <em>Scala</em> installed on your system,
you can easily start one from the command-line by executing <code>scala</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">system</span><span class="o">-</span><span class="n">command</span><span class="o">-</span><span class="n">line</span><span class="k">#</span> <span class="n">scala</span>
</span></span><span class="line"><span class="cl"><span class="nc">Welcome</span> <span class="n">to</span> <span class="nc">Scala</span> <span class="mf">2.13</span><span class="o">.</span><span class="mi">1</span> <span class="o">(</span><span class="nc">OpenJDK</span> <span class="mi">64</span><span class="o">-</span><span class="nc">Bit</span> <span class="nc">Server</span> <span class="nc">VM</span><span class="o">,</span> <span class="nc">Java</span> <span class="mf">1.8</span><span class="o">.</span><span class="mi">0</span><span class="n">_222</span><span class="o">).</span>
</span></span><span class="line"><span class="cl"><span class="nc">Type</span> <span class="n">in</span> <span class="n">expressions</span> <span class="k">for</span> <span class="n">evaluation</span><span class="o">.</span> <span class="nc">Or</span> <span class="k">try</span> <span class="k">:</span><span class="kt">help.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">scala&gt;</span></span></span></code></pre></div>
<p>Remember that the <em>R.E.P.L</em> command <code>:paste</code> allows to paste code
and <code>:reset</code> cleans the environment.</p>
<p>If you don&rsquo;t have <em>Scala</em> installed, <strong>you can use</strong> the <em>online-REPL</em>
<a href="https://scastie.scala-lang.org/" rel="external" target="_self">https://scastie.scala-lang.org/</a> .</p>
<h2 id="stretching">Stretching</h2>
<p>This section is a brief reminder of some definitions and properties
about values and types.</p>
<h3 id="values-and-types"><em>Values</em> and <em>Types</em>?</h3>
<p><strong>Values</strong> are <em>actual piece of data your program manipulates</em>
like the integer <code>5</code>, the boolean <code>true</code>, the string <code>&quot;Hello World!&quot;</code>,
the function <code>(x: Double) =&gt; x / 7.5</code>, the list <code>List(1,2,3)</code>, etc.
It is convenient to classify values into groups. These groups are called
<strong>types</strong>. For example:</p>
<ul>
<li><code>Int</code> is the group of integer values, i.e. values like <code>1</code>, <code>-7</code>, <code>19</code>, etc.</li>
<li><code>Boolean</code> is the group containing exactly the values
<code>true</code> and <code>false</code> (no more, no less!).</li>
<li><code>String</code> is the group whose values are <code>&quot;Hello World!&quot;</code>, <code>&quot;&quot;</code>, <code>&quot;I ❤️ GADTs&quot;</code>, etc.</li>
<li><code>Double =&gt; Double</code> is the group whose values are functions taking
any <code>Double</code> as argument and returning some <code>Double</code>.</li>
</ul>
<p>To indicate that the value <code>v</code> belongs to the type (i.e. group of values) <code>T</code>,
we write <code>v : T</code>. In <em>Scala</em>, testing if a value <code>v</code> belongs to a type <code>T</code>
is very simple: just type <code>v : T</code> in the <em>REPL</em>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="mi">5</span> <span class="k">:</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl"><span class="n">res7</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">5</span></span></span></code></pre></div>
<p>If <em>Scala</em> accepts it, then <code>v</code> belongs to <code>T</code>. If <em>Scala</em> complains,
it most probably does not :</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="mi">5</span> <span class="k">:</span> <span class="kt">String</span>
</span></span><span class="line"><span class="cl">       <span class="o">^</span>
</span></span><span class="line"><span class="cl">       <span class="n">error</span><span class="k">:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">found</span>   <span class="k">:</span> <span class="kt">Int</span><span class="o">(</span><span class="err">5</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="kt">required:</span> <span class="kt">String</span></span></span></code></pre></div>
<h3 id="how-many-types">How many types?</h3>
<p>Let&rsquo;s now create some types and some of their values (when possible!).</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">OneType</span></span></span></code></pre></div>
<ul>
<li>
<p><strong>Question 1:</strong> How many types does the line <code>class OneType</code> defines?</p>
  <details>
    <summary><em>Solution (click to expand)</em></summary>
<p>As the name suggests, <code>class OneType</code> defines only one type which is named <code>OneType</code>.</p>
  </details>
</li>
</ul>
<p>Let&rsquo;s now consider:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">OneTypeForEvery</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span></span></span></code></pre></div>
<ul>
<li>
<p><strong>Question 2:</strong> How many types does the line <code>class OneTypeForEvery[A]</code> defines?</p>
  <details>
    <summary><em>Solution (click to expand)</em></summary>
<p>As the name suggests, every concrete type <code>A</code> gives
rise to a distinct type <code>OneTypeForEvery[A]</code>.</p>
<p>For example, a list of integers is neither a list of booleans,
nor a list of strings, nor a list of functions, nor &hellip;
It means the types <code>List[Int]</code>, <code>List[Boolean]</code>,
<code>List[Int =&gt; Int]</code>, etc are all distinct types.</p>
<p>The line <code>class OneTypeForEvery[A]</code> defines a
<strong>distinct type for every concrete type</strong> <code>A</code>. There
is an infnity of concrete types <code>A</code>, so an infinity of distinct types
<code>OneTypeForEvery[A]</code>.</p>
  </details>
</li>
<li>
<p><strong>Question 3:</strong> Give a value that belongs to both <code>OneTypeForEvery[Int]</code>
and <code>OneTypeForEvery[Boolean]</code>.</p>
<p><strong>Remember that <code>null</code> does not exist!</strong></p>
  <details>
    <summary><em>Solution (click to expand)</em></summary>
<p>This is actually impossible. Every concrete type <code>A</code> give rise a distinct type <code>OneTypeForEvery[A]</code>
that have no values in common with others types <code>OneTypeForEvery[B]</code> for <code>B ≠ A</code>.</p>
  </details>
</li>
</ul>
<h3 id="how-many-values">How many values?</h3>
<p>Considering the following type:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">final</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">NoValueForThisType</span></span></span></code></pre></div>
<ul>
<li>
<p><strong>Question 1:</strong> Give a value belonging to the type <code>NoValueForThisType</code>?
How many values belong to <code>NoValueForThisType</code>?</p>
  <details>
  <summary><em>Hint (click to expand)</em></summary>
<ul>
<li>What is a <code>final</code> class? How does it differ from a normal non-final class?</li>
<li>What is an <code>abstract</code> class? How does it differ from a concrete class?</li>
</ul>
  </details>
  <details>
    <summary><em>Solution (click to expand)</em></summary>
<p>The class <code>NoValueForThisType</code> is declared <code>abstract</code>. It is then forbidden to create
a direct instance of this class:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="k">new</span> <span class="nc">NoValueForThisType</span>
</span></span><span class="line"><span class="cl">        <span class="o">^</span>
</span></span><span class="line"><span class="cl">        <span class="n">error</span><span class="k">:</span> <span class="kt">class</span> <span class="kt">NoValueForThisType</span> <span class="kt">is</span> <span class="kt">abstract</span><span class="o">;</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">instantiated</span></span></span></code></pre></div>
<p>The only way to create an instance of an abstract class is creating a concrete sub-class.
But the keyword <code>final</code> forbids creating such sub-classes:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">ConcreteSubClass</span> <span class="k">extends</span> <span class="nc">NoValueForThisType</span>
</span></span><span class="line"><span class="cl">                                        <span class="o">^</span>
</span></span><span class="line"><span class="cl">        <span class="n">error</span><span class="k">:</span> <span class="kt">illegal</span> <span class="kt">inheritance</span> <span class="kt">from</span> <span class="kt">final</span> <span class="kt">class</span> <span class="kt">NoValueForThisType</span></span></span></code></pre></div>
<p>There is no way to create an instance of <code>NoValueForThisType</code>.</p>
  </details>
</li>
</ul>
<p>Let&rsquo;s take another example:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">ExactlyOneValue</span>
</span></span><span class="line"><span class="cl"><span class="k">case</span> <span class="k">object</span> <span class="nc">TheOnlyValue</span> <span class="k">extends</span> <span class="nc">ExactlyOneValue</span></span></span></code></pre></div>
<ul>
<li>
<p><strong>Question 2:</strong> Give a value belonging to the type <code>ExactlyOneValue</code>?</p>
  <details>
    <summary><em>Solution (click to expand)</em></summary>
<p>By definition, <code>TheOnlyValue</code> is a value of type <code>ExactlyOneValue</code>.</p>
  </details>
</li>
<li>
<p><strong>Question 3:</strong> How many values belong to <code>ExactlyOneValue</code>?</p>
  <details>
    <summary><em>Solution (click to expand)</em></summary>
<p>Just like above, <code>ExactlyOneValue</code>, being a <code>trait</code>, is <em>abstract</em>. Being <code>sealed</code>,
extending it outside of its defining file is forbidden.
So <code>TheOnlyValue</code> is the only value of type <code>ExactlyOneValue</code>.</p>
  </details>
</li>
</ul>
<h2 id="first-contact">First Contact</h2>
<p>This part presents the core ideas. There are actually
only two ideas! What you will find here are stripped down
examples to illustrate each of these ideas.</p>
<h3 id="use-case-evidence-of-some-property">Use Case: Evidence of some property</h3>
<p>Let&rsquo;s define a simple <em>sealed trait</em>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">ATrait</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">case</span> <span class="k">object</span> <span class="nc">AValue</span> <span class="k">extends</span> <span class="nc">ATrait</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span></span></span></code></pre></div>
<ul>
<li>
<p><strong>Question 1:</strong> Give a value of type <code>ATrait[Char]</code>.</p>
  <details>
    <summary><em>Solution (click to expand)</em></summary>
<p>By definition, <code>AValue</code> is a value of type <code>ATrait[Char]</code>.</p>
  </details>
</li>
<li>
<p><strong>Question 2:</strong> Give a value of type <code>ATrait[Double]</code>.</p>
  <details>
    <summary><em>Solution (click to expand)</em></summary>
<p>There is no way to have an instance of type <code>ATrait[Double]</code>.
There is actually no way to have an instance of type <code>ATrait[B]</code> for <code>B ≠ Char</code>,
because the only possible value is <code>AValue</code> which is of type <code>ATrait[Char]</code>.</p>
  </details>
</li>
<li>
<p><strong>Question 3:</strong> What can you conclude about a type <code>A</code> if you have a value
<code>ev</code> of type <code>ATrait[A]</code> (i.e. <code>ev: ATrait[A]</code>)?</p>
  <details>
    <summary><em>Solution (click to expand)</em></summary>
<p>The only possible value is <code>AValue</code>, so <code>ev == AValue</code>.
Furthermore <code>AValue</code> is of type <code>ATrait[Char]</code> so <code>A = Char</code>.</p>
  </details>
</li>
<li>
<p><strong>Question 4:</strong> In the <em>REPL</em>, enter the following code:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">f</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">ATrait</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Char</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">x</span></span></span></code></pre></div>
</li>
<li>
<p><strong>Question 5:</strong> Now try pattern matching on <code>ev: ATrait[A]</code></p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">f</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">ATrait</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Char</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">ev</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">AValue</span> <span class="k">=&gt;</span> <span class="n">x</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
<p>Is the pattern matching exhaustive?</p>
  <details>
    <summary><em>Solution (click to expand)</em></summary>
<p>The pattern matching is exhaustive because the only possible actual
value for <code>ev</code> is <code>AValue</code>. Furthermore <code>AValue</code> is of type <code>ATrait[Char]</code>
which means <code>ev : ATrait[Char]</code> because <code>ev == AValue</code>. So <code>A = Char</code> and <code>x : Char</code>.</p>
  </details>
</li>
<li>
<p><strong>Question 6:</strong> Call <code>f</code> with <code>x = 'w' : Char</code>.</p>
  <details>
    <summary><em>Solution (click to expand)</em></summary>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">[</span><span class="kt">Char</span><span class="o">](</span><span class="sc">&#39;w&#39;</span><span class="o">,</span> <span class="nc">AValue</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="n">res0</span><span class="k">:</span> <span class="kt">Char</span> <span class="o">=</span> <span class="n">w</span></span></span></code></pre></div>
  </details>
</li>
<li>
<p><strong>Question 7:</strong> Call <code>f</code> with <code>x =  5.2 : Double</code>.</p>
  <details>
    <summary><em>Solution (click to expand)</em></summary>
<p>This is impossible because it would require to give a value
<code>ev : ATrait[Double]</code>, which does not exist!</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">[</span><span class="kt">Double</span><span class="o">](</span><span class="mi">5</span><span class="o">,</span> <span class="nc">AValue</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">                    <span class="o">^</span>
</span></span><span class="line"><span class="cl">          <span class="n">error</span><span class="k">:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">found</span>   <span class="k">:</span> <span class="kt">AValue.type</span>
</span></span><span class="line"><span class="cl">            <span class="n">required</span><span class="k">:</span> <span class="kt">ATrait</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span></span></span></code></pre></div>
  </details>
</li>
</ul>
<details>
  <summary><strong>Remark for people fluent in <em>Scala</em></strong> <em>(click to expand)</em></summary>
<p>Using all the nice features of <em>Scala</em>, the production-ready version of the code above is:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">IsChar</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">object</span> <span class="nc">IsChar</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">implicit</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">Evidence</span> <span class="k">extends</span> <span class="nc">IsChar</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">implicit</span> <span class="n">evidence</span><span class="k">:</span> <span class="kt">IsChar</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">IsChar</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="n">evidence</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">f</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">IsChar</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Char</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="nc">IsChar</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">IsChar</span><span class="o">.</span><span class="nc">Evidence</span> <span class="k">=&gt;</span> <span class="n">x</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
</details>
<h3 id="use-case-the-only-thing-i-know-is-it-exists">Use Case: The only thing I know is it exists</h3>
<p>What would you do if you wanted your codebase to log messages, but you want to be sure your
codebase do not rely on any implementation details of the logger, so that you can change its
implementation without risking breaking the codebase?</p>
<p>Take the following logger type <code>UnknownLogger</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">UnknownLogger</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">LogWith</span><span class="o">[</span><span class="kt">X</span><span class="o">](</span><span class="n">logs</span> <span class="k">:</span> <span class="kt">X</span><span class="o">,</span> <span class="n">appendMessage</span><span class="k">:</span> <span class="o">(</span><span class="kt">X</span><span class="o">,</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">X</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">UnknownLogger</span></span></span></code></pre></div>
<p>The first logger we will create stores the logs in a <code>String</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">loggerStr</span> <span class="k">:</span> <span class="kt">UnknownLogger</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="nc">LogWith</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">&#34;&#34;</span><span class="o">,</span> <span class="o">(</span><span class="n">logs</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">message</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">logs</span> <span class="o">++</span> <span class="n">message</span><span class="o">)</span></span></span></code></pre></div>
<p>The second logger stores them in a <code>List[String]</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">loggerList</span> <span class="k">:</span> <span class="kt">UnknownLogger</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="nc">LogWith</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]](</span><span class="nc">Nil</span><span class="o">,</span> <span class="o">(</span><span class="n">logs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span> <span class="n">message</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">message</span> <span class="k">:</span><span class="kt">:</span> <span class="kt">logs</span><span class="o">)</span></span></span></code></pre></div>
<p>The third logger directly prints the messages to the standard output:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">loggerStdout</span> <span class="k">:</span> <span class="kt">UnknownLogger</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="nc">LogWith</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]((),</span> <span class="o">(</span><span class="n">logs</span><span class="k">:</span> <span class="kt">Unit</span><span class="o">,</span> <span class="n">message</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">message</span><span class="o">))</span></span></span></code></pre></div>
<p>Note that these three loggers all have the same type (i.e. <code>UnknownLogger</code>) but they store
the logs using different types <code>X</code> (<code>String</code>, <code>List[String]</code> and <code>Unit</code>).</p>
<ul>
<li>
<p><strong>Question 1:</strong> Let <code>v</code> be a value of type <code>UnknownLogger</code>.
Clearly <code>v</code> has to be an instance of the class <code>LogWith[X]</code> for some type <code>X</code>.
What can you say about the type <code>X</code>? Can you figure out which type <code>X</code> actually is?</p>
<p><strong>Remember that we refuse to use runtime-reflection!</strong> (i.e. <code>isInstanceOf</code>, <code>getClass</code>, etc)</p>
  <details>
    <summary><em>Solution (click to expand)</em></summary>
<p>We know almost nothing about <code>X</code>. The only thing we know is there exists at least
one value (<code>v.logs</code>) of type <code>X</code>. Appart from that, <code>X</code> can be any type.</p>
<p>Not knowing which type is actually <code>X</code> is very useful to guarantee that the code that will
use <code>v : UnknownLogger</code> will never rely on the nature of <code>X</code>. If the code knew <code>X</code> was
<code>String</code> for example, it could perform some operations we want to forbid like reversing
the list, taking only the <em>nth</em> first characters, etc. By hiding the real type <code>X</code>, we force
our codebase to not depend on what <code>X</code> is but to use the provided <code>v.appendMessage</code>.
So changing the real implementation of the logger won&rsquo;t break any code.</p>
  </details>
</li>
<li>
<p><strong>Question 2:</strong> Write the function <code>def log(message: String, v: UnknownLogger): UnknownLogger</code>
that uses <code>v.appendMessage</code> to append <code>message</code> to <code>v.logs</code>
and returns a new <code>UnknownLogger</code> containing the new logs.</p>
<p>Remember that in <em>Scala</em>, the pattern <code>case ac : AClass[t] =&gt;</code> (see below)
is allowed in <code>match/case</code> in replacement of the pattern <code>case AClass(v) =&gt;</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">AClass</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">value</span> <span class="k">:</span> <span class="kt">A</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">f</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">v</span><span class="k">:</span> <span class="kt">AClass</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">v</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="n">ac</span> <span class="k">:</span> <span class="kt">AClass</span><span class="o">[</span><span class="kt">t</span><span class="o">]</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// The variable `t` is a type variable
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// The type `t` is equal to `A`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">val</span> <span class="n">r</span> <span class="k">:</span> <span class="kt">t</span> <span class="o">=</span> <span class="n">ac</span><span class="o">.</span><span class="n">value</span>
</span></span><span class="line"><span class="cl">      <span class="n">r</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
<p>Its main benefit is introducing the type variable <code>t</code>.
Type variables work like normal pattern variables except that they represent types
instead of values. Having <code>t</code> enable us to help the compiler by giving explicit types
(like just above, saying <code>r</code> is of type <code>t</code>).</p>
  <details>
    <summary><em>Solution (click to expand)</em></summary>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">log</span><span class="o">(</span><span class="n">message</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">v</span><span class="k">:</span> <span class="kt">UnknownLogger</span><span class="o">)</span><span class="k">:</span> <span class="kt">UnknownLogger</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">v</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="n">vx</span> <span class="k">:</span> <span class="kt">LogWith</span><span class="o">[</span><span class="kt">x</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">LogWith</span><span class="o">[</span><span class="kt">x</span><span class="o">](</span><span class="n">vx</span><span class="o">.</span><span class="n">appendMessage</span><span class="o">(</span><span class="n">vx</span><span class="o">.</span><span class="n">logs</span><span class="o">,</span> <span class="n">message</span><span class="o">),</span> <span class="n">vx</span><span class="o">.</span><span class="n">appendMessage</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
  </details>
</li>
<li>
<p><strong>Question 3:</strong> Execute <code>log(&quot;Hello World&quot;, loggerStr)</code> and <code>log(&quot;Hello World&quot;, loggerList)</code>
and <code>log(&quot;Hello World&quot;, loggerStdout)</code></p>
  <details>
    <summary><em>Solution (click to expand)</em></summary>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">log</span><span class="o">(</span><span class="s">&#34;Hello World&#34;</span><span class="o">,</span> <span class="n">loggerStr</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="n">res0</span><span class="k">:</span> <span class="kt">UnknownLogger</span> <span class="o">=</span> <span class="nc">LogWith</span><span class="o">(</span><span class="nc">Hello</span> <span class="nc">World</span><span class="o">,</span><span class="nc">$$Lambda$988</span><span class="o">/</span><span class="mi">1455466014</span><span class="k">@</span><span class="mi">421</span><span class="n">ead7e</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">log</span><span class="o">(</span><span class="s">&#34;Hello World&#34;</span><span class="o">,</span> <span class="n">loggerList</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="n">res1</span><span class="k">:</span> <span class="kt">UnknownLogger</span> <span class="o">=</span> <span class="nc">LogWith</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="nc">Hello</span> <span class="nc">World</span><span class="o">),</span><span class="nc">$$Lambda$989</span><span class="o">/</span><span class="mi">1705282731</span><span class="k">@</span><span class="mi">655621</span><span class="n">fd</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">log</span><span class="o">(</span><span class="s">&#34;Hello World&#34;</span><span class="o">,</span> <span class="n">loggerStdout</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="nc">Hello</span> <span class="nc">World</span>
</span></span><span class="line"><span class="cl"><span class="n">res2</span><span class="k">:</span> <span class="kt">UnknownLogger</span> <span class="o">=</span> <span class="nc">LogWith</span><span class="o">((),</span><span class="nc">$$Lambda$990</span><span class="o">/</span><span class="mi">1835105031</span><span class="k">@</span><span class="mi">340</span><span class="n">c57e0</span><span class="o">)</span></span></span></code></pre></div>
  </details>
</li>
</ul>
<details>
  <summary><strong>Remark for people fluent in <em>Scala</em></strong> <em>(click to expand)</em></summary>
<p>Once again, using all the nice features of <em>Scala</em>,
the production-ready version of the code above is:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">UnknownLogger</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">type</span> <span class="kt">LogsType</span>
</span></span><span class="line"><span class="cl">  <span class="k">val</span> <span class="n">logs</span> <span class="k">:</span> <span class="kt">LogsType</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">appendMessage</span><span class="o">(</span><span class="n">presentLogs</span><span class="k">:</span> <span class="kt">LogsType</span><span class="o">,</span> <span class="n">message</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">LogsType</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">object</span> <span class="nc">UnknownLogger</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">LogWith</span><span class="o">[</span><span class="kt">X</span><span class="o">](</span><span class="n">logs</span> <span class="k">:</span> <span class="kt">X</span><span class="o">,</span> <span class="n">appendMessage_</span> <span class="k">:</span> <span class="o">(</span><span class="kt">X</span><span class="o">,</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">X</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">UnknownLogger</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">type</span> <span class="kt">LogsType</span> <span class="o">=</span> <span class="n">X</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="n">appendMessage</span><span class="o">(</span><span class="n">presentLogs</span><span class="k">:</span> <span class="kt">LogsType</span><span class="o">,</span> <span class="n">message</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">LogsType</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">appendMessage_</span><span class="o">(</span><span class="n">presentLogs</span><span class="o">,</span> <span class="n">message</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">X</span><span class="o">](</span><span class="n">logs</span><span class="k">:</span> <span class="kt">X</span><span class="o">,</span> <span class="n">appendMessage</span><span class="k">:</span> <span class="o">(</span><span class="kt">X</span><span class="o">,</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">X</span><span class="o">)</span><span class="k">:</span> <span class="kt">UnknownLogger</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="nc">LogWith</span><span class="o">[</span><span class="kt">X</span><span class="o">](</span><span class="n">logs</span><span class="o">,</span> <span class="n">appendMessage</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
</details>
<h3 id="intermediary-conclusion">Intermediary Conclusion</h3>
<p><em>GADTs</em> are actually only this: simple <em>sealed trait</em> with some
<em>case object</em> (possibly none) and some <em>final case class</em> (possible none too!).
In the following parts we will explore some major use cases of <em>GADTs</em></p>
<h2 id="easy-useful-use-cases-relations-on-types">Easy Useful Use Cases: Relations on Types</h2>
<p>One easy, but very useful, benefit of <em>GADTs</em> is expressing relations about types such that:</p>
<ul>
<li>Is type <code>A</code> equal to type <code>B</code>?</li>
<li>Is type <code>A</code> a sub-type of <code>B</code>?</li>
</ul>
<p>Note that, by definition, a type <code>A</code> is a sub-type of itself (i.e. <code>A &lt;: A</code>),
very much like an integer <code>x</code> is also lesser-than-or-equal to itself <code>x ≤ x</code>.</p>
<h3 id="use-case-witnessing-type-equality">Use Case: Witnessing Type Equality</h3>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">EqT</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Evidence</span><span class="o">[</span><span class="kt">X</span><span class="o">]()</span> <span class="k">extends</span> <span class="nc">EqT</span><span class="o">[</span><span class="kt">X</span>,<span class="kt">X</span><span class="o">]</span></span></span></code></pre></div>
<ul>
<li>
<p><strong>Question 1:</strong> Give a value of type <code>EqT[Int, Int]</code></p>
  <details>
    <summary><em>Solution (click to expand)</em></summary>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Evidence</span><span class="o">[</span><span class="kt">Int</span><span class="o">]()</span> <span class="k">:</span> <span class="kt">EqT</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="n">res0</span><span class="k">:</span> <span class="kt">EqT</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Evidence</span><span class="o">()</span></span></span></code></pre></div>
  </details>
</li>
<li>
<p><strong>Question 2:</strong> Give a value of type <code>EqT[String, Int]</code></p>
  <details>
    <summary><em>Solution (click to expand)</em></summary>
<p>The class <code>Evidence</code> is the only concrete sub-class of trait <code>EqT</code> and we cannot
create another one because <code>EqT</code> is <code>sealed</code>. So any value <code>v : EqT[A,B]</code> has to be
an instance of <code>Evidence[X]</code> for some type <code>X</code>, which is of type <code>EqT[X,X]</code>.
Thus there is no way to get a value of type <code>EqT[String, Int]</code>.</p>
  </details>
</li>
<li>
<p><strong>Question 3:</strong> Given two (unknown) types <code>A</code> and <code>B</code>.
What can you conclude if I give you a value of type <code>EqT[A,B]</code>?</p>
  <details>
    <summary><em>Solution (click to expand)</em></summary>
<p>If I give you a value <code>v : EqT[A,B]</code>, then you know that <code>v</code> is an instance of
<code>Evidence[X]</code> for some (unknown) type <code>X</code> because the class <code>Evidence</code> is the only concrete
sub-class of the sealed trait <code>EqT</code>. Actually <code>Evidence[X]</code> is a sub-type of
<code>EqT[X,X]</code>. Thus <code>v : EqT[X,X]</code>. Types <code>EqT[A,B]</code> and <code>EqT[X,X]</code> have no value in
common if <code>A ≠ X</code> or <code>B ≠ X</code>, so <code>A = X</code> and <code>B = X</code>. Thus <code>A = B</code>.</p>
  </details>
</li>
</ul>
<details>
  <summary><strong>Remark for people fluent in <em>Scala</em></strong> <em>(click to expand)</em></summary>
<p>In production, it is convenient to write the following equivalent code:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">EqT</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">object</span> <span class="nc">EqT</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Evidence</span><span class="o">[</span><span class="kt">X</span><span class="o">]()</span> <span class="k">extends</span> <span class="nc">EqT</span><span class="o">[</span><span class="kt">X</span>,<span class="kt">X</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">implicit</span> <span class="k">def</span> <span class="n">evidence</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span> <span class="k">:</span> <span class="kt">EqT</span><span class="o">[</span><span class="kt">X</span>,<span class="kt">X</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Evidence</span><span class="o">[</span><span class="kt">X</span><span class="o">]()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">EqT</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">ev.</span><span class="k">type</span> <span class="o">=</span> <span class="n">ev</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
</details>
<h4 id="switching-between-equal-types">Switching between equal types</h4>
<p>If <code>A</code> and <code>B</code> are actually the same type, then <code>List[A]</code> is also the
same type as <code>List[B]</code>, <code>Option[A]</code> is also the same type as <code>Option[B]</code>,
etc. More generally, for any <code>F[_]</code>, <code>F[A]</code> is also the same type as <code>F[B]</code>.</p>
<ul>
<li>
<p><strong>Question 4:</strong> Write the function <code>def coerce[F[_],A,B](eqT: EqT[A,B])(fa: F[A]): F[B]</code>.</p>
  <details>
    <summary><em>Solution (click to expand)</em></summary>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">coerce</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">eqT</span><span class="k">:</span> <span class="kt">EqT</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">])(</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">eqT</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="k">_</span> <span class="k">:</span> <span class="kt">Evidence</span><span class="o">[</span><span class="kt">x</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">fa</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
  </details>
</li>
</ul>
<p>The <em>Scala</em> standard library already defines a class, named <code>=:=[A,B]</code>
(yes, its name is really <code>=:=</code>), representing type equality.
You&rsquo;re strongly encouraged to have a quick look
<a href="https://www.scala-lang.org/api/current/scala/$eq$colon$eq.html" rel="external" target="_self">at its documentation (click here)</a>.
Thankfully, <em>Scala</em> enables to write <code>A =:= B</code> instead of <code>=:=[A,B]</code>.</p>
<p>Given two types <code>A</code> and <code>B</code>, having an instance (i.e. object)
of <code>A =:= B</code> means that <code>A</code> and <code>B</code> are actually the same type,
just like with <code>EqT[A,B]</code>.
Remember that <code>A =:= B</code> is just syntactic sugar for <code>=:=[A,B]</code>.</p>
<p>Instances of <code>A =:= B</code> can be created by the function
<a href="https://www.scala-lang.org/api/current/scala/$less$colon$less$.html#refl[A]:A=:=A" rel="external" target="_self"><code>(&lt;:&lt;).refl[X]: X =:= X</code>
(click for docs)</a>.
The &ldquo;symbol&rdquo; <code>&lt;:&lt;</code> is indeed a valid name for an object.</p>
<ul>
<li>
<p><strong>Question 5:</strong> Using the function <code>coerce</code> above,
write the function <code>def toScalaEq[A,B](eqT: EqT[A,B]): A =:= B</code>.</p>
  <details>
    <summary><em>Hint (click to expand)</em></summary>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">toScalaEq</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">eqT</span><span class="k">:</span> <span class="kt">EqT</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span><span class="k">:</span><span class="o">=</span> <span class="n">B</span> <span class="k">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* Find a definition for:
</span></span></span><span class="line"><span class="cl"><span class="cm">        - the type constructor `F`
</span></span></span><span class="line"><span class="cl"><span class="cm">        - the value `fa : F[A]`
</span></span></span><span class="line"><span class="cl"><span class="cm">  */</span>
</span></span><span class="line"><span class="cl">  <span class="k">type</span> <span class="kt">F</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</span></span><span class="line"><span class="cl">  <span class="k">val</span> <span class="n">fa</span> <span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Such that this call: */</span>
</span></span><span class="line"><span class="cl">  <span class="n">coerce</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">eqT</span><span class="o">)(</span><span class="n">fa</span><span class="o">)</span> <span class="c1">// is of type `F[B]`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}</span></span></span></code></pre></div>
  </details>
  <details>
    <summary><em>Solution (click to expand)</em></summary>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">toScalaEq</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">eqT</span><span class="k">:</span> <span class="kt">EqT</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span><span class="k">:</span><span class="o">=</span> <span class="n">B</span> <span class="k">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">type</span> <span class="kt">F</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span> <span class="k">=</span> <span class="n">A</span> <span class="o">=:=</span> <span class="n">X</span>
</span></span><span class="line"><span class="cl">  <span class="k">val</span> <span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">(&lt;:&lt;).</span><span class="n">refl</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">  <span class="n">coerce</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">eqT</span><span class="o">)(</span><span class="n">fa</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
  </details>
</li>
<li>
<p><strong>Question 6:</strong> Using the <em>method</em> <code>substituteCo[F[_]](ff: F[A]): F[B]</code> of
objects of class <code>A =:= B</code>, whose
<a href="https://www.scala-lang.org/api/current/scala/$eq$colon$eq.html#substituteCo[F[_]](ff:F[From]):F[To]" rel="external" target="_self">documentation is here</a>,
write the function <code>def fromScalaEq[A,B](scala: A =:= B): EqT[A,B]</code>.</p>
  <details>
    <summary><em>Hint (click to expand)</em></summary>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">fromScalaEq</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">scala</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span><span class="k">:</span><span class="o">=</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">EqT</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* Find a definition for:
</span></span></span><span class="line"><span class="cl"><span class="cm">        - the type constructor `F`
</span></span></span><span class="line"><span class="cl"><span class="cm">        - the value `fa : F[A]`
</span></span></span><span class="line"><span class="cl"><span class="cm">  */</span>
</span></span><span class="line"><span class="cl">  <span class="k">type</span> <span class="kt">F</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</span></span><span class="line"><span class="cl">  <span class="k">val</span> <span class="n">fa</span> <span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Such that this call: */</span>
</span></span><span class="line"><span class="cl">  <span class="n">scala</span><span class="o">.</span><span class="n">substituteCo</span><span class="o">[</span><span class="kt">F</span><span class="o">](</span><span class="n">fa</span><span class="o">)</span> <span class="c1">// is of type `F[B]`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}</span></span></span></code></pre></div>
  </details>
  <details>
    <summary><em>Solution (click to expand)</em></summary>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">fromScalaEq</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">scala</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span><span class="k">:</span><span class="o">=</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">EqT</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">type</span> <span class="kt">F</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span> <span class="k">=</span> <span class="nc">EqT</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">X</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">  <span class="k">val</span> <span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Evidence</span><span class="o">[</span><span class="kt">A</span><span class="o">]()</span>
</span></span><span class="line"><span class="cl">  <span class="n">scala</span><span class="o">.</span><span class="n">substituteCo</span><span class="o">[</span><span class="kt">F</span><span class="o">](</span><span class="n">fa</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
  </details>
</li>
</ul>
<h3 id="use-case-witnessing-sub-typing">Use Case: Witnessing Sub Typing</h3>
<p>In this section, we want to create types <code>SubTypeOf[A,B]</code> whose values prove
that the type <code>A</code> is a sub-type of <code>B</code> (i.e. <code>A &lt;: B</code>).
A similar <em>but different</em> class already exists in the <em>Scala</em> library.
It is named <code>&lt;:&lt;[A,B]</code>, which is often written <code>A &lt;:&lt; B</code>. Its
<a href="https://www.scala-lang.org/api/current/scala/$less$colon$less.html" rel="external" target="_self">documentation is here</a>.
Because this section is about implementing a variant of this class,
please <strong>do not use</strong> <code>&lt;:&lt;[A,B]</code> to implement <code>SubTypeOf</code>.</p>
<ul>
<li>
<p><strong>Question 1:</strong> Using only <em>upper bounds</em> (i.e. <code>A &lt;: B</code>) or <em>lower bounds</em> (i.e. <code>A &gt;: B</code>)
and <strong>no</strong> <em>variance annotation</em> (i.e. <code>[+A]</code> and <code>[-A]</code>),
create the trait <code>SubTypeOf[A,B]</code> (and all that is necessary) such that:</p>
<blockquote>
<p>There exists a value of type <code>SubType[A,B]</code> <strong>if and only if</strong>
<code>A</code> is a sub-type of <code>B</code> (i.e. <code>A &lt;: B</code>).</p>
</blockquote>
<p>Remember that, by definition, a type <code>A</code> is a sub-type of itself (i.e. <code>A &lt;: A</code>).</p>
<p>Remember that you should not use the <code>class &lt;:&lt;[A,B]</code>.</p>
  <details>
    <summary><em>Solution (click to expand)</em></summary>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">SubTypeOf</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">SubTypeEvidence</span><span class="o">[</span><span class="kt">A</span> <span class="k">&lt;:</span> <span class="kt">B</span>, <span class="kt">B</span><span class="o">]()</span> <span class="k">extends</span> <span class="nc">SubTypeOf</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span></span></span></code></pre></div>
  <details>
    <summary><strong>Remark for people fluent in <em>Scala</em></strong> <em>(click to expand)</em></summary>
<p>In production, it is convenient to write the following equivalent code:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">SubTypeOf</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">object</span> <span class="nc">SubTypeOf</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Evidence</span><span class="o">[</span><span class="kt">A</span> <span class="k">&lt;:</span> <span class="kt">B</span>, <span class="kt">B</span><span class="o">]()</span> <span class="k">extends</span> <span class="nc">SubTypeOf</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">implicit</span> <span class="k">def</span> <span class="n">evidence</span><span class="o">[</span><span class="kt">A</span> <span class="k">&lt;:</span> <span class="kt">B</span>, <span class="kt">B</span><span class="o">]</span><span class="k">:</span> <span class="kt">SubTypeOf</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Evidence</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">SubTypeOf</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">ev.</span><span class="k">type</span> <span class="o">=</span> <span class="n">ev</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
  </details>
  </details>
</li>
</ul>
<h3 id="use-case-avoiding-annoying-scalac-error-messages-about-bounds-not-respected">Use Case: Avoiding annoying <em>scalac</em> error messages about bounds not respected</h3>
<p>In this example, we want to model the diet of some animals.
We start by defining the <code>Food</code> type and some of its subtypes:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">trait</span> <span class="nc">Food</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Vegetable</span> <span class="k">extends</span> <span class="nc">Food</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Fruit</span> <span class="k">extends</span> <span class="nc">Food</span></span></span></code></pre></div>
<p>and then the class representing animals eating food of type <code>A</code>
(i.e. <code>Vegetable</code>, <code>Fruit</code>, etc):</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">AnimalEating</span><span class="o">[</span><span class="kt">A</span> <span class="k">&lt;:</span> <span class="kt">Food</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nc">val</span> <span class="n">elephant</span> <span class="k">:</span> <span class="kt">AnimalEating</span><span class="o">[</span><span class="kt">Vegetable</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="k">new</span> <span class="nc">AnimalEating</span><span class="o">[</span><span class="kt">Vegetable</span><span class="o">]</span></span></span></code></pre></div>
<p>Let&rsquo;s define a function like there are so many in
<em>Functional Programming</em>, and apply it to <code>elephant</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">dummy</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">&#34;Ok!&#34;</span></span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">dummy</span><span class="o">[</span><span class="kt">List</span>, <span class="kt">Int</span><span class="o">](</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">))</span>
</span></span><span class="line"><span class="cl"><span class="n">res0</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">Ok</span><span class="o">!</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">dummy</span><span class="o">[</span><span class="kt">Option</span>, <span class="kt">Boolean</span><span class="o">](</span><span class="nc">Some</span><span class="o">(</span><span class="kc">true</span><span class="o">))</span>
</span></span><span class="line"><span class="cl"><span class="n">res1</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">Ok</span><span class="o">!</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">dummy</span><span class="o">[</span><span class="kt">AnimalEating</span>, <span class="kt">Vegetable</span><span class="o">](</span><span class="n">elephant</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">            <span class="o">^</span>
</span></span><span class="line"><span class="cl">       <span class="n">error</span><span class="k">:</span> <span class="kt">kinds</span> <span class="kt">of</span> <span class="kt">the</span> <span class="k">type</span> <span class="kt">arguments</span> <span class="o">(</span><span class="kt">AnimalEating</span><span class="o">,</span><span class="kt">Vegetable</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">       <span class="k">do</span> <span class="n">not</span> <span class="n">conform</span> <span class="n">to</span> <span class="n">the</span> <span class="n">expected</span> <span class="n">kinds</span> <span class="n">of</span> <span class="n">the</span> <span class="k">type</span> <span class="kt">parameters</span> <span class="o">(</span><span class="k">type</span> <span class="kt">F</span><span class="o">,</span><span class="k">type</span> <span class="kt">A</span><span class="o">).</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">       <span class="nc">AnimalEating</span>&#39;s <span class="k">type</span> <span class="kt">parameters</span> <span class="kt">do</span> <span class="kt">not</span> <span class="kt">match</span> <span class="k">type</span> <span class="kt">F</span><span class="err">&#39;</span><span class="kt">s</span> <span class="kt">expected</span> <span class="kt">parameters:</span>
</span></span><span class="line"><span class="cl">       <span class="k">type</span> <span class="kt">A</span><span class="err">&#39;</span><span class="kt">s</span> <span class="kt">bounds</span> <span class="k">&lt;:</span> <span class="kt">Food</span> <span class="kt">are</span> <span class="kt">stricter</span> <span class="kt">than</span>
</span></span><span class="line"><span class="cl">       <span class="k">type</span> <span class="k">_</span><span class="err">&#39;</span><span class="kt">s</span> <span class="kt">declared</span> <span class="kt">bounds</span> <span class="k">&gt;:</span> <span class="kt">Nothing</span> <span class="k">&lt;:</span> <span class="kt">Any</span></span></span></code></pre></div>
<ul>
<li>
<p><strong>Question 1:</strong> Why does <em>scalac</em> complains?</p>
  <details>
    <summary><em>Solution (click to expand)</em></summary>
<p>The function <code>dummy</code> requires its argument <code>F</code>, which is a type constructor
like <code>List</code>, <code>Option</code>, <code>Future</code>, etc,  to accept any type
as argument so that we can write <code>F[A]</code> for any type <code>A</code>. On the contrary,
<code>AnimalEating</code> requires its argument to be a sub-type of <code>Food</code>.
Thus <code>AnimalEating</code> can not be used as <code>dummy</code>&rsquo;s argument <code>F</code>.</p>
  </details>
</li>
</ul>
<p>The problem is that, when we defined <code>class AnimalEating[A &lt;: Food]</code>,
we gave the restriction that <code>A &lt;: Food</code>. So <em>Scala</em>, like <em>Java</em>,
forbids us to give <code>AnimalEating</code> anything but a sub-type of <code>Food</code>
(including <code>Food</code> itself):</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="k">type</span> <span class="kt">T1</span> <span class="o">=</span> <span class="nc">AnimalEating</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">                 <span class="o">^</span>
</span></span><span class="line"><span class="cl">       <span class="n">error</span><span class="k">:</span> <span class="k">type</span> <span class="kt">arguments</span> <span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">do</span> <span class="n">not</span> <span class="n">conform</span>
</span></span><span class="line"><span class="cl">       <span class="n">to</span> <span class="k">class</span> <span class="nc">AnimalEating</span>&#39;s <span class="k">type</span> <span class="kt">parameter</span> <span class="kt">bounds</span> <span class="o">[</span><span class="kt">A</span> <span class="k">&lt;:</span> <span class="kt">Food</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="k">type</span> <span class="kt">T2</span> <span class="o">=</span> <span class="nc">AnimalEating</span><span class="o">[</span><span class="kt">Food</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="n">defined</span> <span class="k">type</span> <span class="kt">alias</span> <span class="kt">T2</span></span></span></code></pre></div>
<p>We face a dilemma: to use the function <code>dummy</code>, that we really want
to use because it&rsquo;s a very nice function, we need to remove the
constraint <code>A &lt;: Food</code> from the definition <code>class AnimalEating[A &lt;: Food]</code>.
But we still want to say that animals eat food, not integers,
boolean or strings!</p>
<ul>
<li>
<p><strong>Question 2:</strong> How can you adapt the definition of <code>AnimalEating</code> so that:</p>
<ul>
<li>
<p>We can call <code>dummy</code> on <code>elephant</code>! We want:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">dummy</span><span class="o">[</span><span class="kt">AnimalEating</span>, <span class="kt">Vegetable</span><span class="o">](</span><span class="n">elephant</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="n">res0</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">Ok</span><span class="o">!</span></span></span></code></pre></div>
</li>
<li>
<p><em>If</em> <code>A</code> is <strong>not a sub-type</strong> of <code>Food</code> (including <code>Food</code> itself),
<em>then</em> it is <strong>impossible</strong> to create an instance of <code>AnimalEating[A]</code>.</p>
</li>
<li>
<p>The class <code>AnimalEating</code> <strong>must</strong> remain an open class
(i.e. neither sealed nor final)! It should be possible for anyone, anywhen,
to create, freely, sub-classes of <code>AnimalEating</code>. Obviously those
sub-classes must satisfy the constraints above.</p>
<details>
  <summary><em>Hint (click to expand)</em></summary>
<p>In <em>Scala</em>, <code>Nothing</code> is a type having no value.
Can you create a value of type <code>(Nothing, Int)</code>? Why?</p>
</details>
<details>
  <summary><em>Solution (click to expand)</em></summary>
<p>If, to create an instance of <code>AnimalEating[A]</code>, we force <strong>every</strong>
creation method to take an extra paramerer of type <code>SubTypeOf[A, Food]</code>,
then it will only be possible to create an instance of <code>AnimalEating[A]</code>
when <code>A</code> is a sub-type of <code>Food</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">AnimalEating</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">ev</span> <span class="k">:</span> <span class="kt">SubTypeOf</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">Food</span><span class="o">])</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">elephant</span> <span class="k">:</span> <span class="kt">AnimalEating</span><span class="o">[</span><span class="kt">Vegetable</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="k">new</span> <span class="nc">AnimalEating</span><span class="o">[</span><span class="kt">Vegetable</span><span class="o">](</span><span class="nc">SubTypeEvidence</span><span class="o">[</span><span class="kt">Vegetable</span>, <span class="kt">Food</span><span class="o">])</span></span></span></code></pre></div>
<p>To create a value of type <code>AnimalEating[A]</code>, we need to call
<code>AnimalEating</code>&rsquo;s constructor. And to call this constructor,
we need to provide <code>ev : SubTypeOf[A, Food]</code>.</p>
<p>Now we can apply the <code>dummy</code> function on <code>elephant</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">dummy</span><span class="o">[</span><span class="kt">AnimalEating</span>, <span class="kt">Vegetable</span><span class="o">](</span><span class="n">elephant</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="n">res0</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">Ok</span><span class="o">!</span></span></span></code></pre></div>
<p>In practice, using implicits, we let the compiler
fill the parameter <code>ev : SubTypeOf[A, Food]</code> itself.</p>
<p>Note that you can now express the type <code>AnimalEating[Int]</code>
but you won&rsquo;t be able to create a value of this type.</p>
</details>
</li>
</ul>
</li>
</ul>
<h3 id="use-case-give-the-right-data-to-the-right-chart">Use Case: Give the right data to the right chart</h3>
<p>This use case is about enforcing at compile-time that only values
of the right type can be given to a function. In this example, we
consider the design of a chart library. For simplicity&rsquo;s sake, we will
assume that our library only supports two kinds of charts:
<a href="https://www.google.com/search?q=pie+chart&tbm=isch" rel="external" target="_self">Pie charts</a>
and
<a href="https://www.google.com/search?q=xy+charts&tbm=isch" rel="external" target="_self">XY charts</a>.
This is written in <em>Scala</em> via the enumeration:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">ChartType</span>
</span></span><span class="line"><span class="cl"><span class="k">case</span> <span class="k">object</span> <span class="nc">PieChart</span> <span class="k">extends</span> <span class="nc">ChartType</span>
</span></span><span class="line"><span class="cl"><span class="k">case</span> <span class="k">object</span> <span class="nc">XYChart</span> <span class="k">extends</span> <span class="nc">ChartType</span></span></span></code></pre></div>
<p>Obviously <em>Pie</em> and <em>XY</em> charts rely on different kinds of data.
Once again for simplicity&rsquo;s sake, we will assume that our two
kinds of data are:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">PieData</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">XYData</span></span></span></code></pre></div>
<p>A <em>pie</em> chart (<code>PieChart</code>) plots <strong>only</strong> <code>PieData</code>,
whereas an <em>XY</em> chart (<code>XYChart</code>) plots <strong>only</strong> <code>XYData</code>.
Here is our drawing function <code>draw</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">draw</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">chartType</span><span class="k">:</span> <span class="kt">ChartType</span><span class="o">)(</span><span class="n">data</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">chartType</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">PieChart</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">pieData</span> <span class="k">=</span> <span class="n">data</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">PieData</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Do some stuff to draw pieData
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="o">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">XYChart</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">xyData</span> <span class="k">=</span> <span class="n">data</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">XYData</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Do some stuff to draw xyData
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="o">()</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
<p>It assumes that the user will only call <code>draw</code> on the right data.
When <code>chartType</code> is <code>PieChart</code>, the function assumes, via
<code>data.asInstanceOf[PieData]</code> that <code>data</code> is actually of type <code>PieData</code>.
And when <code>chartType</code> is <code>XYChart</code>, it assumes that <code>data</code> is actually
of type <code>XYData</code>.</p>
<p>The problem is that these assumptions rely on the hypothesis that
users and developers will always make sure they are calling <code>draw</code> on
the right data type. But nothing stops someone to call <code>draw</code> on a
<code>PieChart</code> with <code>XYData</code> (or the opposite), crashing the system miserably at runtime!</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">draw</span><span class="o">(</span><span class="nc">PieChart</span><span class="o">)(</span><span class="k">new</span> <span class="nc">XYData</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">ClassCastException</span><span class="k">:</span> <span class="kt">XYData</span> <span class="kt">cannot</span> <span class="kt">be</span> <span class="kt">cast</span> <span class="kt">to</span> <span class="kt">PieData</span>
</span></span><span class="line"><span class="cl">  <span class="n">at</span> <span class="o">.</span><span class="n">draw</span><span class="o">(&lt;</span><span class="n">pastie</span><span class="k">&gt;:</span><span class="mi">11</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">...</span> <span class="mi">28</span> <span class="n">elided</span></span></span></code></pre></div>
<p>As developers, we know mistakes do happen! We want a way to prevent
theses annoying bugs to happen in production! We want to enforce at
compile-time that only these two scenarii are possible:</p>
<ul>
<li>When <code>draw</code> is called with <code>chartType == PieChart</code>:
the argument <code>data</code> can only be of type <code>PieData</code></li>
<li>When <code>draw</code> is called with <code>chartType == XYChart</code>:
the argument <code>data</code> can only be of type <code>XYData</code>.</li>
</ul>
<p>Remember that these two constraints have to be enforced at compile-time!</p>
<ul>
<li>
<p><strong>Question 1:</strong> Adapt the definition of <code>ChartType</code>, <code>PieChart</code>, <code>XYChart</code> and <code>draw</code> such that:</p>
<ul>
<li>
<p>Any scenario other than the two above will make the compilation fail
on a type error.</p>
</li>
<li>
<p><code>ChartType</code> must still be a <code>sealed trait</code>.
It is now allowed to have <em>type parameters</em> (i.e. <em>generics</em>).</p>
</li>
<li>
<p><code>PieChart</code> and <code>XYChar</code> must still be two <code>case object</code>.
They should still extends <code>ChartType</code>.</p>
</li>
<li>
<p><code>ChartType</code>, <code>PieChart</code> and <code>XYChar</code> declarations must have <em>no body</em> at all
(i.e. there should be no brackets <code>{ ... }</code> in their declaration).</p>
</li>
</ul>
  <details>
    <summary><em>Hint (click to expand)</em></summary>
<p>The code looks like this:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">ChartType</span><span class="o">[</span><span class="kt">/*PUT</span> <span class="kt">SOME</span> <span class="kt">GENERICS</span> <span class="kt">HERE*/</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">case</span> <span class="k">object</span> <span class="nc">PieChart</span> <span class="k">extends</span> <span class="nc">ChartType</span><span class="o">[</span><span class="kt">/*There</span> <span class="kt">is</span> <span class="kt">something</span> <span class="kt">to</span> <span class="kt">write</span> <span class="kt">here*/</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">case</span> <span class="k">object</span> <span class="nc">XYChart</span> <span class="k">extends</span> <span class="nc">ChartType</span><span class="o">[</span><span class="kt">/*There</span> <span class="kt">is</span> <span class="kt">something</span> <span class="kt">to</span> <span class="kt">write</span> <span class="kt">here</span> <span class="kt">too*/</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">draw</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">chartType</span><span class="k">:</span> <span class="kt">ChartType</span><span class="o">[</span><span class="kt">/*Write</span> <span class="kt">something</span> <span class="kt">here*/</span><span class="o">])(</span><span class="n">data</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl"> <span class="n">chartType</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">PieChart</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">pieData</span> <span class="k">:</span> <span class="kt">PieData</span> <span class="o">=</span> <span class="n">data</span>
</span></span><span class="line"><span class="cl">      <span class="o">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">XYChart</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">xyData</span><span class="k">:</span> <span class="kt">XYData</span> <span class="o">=</span> <span class="n">data</span>
</span></span><span class="line"><span class="cl">      <span class="o">()</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span></span></span></code></pre></div>
  </details>
  <details>
    <summary><em>Solution (click to expand)</em></summary>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">ChartType</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">case</span> <span class="k">object</span> <span class="nc">PieChart</span> <span class="k">extends</span> <span class="nc">ChartType</span><span class="o">[</span><span class="kt">PieData</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">case</span> <span class="k">object</span> <span class="nc">XYChart</span> <span class="k">extends</span> <span class="nc">ChartType</span><span class="o">[</span><span class="kt">XYData</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">draw</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">chartType</span><span class="k">:</span> <span class="kt">ChartType</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">data</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl"> <span class="n">chartType</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">PieChart</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">pieData</span> <span class="k">:</span> <span class="kt">PieData</span> <span class="o">=</span> <span class="n">data</span>
</span></span><span class="line"><span class="cl">      <span class="o">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">XYChart</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">xyData</span><span class="k">:</span> <span class="kt">XYData</span> <span class="o">=</span> <span class="n">data</span>
</span></span><span class="line"><span class="cl">      <span class="o">()</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span></span></span></code></pre></div>
  </details>
</li>
</ul>
<p>You can now sleep well knowing your production will not
crash because of some bad inputs here 😉</p>
<h2 id="more-advanced-use-cases">More Advanced Use Cases</h2>
<p>Now that you have seen what <em>GADTs</em> are about and how to use
them in real-life, you are ready for the big use cases below.
There are three of them. Each one illustrates one different way
to use the power of <em>GADTs</em>.
The <a href="../posts/gadts_by_use_cases/index.html#use-case-effects">first one</a> is about expressing effects,
which is widely used in every popular <em>IO</em> monads or algebraic effects.
Do not worry if you do not know what they are, the section will clarifies it.
The <a href="../posts/gadts_by_use_cases/index.html#use-case-ensuring-types-are-supported-by-the-database">second one</a>
is about enforcing properties. This point is illustrated
by the real-life use-case of enabling functional programming techniques
support constructions that only work for a limited set of types
(in the example, types supported by our fictional database).
The <a href="../posts/gadts_by_use_cases/index.html#use-case-simplifying-implicits">third one</a> is about simplifying
the creation of implicits.</p>
<h3 id="use-case-effects">Use Case: Effects!</h3>
<p>What we call an effect is sometimes just an interface declaring some functions with
no implementation. For example we can define the trait below. Note that <em>none</em> of its functions
has an implementation.</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">trait</span> <span class="nc">ExampleEffectSig</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">echo</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">randomInt</span> <span class="k">:</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">ignore</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p>Implementations of these interfaces are given elsewhere and there can be many of them! This
is useful to switch between implementations easily:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">object</span> <span class="nc">ExampleEffectImpl</span> <span class="k">extends</span> <span class="nc">ExampleEffectSig</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">echo</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">value</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">randomInt</span> <span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">scala</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">Random</span><span class="o">.</span><span class="n">nextInt</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">ignore</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">()</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p>Another equivalent way to define <code>ExampleEffectSig</code> is via a <code>sealed trait</code>
with some <code>final case class</code> (possibly none!) and/or some<code>case object</code> (possibly none too!):</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">ExampleEffect</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">Echo</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">ExampleEffect</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">RandomInt</span> <span class="k">extends</span> <span class="nc">ExampleEffect</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">Ignore</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">ExampleEffect</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span></span></span></code></pre></div>
<p>Once again this is a declaration with no implementation! Once again implementations
can be written elsewhere and there can also be many of them:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">runExampleEffect</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">effect</span><span class="k">:</span> <span class="kt">ExampleEffect</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">effect</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">Echo</span><span class="o">(</span><span class="n">value</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">value</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">RandomInt</span>   <span class="k">=&gt;</span> <span class="n">scala</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">Random</span><span class="o">.</span><span class="n">nextInt</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">Ignore</span><span class="o">(</span><span class="k">_</span><span class="o">)</span>   <span class="k">=&gt;</span> <span class="o">()</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
<p>Let&rsquo;s consider a more realistic effect and one possible implementation:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">trait</span> <span class="nc">EffectSig</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">currentTimeMillis</span><span class="k">:</span> <span class="kt">Long</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">printLn</span><span class="o">(</span><span class="n">msg</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">mesure</span><span class="o">[</span><span class="kt">X</span>,<span class="kt">A</span><span class="o">](</span><span class="n">fun</span><span class="k">:</span> <span class="kt">X</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">,</span> <span class="n">arg</span><span class="k">:</span> <span class="kt">X</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">object</span> <span class="nc">EffectImpl</span> <span class="k">extends</span> <span class="nc">EffectSig</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">currentTimeMillis</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">printLn</span><span class="o">(</span><span class="n">msg</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="n">println</span><span class="o">(</span><span class="n">msg</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">mesure</span><span class="o">[</span><span class="kt">X</span>,<span class="kt">A</span><span class="o">](</span><span class="n">fun</span><span class="k">:</span> <span class="kt">X</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">,</span> <span class="n">arg</span><span class="k">:</span> <span class="kt">X</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">val</span> <span class="n">t0</span> <span class="k">=</span> <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">val</span> <span class="n">r</span>  <span class="k">=</span> <span class="n">fun</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">val</span> <span class="n">t1</span> <span class="k">=</span> <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">println</span><span class="o">(</span><span class="s">s&#34;Took </span><span class="si">${</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="si">}</span><span class="s"> milli-seconds&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">r</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<ul>
<li>
<p><strong>Question 1:</strong> <code>ExampleEffect</code> is the equivalent of <code>ExampleEffectSig</code>,
but using a <code>sealed trait</code> with some <code>final case class</code> and <code>case object</code>.
Write the equivalent of <code>EffectSig</code> in the same way. Call this trait <code>Effect</code>.</p>
  <details>
    <summary><em>Solution (click to expand)</em></summary>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">CurrentTimeMillis</span> <span class="k">extends</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">PrintLn</span><span class="o">(</span><span class="n">msg</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">Mesure</span><span class="o">[</span><span class="kt">X</span>,<span class="kt">A</span><span class="o">](</span><span class="n">fun</span><span class="k">:</span> <span class="kt">X</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">,</span> <span class="n">arg</span><span class="k">:</span> <span class="kt">X</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span></span></span></code></pre></div>
  </details>
</li>
<li>
<p><strong>Question 2:</strong> Write the function <code>def run[A](effect: Effect[A]): A</code>
that mimics the implementation of <code>EffectImpl</code>
just like <code>runExampleEffect</code> mimics <code>ExampleEffectImpl</code>.</p>
  <details>
    <summary><em>Solution (click to expand)</em></summary>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">run</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">effect</span><span class="k">:</span> <span class="kt">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">effect</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">CurrentTimeMillis</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">PrintLn</span><span class="o">(</span><span class="n">msg</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="n">println</span><span class="o">(</span><span class="n">msg</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">Mesure</span><span class="o">(</span><span class="n">fun</span><span class="o">,</span> <span class="n">arg</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">t0</span> <span class="k">=</span> <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">r</span>  <span class="k">=</span> <span class="n">fun</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">t1</span> <span class="k">=</span> <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">      <span class="n">println</span><span class="o">(</span><span class="s">s&#34;Took </span><span class="si">${</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="si">}</span><span class="s"> milli-seconds&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">r</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
  </details>
</li>
</ul>
<p>The type <code>Effect[A]</code> declares interesting effects (<code>CurrentTimeMillis</code>,
<code>PrintLn</code> and <code>Mesure</code>) but to be really useful, we need to be able
to chain effects! To do so, we want to have these two functions:</p>
<ul>
<li><code>def pure[A](value: A): Effect[A]</code></li>
<li><code>def flatMap[X,A](fx: Effect[X], f: X =&gt; Effect[A]): Effect[A]</code></li>
</ul>
<p>Once again we do not care yet about the implementation. Presently all
we want is declaring these two operations, just like we declared <code>CurrentTimeMillis</code>,
<code>PrintLn</code> and <code>Mesure</code>.</p>
<ul>
<li>
<p><strong>Question 3:</strong> Add two <em>final case classes</em>, <code>Pure</code> and <code>FlatMap</code>,
to <code>Effect[A]</code> declaring these operations.</p>
  <details>
    <summary><em>Solution (click to expand)</em></summary>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">CurrentTimeMillis</span> <span class="k">extends</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">PrintLn</span><span class="o">(</span><span class="n">msg</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">Mesure</span><span class="o">[</span><span class="kt">X</span>,<span class="kt">A</span><span class="o">](</span><span class="n">fun</span><span class="k">:</span> <span class="kt">X</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">,</span> <span class="n">arg</span><span class="k">:</span> <span class="kt">X</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">Pure</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">FlatMap</span><span class="o">[</span><span class="kt">X</span>,<span class="kt">A</span><span class="o">](</span><span class="n">fx</span><span class="k">:</span> <span class="kt">Effect</span><span class="o">[</span><span class="kt">X</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">X</span> <span class="o">=&gt;</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span></span></span></code></pre></div>
  </details>
</li>
<li>
<p><strong>Question 4:</strong> Adapt the function <code>run</code> to handle these two new cases.</p>
  <details>
    <summary><em>Solution (click to expand)</em></summary>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">run</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">effect</span><span class="k">:</span> <span class="kt">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">effect</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">CurrentTimeMillis</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">PrintLn</span><span class="o">(</span><span class="n">msg</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="n">println</span><span class="o">(</span><span class="n">msg</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">Mesure</span><span class="o">(</span><span class="n">fun</span><span class="o">,</span> <span class="n">arg</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">t0</span> <span class="k">=</span> <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">r</span>  <span class="k">=</span> <span class="n">fun</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">t1</span> <span class="k">=</span> <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">      <span class="n">println</span><span class="o">(</span><span class="s">s&#34;Took </span><span class="si">${</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="si">}</span><span class="s"> milli-seconds&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">r</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">Pure</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="n">a</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">FlatMap</span><span class="o">(</span><span class="n">fx</span><span class="o">,</span> <span class="n">f</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">x</span>  <span class="k">=</span> <span class="n">run</span><span class="o">(</span><span class="n">fx</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">fa</span> <span class="k">:</span> <span class="kt">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">run</span><span class="o">(</span><span class="n">fa</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
  </details>
</li>
<li>
<p><strong>Question 5:</strong> Add the two following methods to trait <code>Effect[A]</code> to get:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">final</span> <span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Effect</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nc">FlatMap</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">f</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="k">final</span> <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Effect</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">]((</span><span class="n">a</span><span class="k">:</span><span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Pure</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)))</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p>And run the follwing code to see if it works:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">effect1</span><span class="k">:</span> <span class="kt">Effect</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">t0</span> <span class="k">&lt;-</span> <span class="nc">CurrentTimeMillis</span>
</span></span><span class="line"><span class="cl">    <span class="k">_</span>  <span class="k">&lt;-</span> <span class="nc">PrintLn</span><span class="o">(</span><span class="s">s&#34;The current time is </span><span class="si">$t0</span><span class="s">&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span> <span class="k">yield</span> <span class="o">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">run</span><span class="o">(</span><span class="n">effect1</span><span class="o">)</span></span></span></code></pre></div>
  <details>
    <summary><em>Solution (click to expand)</em></summary>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">final</span> <span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Effect</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nc">FlatMap</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">f</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="k">final</span> <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Effect</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">]((</span><span class="n">a</span><span class="k">:</span><span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Pure</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)))</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">CurrentTimeMillis</span> <span class="k">extends</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">PrintLn</span><span class="o">(</span><span class="n">msg</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">Mesure</span><span class="o">[</span><span class="kt">X</span>,<span class="kt">A</span><span class="o">](</span><span class="n">fun</span><span class="k">:</span> <span class="kt">X</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">,</span> <span class="n">arg</span><span class="k">:</span> <span class="kt">X</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">Pure</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">FlatMap</span><span class="o">[</span><span class="kt">X</span>,<span class="kt">A</span><span class="o">](</span><span class="n">fx</span><span class="k">:</span> <span class="kt">Effect</span><span class="o">[</span><span class="kt">X</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">X</span> <span class="o">=&gt;</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">run</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">effect</span><span class="k">:</span> <span class="kt">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">effect</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">CurrentTimeMillis</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">PrintLn</span><span class="o">(</span><span class="n">msg</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="n">println</span><span class="o">(</span><span class="n">msg</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">Mesure</span><span class="o">(</span><span class="n">fun</span><span class="o">,</span> <span class="n">arg</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">t0</span> <span class="k">=</span> <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">r</span>  <span class="k">=</span> <span class="n">fun</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">t1</span> <span class="k">=</span> <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">      <span class="n">println</span><span class="o">(</span><span class="s">s&#34;Took </span><span class="si">${</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="si">}</span><span class="s"> milli-seconds&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">r</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">Pure</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="n">a</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">FlatMap</span><span class="o">(</span><span class="n">fx</span><span class="o">,</span> <span class="n">f</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">x</span>  <span class="k">=</span> <span class="n">run</span><span class="o">(</span><span class="n">fx</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">fa</span> <span class="k">:</span> <span class="kt">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">run</span><span class="o">(</span><span class="n">fa</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">effect1</span><span class="k">:</span> <span class="kt">Effect</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">t0</span> <span class="k">&lt;-</span> <span class="nc">CurrentTimeMillis</span>
</span></span><span class="line"><span class="cl">    <span class="k">_</span>  <span class="k">&lt;-</span> <span class="nc">PrintLn</span><span class="o">(</span><span class="s">s&#34;The current time is </span><span class="si">$t0</span><span class="s">&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span> <span class="k">yield</span> <span class="o">()</span></span></span></code></pre></div>
<p>When we run <code>run(effect1)</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">run</span><span class="o">(</span><span class="n">effect1</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="nc">The</span> <span class="n">current</span> <span class="n">time</span> <span class="n">is</span> <span class="mi">1569773175010</span></span></span></code></pre></div>
  </details>
</li>
</ul>
<p>Congratulations! You just wrote your first <em>IO</em> monad! There
is a lot of scientific words to name the <code>sealed trait Effect[A]</code>:
you can call it an <em>algebraic effect</em>, a <em>free monad</em>, an <em>IO</em>, etc.
But in the end, it is just a plain simple <code>sealed trait</code> with
some <code>final case class</code> and <code>case object</code> that
represent the functions we wanted to have, without providing
their implementation (<code>CurrentTimeMillis</code>, <code>PrintLn</code>, <code>Mesure</code>,
<code>Pure</code> and <code>FlatMap</code>). You can call them <em>virtual methods</em> if you
like. <strong>What really matters is that we isolated the declaration of
the functions from their implementation.</strong> Remember that a <code>trait</code>
is just a interface after all.</p>
<h3 id="use-case-ensuring-types-are-supported-by-the-database">Use Case: Ensuring types are supported by the Database</h3>
<p>Databases are great. We can store tables, documents, key/values pairs, graphs, etc.
But for any database, there is unfortunately only a limited set of supported types.
Take a database you like, I am sure I can find some types it does not support.</p>
<p>In this section we consider the use case of data structures and code that do not work
for (values of) any type but only for some! This problem is not limited to databases but
concerns any <em>API</em> that only supports a limited set of types (the vast majority of <em>APIs</em>).
How to enforce this constraint? How to adapt the patterns we like to work under this constraint?
This is all this section is about.</p>
<p>We consider a fictional database that <strong>only</strong> supports the following types:</p>
<ol>
<li><code>String</code></li>
<li><code>Double</code></li>
<li><code>(A,B)</code> where <code>A</code> and <code>B</code> are also types supported by the database.</li>
</ol>
<p>It means that the values stored by the database (in tables, key/value pairs, etc) <strong>must</strong>
follow the rules above. It can store <code>&quot;Hello World&quot;</code> because it is a <code>String</code> which is
a supported type by rule <em>1</em>. Likewise, it can store <code>5.2</code> because it is a <code>Double</code>,
but it can <em>not</em> store <code>5 : Int</code> because it is an <code>Int</code>. It can store <code>(&quot;Hello World&quot;, 5.2)</code>
thanks to rule <em>3</em> and also <code>((&quot;Hello World&quot;, 5.2) , 8.9)</code> once again by rule <em>3</em>.</p>
<ul>
<li>
<p><strong>Question 1:</strong> Define the type <code>DBType[A]</code> such that:</p>
<blockquote>
<p>There exists a value of type <code>DBType[A]</code> <strong>if and only if</strong> <code>A</code>
is a type supported by the database.</p>
</blockquote>
  <details>
    <summary><em>Solution (click to expand)</em></summary>
<p>Transposing the rules above in code, we get:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">DBType</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">DBString</span> <span class="k">extends</span> <span class="nc">DBType</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">DBDouble</span> <span class="k">extends</span> <span class="nc">DBType</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">DBPair</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">first</span><span class="k">:</span> <span class="kt">DBType</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">second</span><span class="k">:</span> <span class="kt">DBType</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">DBType</span><span class="o">[(</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">)]</span></span></span></code></pre></div>
  <details>
  <summary><strong>Remark for people fluent in <em>Scala</em></strong> <em>(click to expand)</em></summary>
<p>Using all the nice features of <em>Scala</em>, the production-ready version of the code above is:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">DBType</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">object</span> <span class="nc">DBType</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">DBString</span> <span class="k">extends</span> <span class="nc">DBType</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">  <span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">DBDouble</span> <span class="k">extends</span> <span class="nc">DBType</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">DBPair</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">first</span><span class="k">:</span> <span class="kt">DBType</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">second</span><span class="k">:</span> <span class="kt">DBType</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">DBType</span><span class="o">[(</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">)]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">implicit</span> <span class="k">val</span> <span class="n">dbString</span> <span class="k">:</span> <span class="kt">DBType</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="nc">DBString</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">implicit</span> <span class="k">val</span> <span class="n">dbDouble</span> <span class="k">:</span> <span class="kt">DBType</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="nc">DBDouble</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">implicit</span> <span class="k">def</span> <span class="n">dbPair</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="k">implicit</span> <span class="n">first</span><span class="k">:</span> <span class="kt">DBType</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">second</span><span class="k">:</span> <span class="kt">DBType</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">DBType</span><span class="o">[(</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">)]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="nc">DBPair</span><span class="o">(</span><span class="n">first</span><span class="o">,</span> <span class="n">second</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">DBType</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">ev.</span><span class="k">type</span> <span class="o">=</span> <span class="n">ev</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
  </details>
  </details>
</li>
</ul>
<p>Using <code>DBType</code>, we can pair a value of type <code>A</code> with a value of type <code>DBType[A]</code>,
which provides an evidence that the type <code>A</code> is supported by the database:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">DBValue</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="k">val</span> <span class="n">dbType</span><span class="k">:</span> <span class="kt">DBType</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span></span></span></code></pre></div>
<p>Note that the parameter <code>dbType</code> does not need to be implicit! All that matters is that
to create a value of type <code>DBValue[A]</code>, we need to provide a value of type <code>DBType[A]</code>
which forces <code>A</code> to be a supported type.</p>
<p>A functor is, approximately, a type constructor <code>F</code> like <code>List</code>, <code>Option</code>, <code>DBValue</code>, &hellip;
for which you can write an instance of the trait</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">trait</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p>where <code>map(fa)(f)</code> applies the function <code>f</code> to any value of type <code>A</code> contained in <code>fa</code>.
For example:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">implicit</span> <span class="k">object</span> <span class="nc">OptionFunctor</span> <span class="k">extends</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">Option</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="n">fa</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nc">None</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<ul>
<li>
<p><strong>Question 2:</strong> Write an instance of <code>Functor[DBValue]</code>.</p>
  <details>
    <summary><em>Solution (click to expand)</em></summary>
<p>We actually can not! If we try to compile the following code:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">object</span> <span class="nc">DBValueFunctor</span> <span class="k">extends</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">DBValue</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">DBValue</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">DBValue</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="nc">DBValue</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="o">(</span><span class="n">fa</span><span class="o">.</span><span class="n">value</span><span class="o">))</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p><em>Scala</em> complains: <code>could not find implicit value for parameter dbType: DBType[B]</code>.
Indeed, booleans are not a supported type by the database: they are neither strings,
nor doubles, not pairs.
But if we could write a <code>Functor</code> instance for <code>DBValue</code>
(i.e. if we could write a <code>map</code> function for <code>DBValue</code>),
then we could write:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">dbValueString</span>  <span class="k">:</span> <span class="kt">DBValue</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>  <span class="k">=</span> <span class="nc">DBValue</span><span class="o">(</span><span class="s">&#34;A&#34;</span><span class="o">)(</span><span class="nc">DBString</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">dbValueBoolean</span> <span class="k">:</span> <span class="kt">DBValue</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="k">=</span> <span class="n">dbValueString</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">true</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">dbTypeBoolean</span>  <span class="k">:</span> <span class="kt">DBType</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span>  <span class="k">=</span> <span class="n">dbValueBoolean</span><span class="o">.</span><span class="n">dbType</span></span></span></code></pre></div>
<p>We would get a value (<code>dbTypeBoolean</code>) of type <code>DBType[Boolean]</code>,
which would mean that the type <code>Boolean</code> is supported by the database.
But it is not! Furthermore, by definition:</p>
<blockquote>
<p>There exists a value of type <code>DBType[A]</code> <strong>if and only if</strong>
<code>A</code> is a type supported by the database.</p>
</blockquote>
<p>So it is impossible to have a value of type <code>DBType[Boolean]</code>
and thus it is impossible to write a function <code>map</code> for <code>DBValue</code>.
So there is no way to write a <code>Functor</code> instance for <code>DBValue</code>.</p>
  </details>
</li>
</ul>
<p>A <em>Generalized Functor</em> is very much like a regular <code>Functor</code>.
But whereas the <code>map</code> function of functors have to work for <strong>every</strong>
types <code>A</code> and <code>B</code>, the <code>map</code> function of <em>generalized functor</em>
can be narrowed to only operate on a limited set of types <code>A</code> and <code>B</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">trait</span> <span class="nc">GenFunctor</span><span class="o">[</span><span class="kt">P</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">evA</span><span class="k">:</span> <span class="kt">P</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">evB</span><span class="k">:</span> <span class="kt">P</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p>For example <code>Set</code> (more precisely <code>TreeSet</code>) is not a functor!
Indeed there is no way to write a function <code>map</code> that works for
any type <code>B</code> (because <code>B</code> need to have an ordering). But if we narrow
<code>map</code> to the only types <code>B</code> having an ordering, we can write it.</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">import</span> <span class="nn">scala.collection.immutable._</span>
</span></span><span class="line"><span class="cl"><span class="k">object</span> <span class="nc">TreeSetFunctor</span> <span class="k">extends</span> <span class="nc">GenFunctor</span><span class="o">[</span><span class="kt">Ordering</span>, <span class="kt">TreeSet</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">TreeSet</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">evA</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">evB</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">TreeSet</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="nc">TreeSet</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">evB</span><span class="o">)</span> <span class="o">++</span> <span class="n">fa</span><span class="o">.</span><span class="n">toSeq</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">f</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<ul>
<li>
<p><strong>Question 3:</strong> Write an instance of <code>GenFunctor[DBType, DBValue]</code>.</p>
  <details>
    <summary><em>Solution (click to expand)</em></summary>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">object</span> <span class="nc">DBValueGenFunctor</span> <span class="k">extends</span> <span class="nc">GenFunctor</span><span class="o">[</span><span class="kt">DBType</span>, <span class="kt">DBValue</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">DBValue</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">evA</span><span class="k">:</span> <span class="kt">DBType</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">evB</span><span class="k">:</span> <span class="kt">DBType</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">DBValue</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="nc">DBValue</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="o">(</span><span class="n">fa</span><span class="o">.</span><span class="n">value</span><span class="o">))(</span><span class="n">evB</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
  </details>
</li>
</ul>
<p>What we have done to <code>Functor</code> can be done for many data-structures and patterns.
We can often limit the types on which a data-structure or a type-class can operate
by adding an extra parameter like <code>ev : DBType[A]</code> to constructors and methods.</p>
<h3 id="use-case-simplifying-implicits">Use Case: Simplifying Implicits</h3>
<p>This use case is one the most interesting but unfortunately, not one of the easiest. It
illustrates how it is possible to use <em>GADTs</em> to simplify the creation of implicit values.
In this example we consider lists of values whose items can be of different types. Theses
lists are called <em>heterogeneous lists</em>. They are usually defined in <em>Scala</em> almost like
normal lists:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">HNil</span><span class="o">()</span> <span class="c1">// The empty list
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">HCons</span><span class="o">[</span><span class="kt">Head</span>,<span class="kt">Tail</span><span class="o">](</span><span class="n">head</span><span class="k">:</span> <span class="kt">Head</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">Tail</span><span class="o">)</span> <span class="c1">// The `head :: tail` operation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">empty</span> <span class="k">:</span> <span class="kt">HNil</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="nc">HNil</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">oneTrueToto</span> <span class="k">:</span> <span class="kt">HCons</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">HCons</span><span class="o">[</span><span class="kt">Boolean</span>, <span class="kt">HCons</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">HNil</span><span class="o">]]]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="nc">HCons</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">HCons</span><span class="o">(</span><span class="kc">true</span><span class="o">,</span> <span class="nc">HCons</span><span class="o">(</span><span class="s">&#34;toto&#34;</span><span class="o">,</span> <span class="nc">HNil</span><span class="o">())))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">falseTrueFive</span><span class="k">:</span> <span class="kt">HCons</span><span class="o">[</span><span class="kt">Boolean</span>, <span class="kt">HCons</span><span class="o">[</span><span class="kt">Boolean</span>, <span class="kt">HCons</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">HNil</span><span class="o">]]]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="nc">HCons</span><span class="o">(</span><span class="kc">false</span><span class="o">,</span> <span class="nc">HCons</span><span class="o">(</span><span class="kc">true</span><span class="o">,</span> <span class="nc">HCons</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="nc">HNil</span><span class="o">())))</span></span></span></code></pre></div>
<p>As you can see, there is nothing special about it. We want to define
orderings on heterogeneous lists. An ordering is a way to compare two
values (<strong>of the same type!</strong>): they can be equal or one may be lesser
than the other. In <em>Scala</em> we can define the trait <code>Order</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">trait</span> <span class="nc">Order</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// true if and only if a1 &lt; a2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">def</span> <span class="n">lesserThan</span><span class="o">(</span><span class="n">a1</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// a1 and a2 are equal if and only if none of them is lesser than the other.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">final</span> <span class="k">def</span> <span class="n">areEqual</span><span class="o">(</span><span class="n">a1</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">!</span><span class="n">lesserThan</span><span class="o">(</span><span class="n">a1</span><span class="o">,</span> <span class="n">a2</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">lesserThan</span><span class="o">(</span><span class="n">a2</span><span class="o">,</span> <span class="n">a1</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// a1 &gt; a2 if and only if a2 &lt; a1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">final</span> <span class="k">def</span> <span class="n">greaterThan</span><span class="o">(</span><span class="n">a1</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">lesserThan</span><span class="o">(</span><span class="n">a2</span><span class="o">,</span> <span class="n">a1</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">final</span> <span class="k">def</span> <span class="n">lesserThanOrEqual</span><span class="o">(</span><span class="n">a1</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">!</span><span class="n">lesserThan</span><span class="o">(</span><span class="n">a2</span><span class="o">,</span> <span class="n">a1</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">final</span> <span class="k">def</span> <span class="n">greaterThanOrEqual</span><span class="o">(</span><span class="n">a1</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">!</span><span class="n">lesserThan</span><span class="o">(</span><span class="n">a1</span><span class="o">,</span> <span class="n">a2</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">object</span> <span class="nc">Order</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">ev.</span><span class="k">type</span> <span class="o">=</span> <span class="n">ev</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">make</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">lg_</span> <span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span><span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="k">new</span> <span class="nc">Order</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">def</span> <span class="n">lesserThan</span><span class="o">(</span><span class="n">a1</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">lg_</span><span class="o">(</span><span class="n">a1</span><span class="o">,</span><span class="n">a2</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">implicit</span> <span class="k">val</span> <span class="n">orderInt</span>    <span class="k">=</span> <span class="nc">Order</span><span class="o">.</span><span class="n">make</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="k">_</span> <span class="o">&lt;</span> <span class="k">_</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="k">implicit</span> <span class="k">val</span> <span class="n">orderString</span> <span class="k">=</span> <span class="nc">Order</span><span class="o">.</span><span class="n">make</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="k">_</span> <span class="o">&lt;</span> <span class="k">_</span><span class="o">)</span></span></span></code></pre></div>
<p>Remember that we will only compare lists of the <em>same type</em>:</p>
<ul>
<li>Lists of type <code>HNil</code> will only be compared to lists of type <code>HNil</code>.</li>
<li>Lists of type <code>HCons[H,T]</code> will only be compared to lists of type <code>HCons[H,T]</code>.</li>
</ul>
<p>Comparing lists of type <code>HNil</code> is trivial because there is only one value
of type <code>HNil</code> (the empty list <code>HNil()</code>).
But there are many ways of comparing lists of type <code>HCons[H,T]</code>.
Here are two possible orderings (there exists many more!):</p>
<ul>
<li>
<p>The <em>lexicographic ordering</em> (i.e. dictionary order: from left to right)</p>
<blockquote>
<p><code>HCons(h1,t1) &lt; HCons(h2,t2)</code> <strong>if and only if</strong>
<code>h1 &lt; h2</code> <em>or</em> (<code>h1 == h2</code> <em>and</em> <code>t1 &lt; t2</code> <em>by lexicographic ordering</em>).</p>
</blockquote>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Lex</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">val</span> <span class="n">order</span> <span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">object</span> <span class="nc">Lex</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Lex</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">ev.</span><span class="k">type</span> <span class="o">=</span> <span class="n">ev</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">implicit</span> <span class="k">val</span> <span class="n">lexHNil</span><span class="k">:</span> <span class="kt">Lex</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="k">new</span> <span class="nc">Lex</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">order</span> <span class="k">=</span> <span class="nc">Order</span><span class="o">.</span><span class="n">make</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]((</span><span class="k">_</span><span class="o">,</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="kc">false</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">implicit</span> <span class="k">def</span> <span class="n">lexHCons</span><span class="o">[</span><span class="kt">Head</span>,<span class="kt">Tail</span><span class="o">](</span><span class="k">implicit</span>
</span></span><span class="line"><span class="cl">      <span class="n">orderHead</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">Head</span><span class="o">],</span>
</span></span><span class="line"><span class="cl">      <span class="n">lexTail</span><span class="k">:</span> <span class="kt">Lex</span><span class="o">[</span><span class="kt">Tail</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">    <span class="o">)</span><span class="k">:</span> <span class="kt">Lex</span><span class="o">[</span><span class="kt">HCons</span><span class="o">[</span><span class="kt">Head</span>, <span class="kt">Tail</span><span class="o">]]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="k">new</span> <span class="nc">Lex</span><span class="o">[</span><span class="kt">HCons</span><span class="o">[</span><span class="kt">Head</span>, <span class="kt">Tail</span><span class="o">]]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">orderTail</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">Tail</span><span class="o">]</span> <span class="k">=</span> <span class="n">lexTail</span><span class="o">.</span><span class="n">order</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">order</span> <span class="k">=</span> <span class="nc">Order</span><span class="o">.</span><span class="n">make</span><span class="o">[</span><span class="kt">HCons</span><span class="o">[</span><span class="kt">Head</span>, <span class="kt">Tail</span><span class="o">]]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="o">(</span><span class="nc">HCons</span><span class="o">(</span><span class="n">h1</span><span class="o">,</span><span class="n">t1</span><span class="o">),</span> <span class="nc">HCons</span><span class="o">(</span><span class="n">h2</span><span class="o">,</span><span class="n">t2</span><span class="o">))</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="n">orderHead</span><span class="o">.</span><span class="n">lesserThan</span><span class="o">(</span><span class="n">h1</span><span class="o">,</span><span class="n">h2</span><span class="o">)</span> <span class="o">||</span> <span class="o">(</span><span class="n">orderHead</span><span class="o">.</span><span class="n">areEqual</span><span class="o">(</span><span class="n">h1</span><span class="o">,</span><span class="n">h2</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">orderTail</span><span class="o">.</span><span class="n">lesserThan</span><span class="o">(</span><span class="n">t1</span><span class="o">,</span><span class="n">t2</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">      <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
</li>
<li>
<p>The <em>reverse-lexicographic</em> ordering, which is the reverse version
of the lexicographic ordering, (i.e. from right to left)</p>
<blockquote>
<p><code>HCons(h1,t1) &lt; HCons(h2,t2)</code> <strong>if and only if</strong>
<code>t1 &lt; t2</code> <em>by reverse-lexicographic ordering or</em> (<code>t1 == t2</code> <em>and</em> <code>h1 &lt; h2</code>).</p>
</blockquote>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">RevLex</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">val</span> <span class="n">order</span> <span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">object</span> <span class="nc">RevLex</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">RevLex</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">ev.</span><span class="k">type</span> <span class="o">=</span> <span class="n">ev</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">implicit</span> <span class="k">val</span> <span class="n">revLexHNil</span><span class="k">:</span> <span class="kt">RevLex</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="k">new</span> <span class="nc">RevLex</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">order</span> <span class="k">=</span> <span class="nc">Order</span><span class="o">.</span><span class="n">make</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]((</span><span class="k">_</span><span class="o">,</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="kc">false</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">implicit</span> <span class="k">def</span> <span class="n">revLexHCons</span><span class="o">[</span><span class="kt">Head</span>,<span class="kt">Tail</span><span class="o">](</span><span class="k">implicit</span>
</span></span><span class="line"><span class="cl">      <span class="n">orderHead</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">Head</span><span class="o">],</span>
</span></span><span class="line"><span class="cl">      <span class="n">revLexTail</span><span class="k">:</span> <span class="kt">RevLex</span><span class="o">[</span><span class="kt">Tail</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">    <span class="o">)</span><span class="k">:</span> <span class="kt">RevLex</span><span class="o">[</span><span class="kt">HCons</span><span class="o">[</span><span class="kt">Head</span>, <span class="kt">Tail</span><span class="o">]]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="k">new</span> <span class="nc">RevLex</span><span class="o">[</span><span class="kt">HCons</span><span class="o">[</span><span class="kt">Head</span>, <span class="kt">Tail</span><span class="o">]]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">orderTail</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">Tail</span><span class="o">]</span> <span class="k">=</span> <span class="n">revLexTail</span><span class="o">.</span><span class="n">order</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">order</span> <span class="k">=</span> <span class="nc">Order</span><span class="o">.</span><span class="n">make</span><span class="o">[</span><span class="kt">HCons</span><span class="o">[</span><span class="kt">Head</span>, <span class="kt">Tail</span><span class="o">]]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="o">(</span><span class="nc">HCons</span><span class="o">(</span><span class="n">h1</span><span class="o">,</span><span class="n">t1</span><span class="o">),</span> <span class="nc">HCons</span><span class="o">(</span><span class="n">h2</span><span class="o">,</span><span class="n">t2</span><span class="o">))</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="n">orderTail</span><span class="o">.</span><span class="n">lesserThan</span><span class="o">(</span><span class="n">t1</span><span class="o">,</span><span class="n">t2</span><span class="o">)</span> <span class="o">||</span> <span class="o">(</span><span class="n">orderTail</span><span class="o">.</span><span class="n">areEqual</span><span class="o">(</span><span class="n">t1</span><span class="o">,</span><span class="n">t2</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">orderHead</span><span class="o">.</span><span class="n">lesserThan</span><span class="o">(</span><span class="n">h1</span><span class="o">,</span><span class="n">h2</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">      <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
</li>
</ul>
<p>As said above, it is possible to define more orderings:</p>
<ul>
<li>
<p><strong>Question 1:</strong> The <code>Alternate</code> ordering is defined by:</p>
<blockquote>
<p><code>HCons(h1,t1) &lt; HCons(h2,t2)</code> <strong>if and only if</strong>
<code>h1 &lt; h2</code> <em>or</em> (<code>h1 == h2</code> <em>and</em> <code>t1 &gt; t2</code> <em>by alternate ordering</em>).</p>
</blockquote>
<p>Just like what was done for <code>Lex</code> and <code>RevLex</code>,
implement the <code>Alternate</code> ordering.</p>
  <details>
    <summary><em>Solution (click to expand)</em></summary>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Alternate</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">val</span> <span class="n">order</span> <span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">object</span> <span class="nc">Alternate</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Alternate</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">ev.</span><span class="k">type</span> <span class="o">=</span> <span class="n">ev</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">implicit</span> <span class="k">val</span> <span class="n">alternateHNil</span><span class="k">:</span> <span class="kt">Alternate</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="k">new</span> <span class="nc">Alternate</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">order</span> <span class="k">=</span> <span class="nc">Order</span><span class="o">.</span><span class="n">make</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]((</span><span class="k">_</span><span class="o">,</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="kc">false</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">implicit</span> <span class="k">def</span> <span class="n">alternateHCons</span><span class="o">[</span><span class="kt">Head</span>,<span class="kt">Tail</span><span class="o">](</span><span class="k">implicit</span>
</span></span><span class="line"><span class="cl">      <span class="n">orderHead</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">Head</span><span class="o">],</span>
</span></span><span class="line"><span class="cl">      <span class="n">alternateTail</span><span class="k">:</span> <span class="kt">Alternate</span><span class="o">[</span><span class="kt">Tail</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">    <span class="o">)</span><span class="k">:</span> <span class="kt">Alternate</span><span class="o">[</span><span class="kt">HCons</span><span class="o">[</span><span class="kt">Head</span>, <span class="kt">Tail</span><span class="o">]]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="k">new</span> <span class="nc">Alternate</span><span class="o">[</span><span class="kt">HCons</span><span class="o">[</span><span class="kt">Head</span>, <span class="kt">Tail</span><span class="o">]]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">orderTail</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">Tail</span><span class="o">]</span> <span class="k">=</span> <span class="n">alternateTail</span><span class="o">.</span><span class="n">order</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">order</span> <span class="k">=</span> <span class="nc">Order</span><span class="o">.</span><span class="n">make</span><span class="o">[</span><span class="kt">HCons</span><span class="o">[</span><span class="kt">Head</span>, <span class="kt">Tail</span><span class="o">]]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="o">(</span><span class="nc">HCons</span><span class="o">(</span><span class="n">h1</span><span class="o">,</span><span class="n">t1</span><span class="o">),</span> <span class="nc">HCons</span><span class="o">(</span><span class="n">h2</span><span class="o">,</span><span class="n">t2</span><span class="o">))</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="n">orderHead</span><span class="o">.</span><span class="n">lesserThan</span><span class="o">(</span><span class="n">h1</span><span class="o">,</span><span class="n">h2</span><span class="o">)</span> <span class="o">||</span> <span class="o">(</span><span class="n">orderHead</span><span class="o">.</span><span class="n">areEqual</span><span class="o">(</span><span class="n">h1</span><span class="o">,</span><span class="n">h2</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">orderTail</span><span class="o">.</span><span class="n">greaterThan</span><span class="o">(</span><span class="n">t1</span><span class="o">,</span><span class="n">t2</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">      <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
  </details>
</li>
</ul>
<p>There are lots of ways to define a valid ordering on heterogeneous lists!
Defining type classes like <code>Lex</code>, <code>RevLex</code> and <code>Alternate</code> for every ordering
we want to implement is clunky and messy. We can do much better than that &hellip;
with a <em>GADT</em> 😉</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">HListOrder</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">object</span> <span class="nc">HListOrder</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">HNilOrder</span> <span class="k">extends</span> <span class="nc">HListOrder</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">HConsOrder</span><span class="o">[</span><span class="kt">Head</span>,<span class="kt">Tail</span><span class="o">](</span>
</span></span><span class="line"><span class="cl">      <span class="n">orderHead</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">Head</span><span class="o">],</span>
</span></span><span class="line"><span class="cl">      <span class="n">hlistOrderTail</span><span class="k">:</span> <span class="kt">HListOrder</span><span class="o">[</span><span class="kt">Tail</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">    <span class="o">)</span> <span class="k">extends</span> <span class="nc">HListOrder</span><span class="o">[</span><span class="kt">HCons</span><span class="o">[</span><span class="kt">Head</span>,<span class="kt">Tail</span><span class="o">]]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Implicit definitions
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="k">implicit</span> <span class="k">val</span> <span class="n">hnilOrder</span> <span class="k">:</span> <span class="kt">HListOrder</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="nc">HNilOrder</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">implicit</span> <span class="k">def</span> <span class="n">hconsOrder</span><span class="o">[</span><span class="kt">Head</span>,<span class="kt">Tail</span><span class="o">](</span><span class="k">implicit</span>
</span></span><span class="line"><span class="cl">      <span class="n">orderHead</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">Head</span><span class="o">],</span>
</span></span><span class="line"><span class="cl">      <span class="n">hlistOrderTail</span><span class="k">:</span> <span class="kt">HListOrder</span><span class="o">[</span><span class="kt">Tail</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">    <span class="o">)</span><span class="k">:</span> <span class="kt">HListOrder</span><span class="o">[</span><span class="kt">HCons</span><span class="o">[</span><span class="kt">Head</span>,<span class="kt">Tail</span><span class="o">]]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="nc">HConsOrder</span><span class="o">(</span><span class="n">orderHead</span><span class="o">,</span> <span class="n">hlistOrderTail</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">HListOrder</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">ev.</span><span class="k">type</span> <span class="o">=</span> <span class="n">ev</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p>Note that these implicit definitions are boilerplate. Their only purpose
is passing arguments to their corresponding constructor (i.e. <code>final case class</code>
or <code>case object</code>): <code>hnilOrder</code> to <code>HNilOrder</code> (O arguments) and <code>hconsOrder</code>
to <code>HConsOrder</code> (2 arguments).</p>
<ul>
<li>
<p><strong>Question 2:</strong> Write the function <code>def lex[A](implicit v : HListOrder[A]): Order[A]</code>
that computes the lexicographic ordering from a value of type <code>HListOrder[A]</code>.</p>
  <details>
    <summary><em>Solution (click to expand)</em></summary>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">lex</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">implicit</span> <span class="n">v</span> <span class="k">:</span> <span class="kt">HListOrder</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">v</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">HListOrder</span><span class="o">.</span><span class="nc">HNilOrder</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nc">Order</span><span class="o">.</span><span class="n">make</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]((</span><span class="k">_</span><span class="o">,</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="kc">false</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="n">hc</span> <span class="k">:</span> <span class="kt">HListOrder.HConsOrder</span><span class="o">[</span><span class="kt">head</span>,<span class="kt">tail</span><span class="o">]</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">orderHead</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">head</span><span class="o">]</span> <span class="k">=</span> <span class="n">hc</span><span class="o">.</span><span class="n">orderHead</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">orderTail</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">tail</span><span class="o">]</span> <span class="k">=</span> <span class="n">lex</span><span class="o">(</span><span class="n">hc</span><span class="o">.</span><span class="n">hlistOrderTail</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="nc">Order</span><span class="o">.</span><span class="n">make</span><span class="o">[</span><span class="kt">HCons</span><span class="o">[</span><span class="kt">head</span>, <span class="kt">tail</span><span class="o">]]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="o">(</span><span class="nc">HCons</span><span class="o">(</span><span class="n">h1</span><span class="o">,</span><span class="n">t1</span><span class="o">),</span> <span class="nc">HCons</span><span class="o">(</span><span class="n">h2</span><span class="o">,</span><span class="n">t2</span><span class="o">))</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="n">orderHead</span><span class="o">.</span><span class="n">lesserThan</span><span class="o">(</span><span class="n">h1</span><span class="o">,</span><span class="n">h2</span><span class="o">)</span> <span class="o">||</span> <span class="o">(</span><span class="n">orderHead</span><span class="o">.</span><span class="n">areEqual</span><span class="o">(</span><span class="n">h1</span><span class="o">,</span><span class="n">h2</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">orderTail</span><span class="o">.</span><span class="n">lesserThan</span><span class="o">(</span><span class="n">t1</span><span class="o">,</span><span class="n">t2</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">      <span class="o">}</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
  </details>
</li>
<li>
<p><strong>Question 3:</strong> Write the function <code>def revLex[A](implicit v : HListOrder[A]): Order[A]</code>
that computes the reverse-lexicographic ordering from a value of type <code>HListOrder[A]</code>.</p>
  <details>
    <summary><em>Solution (click to expand)</em></summary>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">revLex</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">implicit</span> <span class="n">v</span> <span class="k">:</span> <span class="kt">HListOrder</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">v</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">HListOrder</span><span class="o">.</span><span class="nc">HNilOrder</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nc">Order</span><span class="o">.</span><span class="n">make</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]((</span><span class="k">_</span><span class="o">,</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="kc">false</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="n">hc</span> <span class="k">:</span> <span class="kt">HListOrder.HConsOrder</span><span class="o">[</span><span class="kt">head</span>,<span class="kt">tail</span><span class="o">]</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">orderHead</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">head</span><span class="o">]</span> <span class="k">=</span> <span class="n">hc</span><span class="o">.</span><span class="n">orderHead</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">orderTail</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">tail</span><span class="o">]</span> <span class="k">=</span> <span class="n">revLex</span><span class="o">(</span><span class="n">hc</span><span class="o">.</span><span class="n">hlistOrderTail</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="nc">Order</span><span class="o">.</span><span class="n">make</span><span class="o">[</span><span class="kt">HCons</span><span class="o">[</span><span class="kt">head</span>, <span class="kt">tail</span><span class="o">]]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="o">(</span><span class="nc">HCons</span><span class="o">(</span><span class="n">h1</span><span class="o">,</span><span class="n">t1</span><span class="o">),</span> <span class="nc">HCons</span><span class="o">(</span><span class="n">h2</span><span class="o">,</span><span class="n">t2</span><span class="o">))</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="n">orderTail</span><span class="o">.</span><span class="n">lesserThan</span><span class="o">(</span><span class="n">t1</span><span class="o">,</span><span class="n">t2</span><span class="o">)</span> <span class="o">||</span> <span class="o">(</span><span class="n">orderTail</span><span class="o">.</span><span class="n">areEqual</span><span class="o">(</span><span class="n">t1</span><span class="o">,</span><span class="n">t2</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">orderHead</span><span class="o">.</span><span class="n">lesserThan</span><span class="o">(</span><span class="n">h1</span><span class="o">,</span><span class="n">h2</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">      <span class="o">}</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
  </details>
</li>
</ul>
<p>This approach has several benefits. Whereas the initial approach had to find
one implicit by ordering, the <em>GADT</em> approach only have to find one! Considering
implicit resolution is a costly operation, reducing it means faster compilation times.
Reading the code of functions <code>lex</code> and <code>revLex</code> is easier than understanding how
implicit resolution works for traits <code>Lex</code> and <code>RevLex</code>. Furthermore, they are just
functions, you can use all you can code in building the instance <code>Order[A]</code>.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Not so trivial, isn&rsquo;t it? 😉 Actually a fair amount
of the complexity you may have experienced comes to
the fact that reasoning about values and types is almost
never taught in programming courses.
What you consider simple now (web APIs, Streaming, Databases, etc)
would probably terrifies your younger self when you
were introduced for the first time to &ldquo;Hello World!&rdquo;.
You probably did not learn all you know in programming
in three hours so do not expect reasoning about programs
to be magically easier.</p>
<p>This workshop aimed at inspiring you, opening your mind
to this all new set of possibilities. If you found the use case
interesting, then take the time to understand the techniques.</p>
<p>Have fun and take care ❤️</p>

  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="proving-primality-with-gadts">Proving Primality with GADTs</h1>
    <p class="article-meta default"><em>1 Oct 2019 - 1100 Words</em></p>

<ul>
<li><strong>The <a href="https://scala-lang.org" rel="external" target="_self">Scala</a> source code is at <a href="https://github.com/chrilves/gadt.scala" rel="external" target="_self">github.com/chrilves/gadt.scala</a>.</strong></li>
<li><strong>The <a href="https://haxe.org" rel="external" target="_self">Haxe</a> source code is at <a href="https://github.com/chrilves/Gadts.hx" rel="external" target="_self">github.com/chrilves/Gadts.hx</a>.</strong></li>
<li><strong><a href="../prime">The Web Application is here.</a></strong></li>
</ul>
<p>Today we will explore the <a href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence" rel="external" target="_self">Curry–Howard correspondence</a>. Our mission
is writing, in <a href="https://www.scala-lang.org/" rel="external" target="_self">Scala</a>&rsquo;s <em>type system</em>, the property
on natural number of being <a href="https://en.wikipedia.org/wiki/Prime_number" rel="external" target="_self">prime</a>. Wikipedia defines it by:</p>
<blockquote>
<p>A natural number (1, 2, 3, 4, 5, 6, etc.) is called a <strong>prime number</strong> (or a <strong>prime</strong>) if it is greater than 1 and cannot be written as a product of two natural numbers that are both smaller than it.</p>
</blockquote>
<p>An equivalent way to put it is:</p>
<blockquote>
<p>A natural number is prime if it is <strong>greater than 1 and cannot be divided by any natural number greater than 1 but smaller than it</strong>.</p>
</blockquote>
<p>These definitions are equivalent as, by definition, any natural number <em>n</em> is divisible by <em>k</em> if and only if it can be written <em>n = k × p</em> for some natural number <em>p</em>.</p>
<p>Writing a program whose execution checks whether a number is prime is easy. But we are not interested in executing programs, only compiling them! We want the <strong>compiler to verify</strong>
that a number is indeed prime. At that point, you may wonder how it is even possible to use the compiler to &ldquo;prove&rdquo; something about numbers. That&rsquo;s exactly the point of the
<a href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence" rel="external" target="_self">Curry–Howard correspondence</a></p>
<h2 id="the-challenge">The Challenge</h2>
<p>You can write any <strong>positive integer</strong> in the input bow below:
<span id="prime-web"></span>
<script type="text/javascript" src="../js/prime-ui.js"></script></p>
<ul>
<li>
<p>Please write <code>3</code> in the input box above. A button shall appear
letting you download <code>Prime3.scala</code>. Run it via</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">scala Prime3.scala</span></span></code></pre></div>
<p>The file should compile and run flawlessly outputting <code>ForAllRec(NotDivRec(NotDivBase(SIsPositive(),LTBase()),AddPlus1(AddZero())),ForAllBase())</code>. Look into <code>Prime3.scala</code>,
you should see a value <code>prime3: Prime[_3]</code> defined. The <code>main</code> method simply outputs this value.</p>
</li>
<li>
<p>Now, write <code>4</code> in the input box. Download and run <code>Prime4.scala</code> via</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">scala Prime4.scala</span></span></code></pre></div>
<p>The file should compile but execution should failed with the exception <code>scala.NotImplementedError: an implementation is missing</code>. Look into <code>Prime4.scala</code>,
the value <code>prime4: Prime[_4]</code> is defined by <code>???</code>.</p>
</li>
<li>
<p>Read <code>Prime4.scala</code> carefully, starting from the beginning, and <strong>try to write a valid
definition for</strong> <code>val prime4: Prime[_4]</code>. Remember to <strong>follow very scrupulously the rules
stated in the first comment of <code>Prime4.scala</code></strong>.</p>
<ul>
<li>DO NOT ALTER, IN ANY WAY, THE DEFINITION OF ANY TYPE IN THE FILE</li>
<li>DO NOT ADD SUB CLASSES/OBJECTS TO TYPES IN THE FILE</li>
<li>DO NOT USE NULL IN ANY WAY</li>
<li>ONLY USE THE GIVEN CASE OBJECTS AND CASE CLASSES IN THE FILE</li>
<li>THE GOAL IS TO PRODUCE A <code>val prime4: Prime[_4]</code>,
NOT A <code>def prime4: Prime[_4]</code>,
NOT A <code>lazy val prime4: Prime[_4]</code>!</li>
<li>YOUR CODE SHOULD TYPE-CHECK AND RUN PRINTING THE VALUE <code>prime4</code></li>
</ul>
</li>
</ul>
<p><strong>Try to find valid values of type</strong> <code>Prime[_N]</code> <strong>when is not a prime number.</strong></p>
<h2 id="what-the-hell-is-going-on-">What the hell is going on ???</h2>
<p>To encode properties over natural number, we need to start by encoding natural numbers.
To do so, we associate to any natural number a type. Natural numbers can be constructed
by starting from the first one, <em>0</em>, and creating new ones by adding <em>1</em> successively.
For example, <em>1 = 0 + 1</em>, <em>2 = 0 + 1 + 1</em>, <em>3 = 0 + 1 + 1 + 1</em>, etc.
Our encoding will mimic this construction, starting from a base type encoding <em>0</em> and
an operation <em>&quot;+ 1&quot;</em>.
The number <em>0</em> is encoded as the type <code>_0</code> defined as the <code>final abstract class _0</code>
and the operation <em>&quot;+ 1&quot;</em> as the type function <code>final abstract class S[N &lt;: Nat]</code> which
for every type <code>N</code> encoding a natural number <em>n</em> gives the type <code>S[N]</code> encoding the
natural number <em>n + 1</em>. The type <code>Nat</code> can simply be defined as the alias
<code>type Nat = _0 | S[?]</code> because a natural number is either <em>0</em> or obtained by some <em>+ 1</em> operations.</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">type</span> <span class="kt">Nat</span> <span class="o">=</span> <span class="n">_0</span> <span class="o">|</span> <span class="n">S</span><span class="o">[</span><span class="kt">?</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">_0</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">S</span><span class="o">[</span><span class="kt">N</span> <span class="k">&lt;:</span> <span class="kt">Nat</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nc">type</span> <span class="n">_1</span> <span class="k">=</span> <span class="n">S</span><span class="o">[</span><span class="k">_</span><span class="err">0</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">type</span> <span class="k">_</span><span class="err">2</span> <span class="o">=</span> <span class="n">S</span><span class="o">[</span><span class="k">_</span><span class="err">1</span><span class="o">]</span> <span class="c1">// S[S[_0]]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">type</span> <span class="k">_</span><span class="err">3</span> <span class="o">=</span> <span class="n">S</span><span class="o">[</span><span class="k">_</span><span class="err">2</span><span class="o">]</span> <span class="c1">// S[S[S[_0]]]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">type</span> <span class="k">_</span><span class="err">4</span> <span class="o">=</span> <span class="n">S</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="o">]</span> <span class="c1">// S[S[S[S[_0]]]]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">type</span> <span class="k">_</span><span class="err">5</span> <span class="o">=</span> <span class="n">S</span><span class="o">[</span><span class="k">_</span><span class="err">4</span><span class="o">]</span> <span class="c1">// S[S[S[S[S[_0]]]]]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">...</span></span></span></code></pre></div>
<p>The next step is to define the type <code>Prime[N]</code> such that:</p>
<blockquote>
<p>There exists a <strong>valid</strong> value of type <code>Prime[N]</code> <strong>if and only if</strong> <code>N</code> is (the type associated to) a <strong>prime</strong> number.</p>
</blockquote>
<h3 id="proving-that-a-natural-number-is-prime">Proving that a Natural Number is Prime</h3>
<p>Let <em>n</em> be a natural number and <code>N</code> its associated type (for example <em>n=3</em> and <code>N = _3</code>).
Then:</p>
<blockquote>
<p><em>n</em> is prime <strong>if and only if</strong> for all natural number <em>m</em> such that <em>2 ≤ m &lt; n</em>, then <em>m</em> does not divide <em>n</em>.</p>
</blockquote>
<p>The type <code>ForAll[X, N]</code> encodes this exact property. There exists a value of type <code>ForAll[X,N]</code> <strong>if and only if</strong> both:</p>
<ul>
<li><code>X ≤ N</code></li>
<li>For all <code>M</code> such that <code>X ≤ M &lt; N</code>, <code>M</code> do not divide <code>N</code></li>
</ul>
<p>Actually the type <code>Prime[N]</code> is an alias for <code>ForAll[_2, N]</code>. We need to encode two more properties:</p>
<ul>
<li>For <code>I</code> and <code>J</code> two natural numbers, the property that <code>I</code> is less than or equal to <code>J</code> (<code>I ≤ J</code>).
It is encoded as the type <code>LessThan[I, J]</code>.</li>
<li>For <code>I</code> and <code>J</code> two natural numbers, the property that <code>I</code> does not divide <code>J</code>.
It is encoded as the type <code>NotDiv[I, J]</code>.</li>
</ul>
<p>Read the file <code>PrimeN.scala</code> carefully, each step is described and explained in much details.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Why asking you to build a value that not exists? Because the main point is not knowing whether there
exists a value of type <code>Prime[_4]</code> but understanding why such a value (following all the rules!) cannot exists!</p>
<p>It is widely known and accepted in programming culture that every type has values. After all, types exists only
to qualify values, right? And instantiating a type <code>T</code> is as simple as calling <code>new</code>! There is one huge problem
with this claim: <strong>it is completely wrong!</strong>. The idea that a types can have no value, often called empty type
or uninhabited type, is the cornerstone of a lot of techniques including logic, maths, programming with rich types,
formal systems like <a href="https://coq.inria.fr/" rel="external" target="_self">Coq</a>, etc.</p>
<p>This example is indeed both complicated and complex. It is neither a regular usage of <em>GADTs</em> nor something
meant for production! It&rsquo;s <strong>perfectly ok being confused</strong> about it or not understanding what is going on. As I
said, it is an complicated and complex example!! But when you manage to understand it, consider you master the
subject.</p>

  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="recursion-schemes-the-high-school-introduction">Recursion Schemes: the high-school introduction</h1>
    <p class="article-meta default"><em>22 Mar 2019 - 3600 Words</em></p>

<p><em>I gave a talk on Thursday the 28th of march 2019 at the <a href="https://www.meetup.com/fr-FR/Paris-Scala-User-Group-PSUG/events/259498147/" rel="external" target="_self">96th Paris Scala User Group</a> session on about this. The <a href="../slides/recursion-schemes-intro/index.html">slides are here</a>.</em></p>
<p>Recursion schemes are said to be a tough subject. Articles and presentations often
flood the audience with lots of names such as <em>Algebra</em>, <em>CoAlgebra</em>, <em>catamorphisms</em>,
<em>anamorhpisms</em>, <em>hylomorphism</em>, etc. Is knowing all these concepts required to understand
recursion schemes? I have good news for you: it isn&rsquo;t! All you need, to see what recursion
schemes are and why there are useful, can be presented with just a single basic function,
often taught as an introduction to programming: factorial. I&rsquo;m glad to welcome you to
to the high-school introduction to recursion scheme 😉.</p>
<h2 id="learning-recursion-schemes">Learning Recursion Schemes</h2>
<p>Before diving into the subject, let&rsquo;s take a moment to contextualize.
Recursion-schemes, like most of advanced functional programming techniques,
is almost never taught in programming courses or books. It means there is a strong chance
the subject, and the concepts it relies upon, is totally new to you.
I want you to remember you haven&rsquo;t learnt programming in one day, and you probably did not
start learning programming by implementing a distributed steaming application over
a spark cluster from scratch.
Like most of us, you probably started by coding some sort of <em>Hello, World!</em>.
Let&rsquo;s face it, real business application are a lot more complex than this.
Do you imagine what a first introduction to programming would be, if instead of asking
people to write a simple <em>Hello, World!</em>, we would ask them to write a real state-of-the-art
large-scale business application that meets all the requirements we expect in
production nowadays? <strong>Learning takes time! Start with toy examples that are
indeed far from real-word cases but enables you to grow your understanding, one step at a time.</strong></p>
<p>The examples below are indeed toy examples. When i develop with recursion scheme, like any
specialist in any field, i use specialist techniques and vocabulary (you know, the usual vocabulary
from category and type theory). But if you&rsquo;re reading this, it probably means you&rsquo;re not a
recursion-scheme specialist yet. Using complex words flatters our ego, which
is very enjoyable, but developing a deep understanding of these notions is far better! So let&rsquo;s put our ego
aside for a moment and accept to start with the basics.</p>
<h2 id="in-recursion-schemes-there-is-recursion">In <em>Recursion Schemes</em>, there is <em>Recursion</em></h2>
<p>First of all, let me present you the famous <em>factorial</em> function. It is defined on <em>non-negative</em> numbers <em>n</em> as the
product of all numbers between <em>1</em> and <em>n</em> included:</p>
$$fact(n) = 1 \times 2 \times 3 \times \cdots \times n$$<p>To ease the presentation we will take <code>Int</code> as the type of <em>non-negative integers</em>.
Obviously in production code negative values should be handled appropriately
but for simplicity&rsquo;s sake, we will define <code>fact</code> in <em>Scala</em> and in <em>Haskell</em> as</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">fact</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">val</span> <span class="n">r</span> <span class="k">=</span> <span class="n">fact</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">n</span> <span class="o">*</span> <span class="n">r</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">fact</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl"><span class="nf">fact</span> <span class="mi">0</span> <span class="ow">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="nf">fact</span> <span class="n">n</span> <span class="ow">=</span> <span class="kr">let</span> <span class="n">r</span> <span class="ow">=</span> <span class="n">fact</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">         <span class="kr">in</span> <span class="n">n</span> <span class="o">*</span> <span class="n">r</span></span></span></code></pre></div>
<p>Factorial is written here as a recursive function.
As you probably know, it can also be written as an
iterative one (using a <code>for</code> or <code>while</code> loop) but the subject of this article is <em>Recursion
Schemes</em>, not <em>Iterative Schemes</em>, so let&rsquo;s use recursion. This function computes <code>fact(2)</code> as follows:</p>
<ul>
<li><code>fact(2) = 2 * fact(1)</code> so it needs to compute <code>fact(1)</code></li>
<li><code>fact(1) = 1 * fact(0)</code> so it needs to compute <code>fact(0)</code></li>
<li><code>fact(0) = 1</code></li>
<li>now that the result of <code>fact(0)</code> is known, it can replace the call of <code>fact(0)</code>
by its result which gives <code>fact(1) = 1 * fact(0) = 1 * 1 = 1</code></li>
<li>now that the result of <code>fact(1)</code> is known, it can replace the call of <code>fact(1)</code>
by its result which gives <code>fact(2) = 2 * fact(1) = 2 * 1 = 2</code>.</li>
</ul>
<p>Look at how <code>fact(n)</code> is calling it-self: if <code>n = 0</code> then it doesn&rsquo;t call itself, otherwise
it calls itself on <code>n - 1</code>. Let&rsquo;s split this definition in two parts: the first one contains all the code
relevant to how <code>fact</code> is calling itself but only it, the second one is made of the rest. There is no clear
rule for what is relevant and what is not. Different splits may work, they will just give rise to different
schemes, which is not a problem at all. You just need to find one that fits your needs.</p>
<p>For <code>fact</code>, the key element to note is it is not calling itself when <code>n = 0</code> but otherwise calls itself
with <code>n - 1</code>. The constant returned in the <code>n = 0</code> case and the operation done in the other one have no impact
on how <code>fact</code> recurses. So i choose to split it by taking all code not relevant to recursion out of
its body:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="cm">/* Part irrelevant to recursion:
</span></span></span><span class="line"><span class="cl"><span class="cm"> * The real definitions of these variables
</span></span></span><span class="line"><span class="cl"><span class="cm"> * have no impact on how fact is calling itself
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">baseCase</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">recCase</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">r</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">r</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* Recursion-only part:
</span></span></span><span class="line"><span class="cl"><span class="cm"> * The only implementation details it contains
</span></span></span><span class="line"><span class="cl"><span class="cm"> * are about how fact it calling itself
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">fact</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">baseCase</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">val</span> <span class="n">r</span> <span class="k">=</span> <span class="n">fact</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">recCase</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="cm">{-
</span></span></span><span class="line"><span class="cl"><span class="cm"> Part irrelevant to recursion:
</span></span></span><span class="line"><span class="cl"><span class="cm"> The real definitions of these variables
</span></span></span><span class="line"><span class="cl"><span class="cm"> Have no impact on how fact is calling itself
</span></span></span><span class="line"><span class="cl"><span class="cm">-}</span>
</span></span><span class="line"><span class="cl"><span class="nf">baseCase</span> <span class="ow">::</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl"><span class="nf">baseCase</span>  <span class="ow">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">recCase</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl"><span class="nf">recCase</span> <span class="n">n</span> <span class="n">r</span> <span class="ow">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">r</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="cm">{-
</span></span></span><span class="line"><span class="cl"><span class="cm"> Recursion-only part:
</span></span></span><span class="line"><span class="cl"><span class="cm"> The only implementation details it contains
</span></span></span><span class="line"><span class="cl"><span class="cm"> are about how fact it calling itself
</span></span></span><span class="line"><span class="cl"><span class="cm"> -}</span>
</span></span><span class="line"><span class="cl"><span class="nf">fact</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl"><span class="nf">fact</span> <span class="mi">0</span> <span class="ow">=</span> <span class="n">baseCase</span>
</span></span><span class="line"><span class="cl"><span class="nf">fact</span> <span class="n">n</span> <span class="ow">=</span> <span class="kr">let</span> <span class="n">r</span> <span class="ow">=</span> <span class="n">fact</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">         <span class="kr">in</span> <span class="n">recCase</span> <span class="n">n</span> <span class="n">r</span></span></span></code></pre></div>
<p>Let me present you another function, also defined on <em>non-negative</em> numbers <em>n</em>,
but that computes this time the <em>sum</em>  of all numbers between <em>1</em> and <em>n</em> included:</p>
$$sum(n)  = 1 + 2 + 3 + \cdots + n$$<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">sum</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">val</span> <span class="n">r</span> <span class="k">=</span> <span class="n">sum</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">n</span> <span class="o">+</span> <span class="n">r</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">sum</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl"><span class="nf">sum</span> <span class="mi">0</span> <span class="ow">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="nf">sum</span> <span class="n">n</span> <span class="ow">=</span> <span class="kr">let</span> <span class="n">r</span> <span class="ow">=</span> <span class="n">sum</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="kr">in</span> <span class="n">n</span> <span class="o">+</span> <span class="n">r</span></span></span></code></pre></div>
<p>We can apply the same technique to <code>sum</code>: splitting the definition into two parts,
one containing all but only recursion-relevant code, and the other the rest. It gives:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="cm">/* Part irrelevant to recursion:
</span></span></span><span class="line"><span class="cl"><span class="cm"> * The real definitions of these variables
</span></span></span><span class="line"><span class="cl"><span class="cm"> * have no impact on how sum is recurs
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">baseCase</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">recCase</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">r</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="n">r</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* Recursion-only part:
</span></span></span><span class="line"><span class="cl"><span class="cm"> * The only implementation details it contains
</span></span></span><span class="line"><span class="cl"><span class="cm"> * are about how fact it recurs
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">sum</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">baseCase</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">val</span> <span class="n">r</span> <span class="k">=</span> <span class="n">sum</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">recCase</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="cm">{-
</span></span></span><span class="line"><span class="cl"><span class="cm"> Part irrelevant to recursion:
</span></span></span><span class="line"><span class="cl"><span class="cm"> The real definitions of these variables
</span></span></span><span class="line"><span class="cl"><span class="cm"> Have no impact on how fact is calling itself
</span></span></span><span class="line"><span class="cl"><span class="cm">-}</span>
</span></span><span class="line"><span class="cl"><span class="nf">baseCase</span> <span class="ow">::</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl"><span class="nf">baseCase</span> <span class="ow">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">recCase</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl"><span class="nf">recCase</span> <span class="n">n</span> <span class="n">r</span> <span class="ow">=</span> <span class="n">n</span> <span class="o">+</span> <span class="n">r</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="cm">{-
</span></span></span><span class="line"><span class="cl"><span class="cm"> Recursion-only part:
</span></span></span><span class="line"><span class="cl"><span class="cm"> The only implementation details it contains
</span></span></span><span class="line"><span class="cl"><span class="cm"> are about how fact it calling itself
</span></span></span><span class="line"><span class="cl"><span class="cm"> -}</span>
</span></span><span class="line"><span class="cl"><span class="nf">sum</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl"><span class="nf">sum</span> <span class="mi">0</span> <span class="ow">=</span> <span class="n">baseCase</span>
</span></span><span class="line"><span class="cl"><span class="nf">sum</span> <span class="n">n</span> <span class="ow">=</span> <span class="kr">let</span> <span class="n">r</span> <span class="ow">=</span> <span class="n">sum</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="kr">in</span> <span class="n">recCase</span> <span class="n">n</span> <span class="n">r</span></span></span></code></pre></div>
<p>Do you see how similar the recursion-relevant parts of <code>sum</code> and  <code>fact</code> are? They are actually identical! It means
<code>fact</code> and <code>sum</code> have the same recursion structure. The recursion-irrelevant part differ:
the constant <code>baseCase</code> which is <em>1</em> in <code>fact</code> but <em>0</em> in <code>sum</code> and operation <code>recCase</code> which is <code>n * r</code> in <code>fact</code> but
<code>n + r</code> in <code>sum</code>. Note that if we replace, in each case, occurrences of <code>baseRec</code> and <code>recCase</code> by their definition, we
get back the original functions. Look at the common recursive-relevant part:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">commonRecursiveRelevantPart</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">baseCase</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">val</span> <span class="n">r</span> <span class="k">=</span> <span class="n">commonRecursiveRelevantPart</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">recCase</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">commonRecursiveRelevantPart</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl"><span class="nf">commonRecursiveRelevantPart</span> <span class="mi">0</span> <span class="ow">=</span> <span class="n">baseCase</span>
</span></span><span class="line"><span class="cl"><span class="nf">commonRecursiveRelevantPart</span> <span class="n">n</span> <span class="ow">=</span> <span class="kr">let</span> <span class="n">r</span> <span class="ow">=</span> <span class="n">commonRecursiveRelevantPart</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                                <span class="kr">in</span> <span class="n">recCase</span> <span class="n">n</span> <span class="n">r</span></span></span></code></pre></div>
<p>Obviously, for this code to be correct, <code>baseCase</code> and <code>recCase</code> have to be defined. Let&rsquo;s fix this by taking them
as arguments:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">scheme</span><span class="o">(</span><span class="n">baseCase</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">recCase</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">commonRecursiveRelevantPart</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">baseCase</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">r</span> <span class="k">=</span> <span class="n">commonRecursiveRelevantPart</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">recCase</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="n">commonRecursiveRelevantPart</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">scheme</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl"><span class="nf">scheme</span> <span class="n">baseCase</span> <span class="n">recCase</span> <span class="ow">=</span> <span class="n">commonRecursiveRelevantPart</span>
</span></span><span class="line"><span class="cl">  <span class="kr">where</span>
</span></span><span class="line"><span class="cl">    <span class="n">commonRecursiveRelevantPart</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl">    <span class="n">commonRecursiveRelevantPart</span> <span class="mi">0</span> <span class="ow">=</span> <span class="n">baseCase</span>
</span></span><span class="line"><span class="cl">    <span class="n">commonRecursiveRelevantPart</span> <span class="n">n</span> <span class="ow">=</span> <span class="kr">let</span> <span class="n">r</span> <span class="ow">=</span> <span class="n">commonRecursiveRelevantPart</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                                    <span class="kr">in</span> <span class="n">recCase</span> <span class="n">n</span> <span class="n">r</span></span></span></code></pre></div>
<p>It is then trivial to define both <code>fact</code> and <code>sum</code> by feeding <code>scheme</code> with corresponding definitions for <code>baseCase</code> and <code>recCase</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">fact</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="n">scheme</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">r</span><span class="k">:</span><span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">n</span> <span class="o">*</span> <span class="n">r</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">sum</span> <span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="n">scheme</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">r</span><span class="k">:</span><span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">n</span> <span class="o">+</span> <span class="n">r</span><span class="o">)</span></span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">fact</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl"><span class="nf">fact</span> <span class="ow">=</span> <span class="n">scheme</span> <span class="mi">1</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">sum</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl"><span class="nf">sum</span> <span class="ow">=</span> <span class="n">scheme</span> <span class="mi">0</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span></span></span></code></pre></div>
<p>We can now give a first answer to how recursion schemes can be useful. They enable to
to write less code which is both easier and safer. But there is more! Recursive calls, like any
function calls, consume the stack. If there are too many recursive calls (i.e. when <code>n</code> is to big),
there is a risk of stack overflow. Some languages like <em>Scala</em> are smart enough to avoid, in some cases,
this problem by transforming <em>tail-recursive</em> functions into iterative loops.
Unfortunately not all recursive functions are <em>tail-recursive</em>. Writing recursive functions as
iterative loops is not the solution either since it is intricate and error-prone.
Fortunately it is enough to only write the recursion scheme once:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">scheme</span><span class="o">(</span><span class="n">baseCase</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">recCase</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Int</span><span class="o">)(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">var</span> <span class="n">res</span> <span class="k">=</span> <span class="n">baseCase</span>
</span></span><span class="line"><span class="cl">  <span class="k">var</span> <span class="n">i</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">res</span> <span class="k">=</span> <span class="n">recCase</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">res</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">res</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">scheme</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl"><span class="nf">scheme</span> <span class="n">baseCase</span> <span class="n">recCase</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">aux</span> <span class="n">baseCase</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">  <span class="kr">where</span>
</span></span><span class="line"><span class="cl">    <span class="n">aux</span> <span class="n">res</span> <span class="n">i</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span>
</span></span><span class="line"><span class="cl">                <span class="kr">then</span> <span class="n">aux</span> <span class="p">(</span><span class="n">recCase</span> <span class="n">i</span> <span class="n">res</span><span class="p">)</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="kr">else</span> <span class="n">res</span></span></span></code></pre></div>
<p>Note that the scheme is usually simpler to write as it only focuses on recursion, not
business logic. Furthermore one scheme may fit many functions thus reducing the complexity
and bugs in writing business functions. Remember that <code>fact</code> and <code>sum</code> are purposely trivial.
They are just toy example to introduce the subject. In practice you will use much more complex
recursive functions. Once you&rsquo;ve understood this example, you&rsquo;ll be able to scale this technique
to any recursive one, however complex it is.</p>
<h2 id="scaling-up">Scaling up!</h2>
<p>To be sure we have a good understanding of the techniqe, let&rsquo;s apply it to the <em>fibonacci</em> function we all love.
It is defined on <em>non-negative</em> integers by</p>
$$fib(0) = 1$$$$fib(1) = 1$$$$fib(n+2) = fib(n+1) + fib(n)$$<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">fib</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">n</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="mi">0</span> <span class="k">=&gt;</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="mi">1</span> <span class="k">=&gt;</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="n">n</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">r1</span> <span class="k">=</span> <span class="n">fib</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">r2</span> <span class="k">=</span> <span class="n">fib</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">r1</span> <span class="o">+</span> <span class="n">r2</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">fib</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl"><span class="nf">fib</span> <span class="mi">0</span> <span class="ow">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="nf">fib</span> <span class="mi">1</span> <span class="ow">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="nf">fib</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">r1</span> <span class="o">+</span> <span class="n">r2</span>
</span></span><span class="line"><span class="cl">  <span class="kr">where</span>
</span></span><span class="line"><span class="cl">    <span class="n">r1</span> <span class="ow">=</span> <span class="n">fib</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">r2</span> <span class="ow">=</span> <span class="n">fib</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span></span></span></code></pre></div>
<p>The function <code>fib</code> does not call itself when <code>n</code> is <em>0</em> or <em>1</em> but calls itself twice, on <code>n-1</code> and <code>n-2</code> otherwise.
So we can, like <code>fact</code> and <code>sum</code>, split <code>fib</code> into two pieces: one containing only recursion-relevant code and the
other one the rest. Once again the split is done by taking recursion-irrelevant code out of the function&rsquo;s body.
Remember they are many ways to split it up. This one is just one of many sensible way of doing so:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="cm">/* Part irrelevant to recursion:
</span></span></span><span class="line"><span class="cl"><span class="cm"> * The real definitions of these variables
</span></span></span><span class="line"><span class="cl"><span class="cm"> * have no impact on how fact is calling itself
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">baseCase0</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">baseCase1</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">recCase</span><span class="o">(</span><span class="n">r1</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">r2</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">r1</span> <span class="o">+</span> <span class="n">r2</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* Recursion-only part:
</span></span></span><span class="line"><span class="cl"><span class="cm"> * The only implementation details it contains
</span></span></span><span class="line"><span class="cl"><span class="cm"> * are about how fib it calling itself
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">fib</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">n</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="mi">0</span> <span class="k">=&gt;</span> <span class="n">baseCase0</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="mi">1</span> <span class="k">=&gt;</span> <span class="n">baseCase1</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="n">n</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">r1</span> <span class="k">=</span> <span class="n">fib</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">r2</span> <span class="k">=</span> <span class="n">fib</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">recCase</span><span class="o">(</span><span class="n">r1</span><span class="o">,</span> <span class="n">r2</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="cm">{-
</span></span></span><span class="line"><span class="cl"><span class="cm"> Part irrelevant to recursion:
</span></span></span><span class="line"><span class="cl"><span class="cm"> The real definitions of these variables
</span></span></span><span class="line"><span class="cl"><span class="cm"> Have no impact on how fact is calling itself
</span></span></span><span class="line"><span class="cl"><span class="cm">-}</span>
</span></span><span class="line"><span class="cl"><span class="nf">baseCase0</span> <span class="ow">::</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl"><span class="nf">baseCase0</span> <span class="ow">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">baseCase1</span> <span class="ow">::</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl"><span class="nf">baseCase1</span> <span class="ow">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">recCase</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl"><span class="nf">recCase</span> <span class="n">n</span> <span class="n">r</span> <span class="ow">=</span> <span class="n">n</span> <span class="o">+</span> <span class="n">r</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">{-
</span></span></span><span class="line"><span class="cl"><span class="cm"> Recursion-only part:
</span></span></span><span class="line"><span class="cl"><span class="cm"> The only implementation details it contains
</span></span></span><span class="line"><span class="cl"><span class="cm"> are about how fact it calling itself
</span></span></span><span class="line"><span class="cl"><span class="cm"> -}</span>
</span></span><span class="line"><span class="cl"><span class="nf">fib</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl"><span class="nf">fib</span> <span class="mi">0</span> <span class="ow">=</span> <span class="n">baseCase0</span>
</span></span><span class="line"><span class="cl"><span class="nf">fib</span> <span class="mi">1</span> <span class="ow">=</span> <span class="n">baseCase1</span>
</span></span><span class="line"><span class="cl"><span class="nf">fib</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">recCase</span> <span class="n">r1</span> <span class="n">r2</span>
</span></span><span class="line"><span class="cl">  <span class="kr">where</span>
</span></span><span class="line"><span class="cl">    <span class="n">r1</span> <span class="ow">=</span> <span class="n">fib</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">r2</span> <span class="ow">=</span> <span class="n">fib</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span></span></span></code></pre></div>
<p>Which leads to the recursion scheme:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">scheme</span><span class="o">(</span><span class="n">baseCase0</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">baseCase1</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">recCase</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Int</span><span class="o">)(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">n</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="mi">0</span> <span class="k">=&gt;</span> <span class="n">baseCase0</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="mi">1</span> <span class="k">=&gt;</span> <span class="n">baseCase1</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="n">n</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">r1</span> <span class="k">=</span> <span class="n">fib</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">r2</span> <span class="k">=</span> <span class="n">fib</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">recCase</span><span class="o">(</span><span class="n">r1</span><span class="o">,</span> <span class="n">r2</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">scheme</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl"><span class="nf">scheme</span> <span class="n">baseCase0</span> <span class="n">baseCase1</span> <span class="n">recCase</span> <span class="ow">=</span> <span class="n">aux</span>
</span></span><span class="line"><span class="cl">  <span class="kr">where</span>
</span></span><span class="line"><span class="cl">    <span class="n">aux</span> <span class="mi">0</span> <span class="ow">=</span> <span class="n">baseCase0</span>
</span></span><span class="line"><span class="cl">    <span class="n">aux</span> <span class="mi">1</span> <span class="ow">=</span> <span class="n">baseCase1</span>
</span></span><span class="line"><span class="cl">    <span class="n">aux</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">recCase</span> <span class="n">r1</span> <span class="n">r2</span>
</span></span><span class="line"><span class="cl">      <span class="kr">where</span>
</span></span><span class="line"><span class="cl">        <span class="n">r1</span> <span class="ow">=</span> <span class="n">aux</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">r2</span> <span class="ow">=</span> <span class="n">aux</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span></span></span></code></pre></div>
<p>It is then trivial to define <code>fib</code> by giving appropriate definition to <code>scheme</code> arguments: <code>baseCase0</code>, <code>baseCase1</code> and
<code>recCase</code>.</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">fib</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="n">scheme</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">(</span><span class="n">r1</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">r2</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">r1</span> <span class="o">+</span> <span class="n">r2</span><span class="o">)</span></span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">fib</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl"><span class="nf">fib</span> <span class="ow">=</span> <span class="n">scheme</span> <span class="mi">1</span> <span class="mi">1</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span></span></span></code></pre></div>
<p>Once again this implementation is not optimal as each call of <code>fib</code> can make to 2 recursive calls
which leads to an exponential time complexity. While computing <code>fib(5)</code> is fast, computing <code>fib(1000)</code> may
take much longer. As you already probably guessed, writing the recursion scheme as an iterative loop, which
sadly makes it more intricate, solves the problem:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">scheme</span><span class="o">(</span><span class="n">baseCase0</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">baseCase1</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">recCase</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Int</span><span class="o">)(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">baseCase0</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">var</span> <span class="n">b0</span> <span class="k">=</span> <span class="n">baseCase0</span>
</span></span><span class="line"><span class="cl">    <span class="k">var</span> <span class="n">b1</span> <span class="k">=</span> <span class="n">baseCase1</span>
</span></span><span class="line"><span class="cl">    <span class="k">var</span> <span class="n">i</span> <span class="k">=</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">b2</span> <span class="k">=</span> <span class="n">recCase</span><span class="o">(</span><span class="n">b0</span><span class="o">,</span> <span class="n">b1</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">b0</span> <span class="k">=</span> <span class="n">b1</span>
</span></span><span class="line"><span class="cl">      <span class="n">b1</span> <span class="k">=</span> <span class="n">b2</span>
</span></span><span class="line"><span class="cl">      <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">b1</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">scheme</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl"><span class="nf">scheme</span> <span class="n">baseCase0</span> <span class="n">baseCase1</span> <span class="n">recCase</span> <span class="mi">0</span> <span class="ow">=</span> <span class="n">baseCase0</span>
</span></span><span class="line"><span class="cl"><span class="nf">scheme</span> <span class="n">baseCase0</span> <span class="n">baseCase1</span> <span class="n">recCase</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">aux</span> <span class="n">baseCase0</span> <span class="n">baseCase1</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">  <span class="kr">where</span>
</span></span><span class="line"><span class="cl">    <span class="n">aux</span> <span class="n">b0</span> <span class="n">b1</span> <span class="n">i</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span>
</span></span><span class="line"><span class="cl">                  <span class="kr">then</span> <span class="n">aux</span> <span class="n">b1</span> <span class="p">(</span><span class="n">recCase</span> <span class="n">b0</span> <span class="n">b1</span><span class="p">)</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                  <span class="kr">else</span> <span class="n">b1</span></span></span></code></pre></div>
<p>By now you should get a good grasp on what recursion schemes are. But we have
only seen a tiny fraction of how useful they are. It&rsquo;s about time to consider
the real power of <code>fact</code>, <code>sum</code> and <code>fib</code>&rsquo;s schemes.</p>
<h2 id="time-to-take-off">Time to take off!</h2>
<p>Previously we defined <code>fact</code> and <code>sum</code>&rsquo;s schemes as</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">scheme</span><span class="o">(</span><span class="n">baseCase</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">recCase</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Int</span><span class="o">)(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">var</span> <span class="n">res</span> <span class="k">=</span> <span class="n">baseCase</span>
</span></span><span class="line"><span class="cl">  <span class="k">var</span> <span class="n">i</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">res</span> <span class="k">=</span> <span class="n">recCase</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">res</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">res</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">scheme</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl"><span class="nf">scheme</span> <span class="n">baseCase</span> <span class="n">recCase</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">aux</span> <span class="n">baseCase</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">  <span class="kr">where</span>
</span></span><span class="line"><span class="cl">    <span class="n">aux</span> <span class="n">res</span> <span class="n">i</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span>
</span></span><span class="line"><span class="cl">                <span class="kr">then</span> <span class="n">aux</span> <span class="p">(</span><span class="n">recCase</span> <span class="n">i</span> <span class="n">res</span><span class="p">)</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="kr">else</span> <span class="n">res</span></span></span></code></pre></div>
<p>I have a small exercise for you: find where this code relies on <code>baseCase</code> to be an <code>Int</code>?
It&rsquo;s important, take the time to figure it out. The answer is simple: it does not! <code>baseCase</code> can actually be
any of type <code>A</code>! We don&rsquo;t even have to modify the code (only the type signature):</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">scheme</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">baseCase</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">recCase</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">A</span><span class="o">)(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">var</span> <span class="n">res</span> <span class="k">=</span> <span class="n">baseCase</span>
</span></span><span class="line"><span class="cl">  <span class="k">var</span> <span class="n">i</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">res</span> <span class="k">=</span> <span class="n">recCase</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">res</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">res</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">scheme</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl"><span class="nf">scheme</span> <span class="n">baseCase</span> <span class="n">recCase</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">aux</span> <span class="n">baseCase</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">  <span class="kr">where</span>
</span></span><span class="line"><span class="cl">    <span class="n">aux</span> <span class="n">res</span> <span class="n">i</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span>
</span></span><span class="line"><span class="cl">                <span class="kr">then</span> <span class="n">aux</span> <span class="p">(</span><span class="n">recCase</span> <span class="n">i</span> <span class="n">res</span><span class="p">)</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="kr">else</span> <span class="n">res</span></span></span></code></pre></div>
<p>Not only can we still define <code>fact</code> (and <code>sum</code>) like above but it makes trivial defining
the functions like <code>list</code> which returns the list of integers between <em>n</em> and <em>1</em>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">list</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">scheme</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]](</span><span class="nc">Nil</span><span class="o">,</span> <span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">r</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="n">n</span> <span class="k">:</span><span class="kt">:</span> <span class="kt">r</span><span class="o">)</span></span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">list</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">list</span> <span class="ow">=</span> <span class="n">scheme</span> <span class="kt">[]</span> <span class="p">(</span><span class="kt">:</span><span class="p">)</span></span></span></code></pre></div>
<p>Unsurprisingly <code>fib</code>&rsquo;s recursion scheme can also be generalized without changing a single line of code (only type signature):</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">scheme</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">baseCase0</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">baseCase1</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">recCase</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">A</span><span class="o">)(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">baseCase0</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">var</span> <span class="n">b0</span> <span class="k">=</span> <span class="n">baseCase0</span>
</span></span><span class="line"><span class="cl">    <span class="k">var</span> <span class="n">b1</span> <span class="k">=</span> <span class="n">baseCase1</span>
</span></span><span class="line"><span class="cl">    <span class="k">var</span> <span class="n">i</span> <span class="k">=</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">b2</span> <span class="k">=</span> <span class="n">recCase</span><span class="o">(</span><span class="n">b0</span><span class="o">,</span> <span class="n">b1</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">b0</span> <span class="k">=</span> <span class="n">b1</span>
</span></span><span class="line"><span class="cl">      <span class="n">b1</span> <span class="k">=</span> <span class="n">b2</span>
</span></span><span class="line"><span class="cl">      <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">b1</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">scheme</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl"><span class="nf">scheme</span> <span class="n">baseCase0</span> <span class="n">baseCase1</span> <span class="n">recCase</span> <span class="mi">0</span> <span class="ow">=</span> <span class="n">baseCase0</span>
</span></span><span class="line"><span class="cl"><span class="nf">scheme</span> <span class="n">baseCase0</span> <span class="n">baseCase1</span> <span class="n">recCase</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">aux</span> <span class="n">baseCase0</span> <span class="n">baseCase1</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">  <span class="kr">where</span>
</span></span><span class="line"><span class="cl">    <span class="n">aux</span> <span class="n">b0</span> <span class="n">b1</span> <span class="n">i</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span>
</span></span><span class="line"><span class="cl">                  <span class="kr">then</span> <span class="n">aux</span> <span class="n">b1</span> <span class="p">(</span><span class="n">recCase</span> <span class="n">b0</span> <span class="n">b1</span><span class="p">)</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                  <span class="kr">else</span> <span class="n">b1</span></span></span></code></pre></div>
<p>While <code>fact</code>&rsquo;s scheme is related to lists, <code>fib</code>&rsquo;s one is related to trees:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Tree</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Leaf</span><span class="o">[</span><span class="kt">+A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Tree</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Node</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">left</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">right</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Tree</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">tree</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Tree</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">scheme</span><span class="o">(</span>
</span></span><span class="line"><span class="cl">    <span class="nc">Leaf</span><span class="o">(</span><span class="kc">false</span><span class="o">),</span>
</span></span><span class="line"><span class="cl">    <span class="nc">Leaf</span><span class="o">(</span><span class="kc">true</span><span class="o">),</span>
</span></span><span class="line"><span class="cl">    <span class="o">(</span><span class="n">r1</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">],</span> <span class="n">r2</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="nc">Node</span><span class="o">(</span><span class="n">r1</span><span class="o">,</span><span class="n">r2</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">)</span></span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">data</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Leaf</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">Node</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">tree</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Tree</span> <span class="kt">Bool</span>
</span></span><span class="line"><span class="cl"><span class="nf">tree</span> <span class="ow">=</span> <span class="n">scheme</span> <span class="p">(</span><span class="kt">Leaf</span> <span class="kt">False</span><span class="p">)</span> <span class="p">(</span><span class="kt">Leaf</span> <span class="kt">True</span><span class="p">)</span> <span class="kt">Node</span></span></span></code></pre></div>
<p>I have few real exercises for you this time:</p>
<ul>
<li><em>find in your production code several spots where this scheme could be useful.</em></li>
<li><em>write schemes, as general as possible, for at least 5 recursive functions in our production code.</em></li>
</ul>
<p>Obviously I won&rsquo;t check you did the exercises but you should really do them. Reading is not sufficient to
develop your understanding of the technique, you need to experiment! Try things, play with
these notions until it clicks. <strong>Learning recursion schemes is like going on expeditions:
preparation time may seem the easier part but if you did not prepare well enough, you&rsquo;ll get lost.</strong></p>
<h2 id="yeah-buzzwords">Yeah! Buzzwords!</h2>
<p>As we have seen, <code>fact</code>&rsquo;s scheme takes 2 arguments:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">scheme</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">baseCase</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">recCase</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="n">A</span></span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">scheme</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">a</span></span></span></code></pre></div>
<p>While this definition is perfectly ok, we can regroup these argument in any structure that can hold both values like
a pair, an interface or a trait:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">trait</span> <span class="nc">FactorialSchemeArguments</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">val</span> <span class="n">baseCase</span><span class="k">:</span> <span class="kt">A</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">recCase</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">r</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">scheme</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">arguments</span><span class="k">:</span> <span class="kt">FactorialSchemeArguments</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="n">A</span></span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">class</span> <span class="kt">FactorialSchemeArguments</span> <span class="n">a</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  <span class="n">baseCase</span> <span class="ow">::</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl">  <span class="n">recCase</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">scheme</span> <span class="ow">::</span> <span class="kt">FactorialSchemeArguments</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">a</span></span></span></code></pre></div>
<p>Note that <code>scheme</code> is still the same: it still takes the same two arguments.
But even if the code didn&rsquo;t change, this transformation makes us see <code>scheme</code>
from a different perspective. It shows <code>scheme</code> as a functions transforming
an integer to an <code>A</code> provided that we give some structure to  <code>A</code>: a constant
<code>baseCase</code> and an operation <code>recCase</code>. Let&rsquo;s give this structure and the scheme
names: i decide to call the structure a <em>AkolovioaAlgebra</em> (don&rsquo;t look for
it in literature, i just coined the term) and the scheme an <em>akolovioaMorphism</em>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">trait</span> <span class="nc">AkolovioaAlgebra</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">val</span> <span class="n">initial</span><span class="k">:</span> <span class="kt">A</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">action</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">r</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">akolovioaMorphism</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">AkolovioaAlgebra</span><span class="o">]</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="n">A</span></span></span></code></pre></div>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">class</span> <span class="kt">AkolovioaAlgebra</span> <span class="n">a</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  <span class="n">initial</span> <span class="ow">::</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl">  <span class="n">action</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">akolovioaMorphism</span> <span class="ow">::</span> <span class="kt">AkolovioaAlgebra</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">a</span></span></span></code></pre></div>
<p>This looks smart, doesn&rsquo;t it? 😉 It is actually very close to a very common structure in
programming! <em>Will you find which one?</em> Obviously the same can be done for <em>fibonacci</em>&rsquo;s scheme.
<em>As an exercise, apply this technique to fibonacci&rsquo;s scheme and give them pretty names.</em></p>
<h2 id="where-to-go-from-here">Where to go from here?</h2>
<p>As you know this is not the end of the story: the subject is closely related to
pervasive notions such as (co)algebras, inductive types, categories, initial-objects, fixed-points,
algebraic data types, etc. Whichever next subject you choose to dive into, the approach this article follows,
i.e. experimenting on toy examples, really helps developing a solid understanding. I want you to realize
each definition you read in books, articles, talks, etc is the result of people experimenting. The common trap
in this field is looking at definitions as sacred pieces of unquestionable truth no mortal can see through.
It is actually the exact opposite! Science is by essence experimentation. This is by investigating and trying things
you end up figuring out how things work. But, like in science, for your investigation to be productive your tests need
to be done in a controlled environment with as few variables as possible so that it is easy for you to see what&rsquo;s going on.
That&rsquo;s why toy examples are so important: they contain the essence of what makes things work without all the noise
real examples have.</p>
<p>Take care and spread recursion schemes around 😉</p>

  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="demystifying-gadts">Demystifying GADTs</h1>
    <p class="article-meta default"><em>20 Feb 2019 - 3200 Words</em></p>

<p><strong>Generalized Algebraic Data Types (GADT)</strong> is certainly one of the most feared concept in programming nowadays. Very few mainstream languages support GADTs. The only ones i know which does are <a href="https://www.haskell.org/ghc" rel="external" target="_self">Haskell</a>, <a href="https://www.scala-lang.org" rel="external" target="_self">Scala</a>, <a href="https://ocaml.org/index.fr.html" rel="external" target="_self">OCaml</a> and <a href="https://haxe.org" rel="external" target="_self">Haxe</a>. The idea is actually very simple but often presented in complicated ways. In fact, if you&rsquo;re familiar to both basic <em>Object-Oriented-with-Generics</em> and basic <em>functional</em> programming, then you most probably are already familiar with GADTs without even knowing you are. But if GADTs are so simple, why so many people feel terrified by them? Well GADTs rely on two fundamental ideas, one of them is known by every <em>Object-Oriented-with-Generics</em> programmer while the other is known by every <em>functional</em> programmer. The problem is most people make the huge mistake of opposing them even though they are complementary. So before diving into GADTs, let me remind you of these elementary notions from <em>Object-Oriented</em> and <em>functional</em> programming.</p>
<h3 id="object-oriented-programming-101">Object-Oriented Programming 101</h3>
<p>Let&rsquo;s start by some plain old <a href="https://openjdk.java.net" rel="external" target="_self">Java</a> (the examples works in probably all Object-Oriented language which supports generics). We want to define an <em>abstract class</em> for sequences:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">abstract</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Sequence</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">abstract</span><span class="w"> </span><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">length</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">abstract</span><span class="w"> </span><span class="kd">public</span><span class="w"> </span><span class="n">A</span><span class="w">   </span><span class="nf">getNthElement</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">nth</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span></span></span></code></pre></div>
<p>In <em>Java</em> it would be better to define <code>Sequence&lt;A&gt;</code> as an interface but i want this example to be as simple as possible. Would you be surprised if told you a <code>String</code> is a sequence of characters ? ;) As i said, GADTs rely on very basic programming knowledge.</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MyString</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">Sequence</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">private</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">str</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">public</span><span class="w"> </span><span class="nf">MyString</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="na">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">length</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">str</span><span class="p">.</span><span class="na">length</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">public</span><span class="w"> </span><span class="n">Character</span><span class="w"> </span><span class="nf">getNthElement</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">nth</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">str</span><span class="p">.</span><span class="na">charAt</span><span class="p">(</span><span class="n">nth</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span></span></span></code></pre></div>
<p>Likewise, <code>byte</code>s are sequences of 8 bits (we represent a bit by a <code>Boolean</code>):</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MyByte</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">Sequence</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">private</span><span class="w"> </span><span class="kt">byte</span><span class="w"> </span><span class="n">bte</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">public</span><span class="w"> </span><span class="nf">MyByte</span><span class="p">(</span><span class="kt">byte</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="na">bte</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">length</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">8</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">public</span><span class="w"> </span><span class="n">Boolean</span><span class="w"> </span><span class="nf">getNthElement</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">nth</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">nth</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">nth</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">7</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="p">((</span><span class="n">bte</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">nth</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">else</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">java</span><span class="p">.</span><span class="na">lang</span><span class="p">.</span><span class="na">IndexOutOfBoundsException</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span></span></span></code></pre></div>
<p>Have you noticed how <code>MyByte</code> and <code>MyString</code> declares themselves being respectively a sequence of booleans (<code>Sequence&lt;Boolean&gt;</code>) and a sequence of characters (<code>Sequence&lt;Character&gt;</code>) but not sequences of <code>A</code> (<code>Sequence&lt;A&gt;</code>) for any type <code>A</code>? Let&rsquo;s try to make it work for any type <code>A</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MyByte</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">Sequence</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">private</span><span class="w"> </span><span class="kt">byte</span><span class="w"> </span><span class="n">bte</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">public</span><span class="w"> </span><span class="nf">MyByte</span><span class="p">(</span><span class="kt">byte</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="na">bte</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">length</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">???</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">public</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="nf">getNthElement</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">nth</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">???</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span></span></span></code></pre></div>
<p>How would you write the methods <code>length</code> and <code>getNthElement</code>? Do you really imagine what would be a <code>MyByte&lt;Graphics2D&gt;</code>? It just doesn&rsquo;t make any sense at all. You could argue that a string is also a sequence of <code>byte</code> and a byte a sequence of one byte. Indeed this relation is not unique, but it does not change the fact that it works for only a small selection of type <code>A</code> and not every one! We can go even deeper in <em>Object-Oriented Programming</em>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MyArray</span><span class="o">&lt;</span><span class="n">A</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">Number</span><span class="o">&gt;</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">Sequence</span><span class="o">&lt;</span><span class="n">Number</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">private</span><span class="w"> </span><span class="n">A</span><span class="o">[]</span><span class="w"> </span><span class="n">array</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">public</span><span class="w"> </span><span class="nf">MyArray</span><span class="p">(</span><span class="n">A</span><span class="o">[]</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="na">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">length</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">array</span><span class="p">.</span><span class="na">length</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">public</span><span class="w"> </span><span class="n">Number</span><span class="w"> </span><span class="nf">getNthElement</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">nth</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">array</span><span class="o">[</span><span class="n">nth</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span></span></span></code></pre></div>
<p>Note how the generics <code>A</code>, which is required to be a sub-class of <code>Number</code>, is present as argument of <code>MyArray</code> but not in <code>extends Sequence&lt;Number&gt;</code>. Now what do you think about this code? Do you think it can be wrong?</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">guess</span><span class="p">(</span><span class="n">Sequence</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="k">instanceof</span><span class="w"> </span><span class="n">MyByte</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;I guess A is actually Boolean, let&#39;s check!&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(((</span><span class="n">Sequence</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="o">&gt;</span><span class="p">)</span><span class="n">x</span><span class="p">).</span><span class="na">getNthElement</span><span class="p">(</span><span class="n">0</span><span class="p">).</span><span class="na">getClass</span><span class="p">().</span><span class="na">getName</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="k">instanceof</span><span class="w"> </span><span class="n">MyString</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;I guess A is actually Character&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(((</span><span class="n">Sequence</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span><span class="p">)</span><span class="n">x</span><span class="p">).</span><span class="na">getNthElement</span><span class="p">(</span><span class="n">0</span><span class="p">).</span><span class="na">getClass</span><span class="p">().</span><span class="na">getName</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="k">instanceof</span><span class="w"> </span><span class="n">MyArray</span><span class="o">&lt;?&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;I guess A is a sub-class of Number but i can not guess which one&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(((</span><span class="n">Sequence</span><span class="o">&lt;?&gt;</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="p">).</span><span class="na">getNthElement</span><span class="p">(</span><span class="n">0</span><span class="p">).</span><span class="na">getClass</span><span class="p">().</span><span class="na">getName</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">else</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;I don&#39;t know what A is&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span></span></span></code></pre></div>
<ul>
<li>If <code>x</code> is an instance of <code>MyByte</code>, which is a sub-class of <code>Sequence&lt;Boolean&gt;</code>, then by trivial inheritance <code>x</code> is also an instance of <code>Sequence&lt;Boolean&gt;</code>. In this case <code>A</code> is forced to be <code>Boolean</code>.</li>
<li>If <code>x</code> is an instance of <code>MyString</code>, which is a sub-class of <code>Sequence&lt;Character&gt;</code>, then again by trivial inheritance <code>x</code> is also an instance of <code>Sequence&lt;Character&gt;</code> . In this case <code>A</code> has to be <code>Character</code>.</li>
<li>If <code>x</code> is an instance of <code>MyArray&lt;A&gt;</code> for some type <code>A</code>, which is a sub-class of <code>Sequence&lt;Number&gt;</code>, then once again by trivial inheritance <code>x</code> is an instance of <code>Sequence&lt;Number&gt;</code>. In this case we know <code>A</code> is a sub-class of <code>Number</code> but we don&rsquo;t know which one.</li>
</ul>
<p>This is the essence of <em>Generalized Algebraic Data Types</em>. It you understand the code above, then you understand how <em>GADTs</em> work. As you see this is very basic <em>Oriented-Object with Generics</em>. You can find lots of examples of this kind in almost every Java/C#/etc project (search for the <code>instanceof</code> keyword).</p>
<h3 id="functional-programming-101">Functional Programming 101</h3>
<p>Functional languages often support a feature called <strong>Algebraic Data Types (ADT)</strong> which is essentially enumerations on steroids. Like enumerations this is a disjoint union of a fixed number of cases but unlike enumerations, where each case is a constant, ADTs cases can have parameters. As an example, the type of lists whose elements are of type <code>a</code>, written <code>List a</code> in <em>Haskell</em>, is defined:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">data</span> <span class="kt">List</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Nil</span> <span class="o">|</span> <span class="kt">Cons</span> <span class="n">a</span> <span class="p">(</span><span class="kt">List</span> <span class="n">a</span><span class="p">)</span></span></span></code></pre></div>
<p>It means any value of type <code>List a</code> belong to <strong>exactly</strong> one of the following cases:</p>
<ul>
<li>either the value is the constant <code>Nil</code> which represents the empty list.</li>
<li>or the value is <code>Cons hd tl</code> which represent the list whose first element is <code>hd</code> (of type <code>a</code>) and whose tail is <code>tl</code> (of type <code>List a</code>).</li>
</ul>
<p>The list <code>[1,2,3,4]</code> is encoded by <code>Cons 1 (Cons 2 (Cons 3 (Cons 4 Nil)))</code>. Where <em>ADTs</em> really shine is pattern-matching which is a very powerful and flexible <code>switch</code> (as i said above, <em>ADTs</em> are enumerations on steroids). <em>ADTs</em> being made of a fixed number of distinct cases, pattern-matching enable to inspect values and perform computations based on a case by case analysis of the form of the value. Here is how to implement the merge sort algorithm on this type:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">split</span> <span class="ow">::</span> <span class="kt">List</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">List</span> <span class="n">a</span><span class="p">,</span> <span class="kt">List</span> <span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">split</span> <span class="n">l</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">  <span class="kr">case</span> <span class="n">l</span> <span class="kr">of</span>
</span></span><span class="line"><span class="cl">    <span class="kt">Cons</span> <span class="n">x</span> <span class="p">(</span><span class="kt">Cons</span> <span class="n">y</span> <span class="n">tl</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kr">case</span> <span class="n">split</span> <span class="n">tl</span> <span class="kr">of</span>
</span></span><span class="line"><span class="cl">                              <span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Cons</span> <span class="n">x</span> <span class="n">l1</span><span class="p">,</span> <span class="kt">Cons</span> <span class="n">y</span> <span class="n">l2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                          <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="kt">Cons</span> <span class="kr">_</span> <span class="kt">Nil</span>         <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">l</span>  <span class="p">,</span> <span class="kt">Nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="kt">Nil</span>                <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Nil</span><span class="p">,</span> <span class="kt">Nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">merge</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">List</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">List</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">List</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl"><span class="nf">merge</span> <span class="n">isLessThan</span> <span class="n">l1</span> <span class="n">l2</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">  <span class="kr">case</span> <span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">)</span> <span class="kr">of</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="kr">_</span>           <span class="p">,</span> <span class="kt">Nil</span>         <span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">l1</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="kt">Nil</span>         <span class="p">,</span> <span class="kr">_</span>           <span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">l2</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="kt">Cons</span> <span class="n">hd1</span> <span class="n">tl1</span><span class="p">,</span> <span class="kt">Cons</span> <span class="n">hd2</span> <span class="kr">_</span>  <span class="p">)</span> <span class="o">|</span> <span class="n">hd1</span> <span class="p">`</span><span class="n">isLessThan</span><span class="p">`</span> <span class="n">hd2</span> <span class="ow">-&gt;</span>  <span class="kt">Cons</span> <span class="n">hd1</span> <span class="p">(</span><span class="n">merge</span> <span class="n">isLessThan</span> <span class="n">tl1</span> <span class="n">l2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="kr">_</span>           <span class="p">,</span> <span class="kt">Cons</span> <span class="n">hd2</span> <span class="n">tl2</span><span class="p">)</span>                        <span class="ow">-&gt;</span>  <span class="kt">Cons</span> <span class="n">hd2</span> <span class="p">(</span><span class="n">merge</span> <span class="n">isLessThan</span> <span class="n">l1</span> <span class="n">tl2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">sort</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">List</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">List</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl"><span class="nf">sort</span> <span class="n">isLessThan</span> <span class="n">l</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">  <span class="kr">case</span> <span class="n">l</span> <span class="kr">of</span>
</span></span><span class="line"><span class="cl">    <span class="kt">Nil</span>        <span class="ow">-&gt;</span> <span class="kt">Nil</span>
</span></span><span class="line"><span class="cl">    <span class="kt">Cons</span> <span class="kr">_</span> <span class="kt">Nil</span> <span class="ow">-&gt;</span> <span class="n">l</span>
</span></span><span class="line"><span class="cl">    <span class="kr">_</span>          <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="n">split</span> <span class="n">l</span> <span class="kr">of</span>
</span></span><span class="line"><span class="cl">                    <span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">merge</span> <span class="n">isLessThan</span> <span class="p">(</span><span class="n">sort</span> <span class="n">isLessThan</span> <span class="n">l1</span><span class="p">)</span> <span class="p">(</span><span class="n">sort</span> <span class="n">isLessThan</span> <span class="n">l2</span><span class="p">)</span></span></span></code></pre></div>
<p>I know there are smarter ways to write it in <em>Haskell</em> but this article is not about it. The code above could be translated trivially in <code>OCaml</code> by replacing <code>case ... of</code> by <code>match ... with</code>, in <em>Scala</em> by <code>... match { ... }</code>, etc. This style is valid is probably all languages supporting pattern-matching so it fits our goal.</p>
<p>The <code>case l of</code> expressions are pattern-matching. They are a sequence of <code>pattern | condition -&gt; code</code>. The code being executed is the right-hand side of the first case for which the value <code>l</code> is of the form of its pattern and satisfy the condition. <code>l</code> is then said to match this case. For example, the case <code>Cons x (Cons y tl) -&gt; (case split tl of (l1, l2) -&gt; (Cons x l1, Cons y l2))</code> states that if <code>l</code> is of the form <code>Cons x (Cons y tl)</code>, which means that there are three values <code>x</code>, <code>y</code> and <code>tl</code> such that <code>l == Cons x (Cons y tl)</code>, then the code executed is <code>(case split tl of (l1, l2) -&gt; (Cons x l1, Cons y l2))</code>. One very important condition is that <strong>pattern-matching must be exhaustive</strong>! It means that the sequence of cases must cover all possible value of <code>l</code>.</p>
<p>If your understand the previous section, the type <code>List a</code> and how pattern-matching works in the example above, then i am very glad to inform you that you already understand GADTs! Well done :)</p>
<h3 id="summing-up">Summing up!</h3>
<p>In this section i assume previous sections are ok for you. If you do not understand previous examples, don&rsquo;t go further but go back to the basics of <em>generics</em> and <em>pattern-matching</em>. Likewise, if you find what follows complicated, go back to the basics <em>generics</em> and <em>pattern-matching</em>. There is no shame in doing so! Difficulties in understanding advanced notion is often the reflect of a lack of understanding in the ones they rely upon. As i said, there is no shame in it, if you think programming paradigms are &ldquo;simple&rdquo; then write a compiler ;)</p>
<p>It&rsquo;s about time to sum up everything. First, note that <code>List a</code> is not one single type. Each type <code>a</code> actually gives rise to a distinct type <code>List a</code>. For example <code>List Int</code>, <code>List String</code>, <code>List (List Bool)</code>, etc are all distinct types. Indeed the list <code>Cons 1 Nil</code> is neither a list of strings nor of booleans! For each type <code>a</code>, the type <code>List a</code> have two constructors: the constant <code>Nil</code> and the function <code>Cons :: a -&gt; List a -&gt; List a</code> which builds a <code>List a</code> from a value of type <code>a</code> and other <code>List a</code>.</p>
<p>There is another equivalent way to define <code>List a</code> in <em>Haskell</em> which makes the nature of the constructor more apparent:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">data</span> <span class="kt">List</span> <span class="n">a</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  <span class="kt">Nil</span>  <span class="ow">::</span> <span class="kt">List</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl">  <span class="kt">Cons</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">List</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">List</span> <span class="n">a</span></span></span></code></pre></div>
<p>Indeed, for each type <code>a</code>, <code>Nil</code> is constant of type <code>List a</code> while <code>Cons</code> is a function of type <code>a -&gt; List a -&gt; List a</code>. Note that it is actually very close to the way to define it in <em>Scala</em>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Nil</span><span class="o">[</span><span class="kt">A</span><span class="o">]()</span> <span class="k">extends</span> <span class="nc">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Cons</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">head</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span></span></span></code></pre></div>
<p>Do you remember the example of the first section <code>Sequence&lt;A&gt;</code>? There was three sub-classes of <code>Sequence&lt;A</code>: <code>MyString</code> which is actually a sub-class of <code>Sequence&lt;Character&gt;</code>, <code>MyByte</code> which is a sub-class of <code>Sequence&lt;Boolean&gt;</code> and <code>MyArray&lt;A extends Number&gt;</code> which is a sub-class of <code>Sequence&lt;Number&gt;</code>. What is the type of their constructors? Some admissible type for them is (in <em>Scala</em> notation):</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="nc">MyString</span>             <span class="k">:</span> <span class="kt">String</span>   <span class="o">=&gt;</span> <span class="nc">Sequence</span><span class="o">[</span><span class="kt">Character</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nc">MyByte</span>               <span class="k">:</span> <span class="kt">Byte</span>     <span class="o">=&gt;</span> <span class="nc">Sequence</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nc">MyArray</span><span class="o">[</span><span class="kt">A</span> <span class="k">&lt;:</span> <span class="kt">Number</span><span class="o">]</span> <span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Sequence</span><span class="o">[</span><span class="kt">Number</span><span class="o">]</span></span></span></code></pre></div>
<p>From this, this is trivial to write:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Sequence</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">MyString</span><span class="o">(</span><span class="n">str</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>                 <span class="k">extends</span> <span class="nc">Sequence</span><span class="o">[</span><span class="kt">Character</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">MyByte</span><span class="o">(</span><span class="n">bte</span><span class="k">:</span> <span class="kt">Byte</span><span class="o">)</span>                     <span class="k">extends</span> <span class="nc">Sequence</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">MyArray</span><span class="o">[</span><span class="kt">A</span> <span class="k">&lt;:</span> <span class="kt">Number</span><span class="o">](</span><span class="n">array</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Sequence</span><span class="o">[</span><span class="kt">Number</span><span class="o">]</span></span></span></code></pre></div>
<p>or in <em>Haskell</em>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">data</span> <span class="kt">Number</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  <span class="kt">MkNum</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="kt">Num</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Number</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">data</span> <span class="kt">Sequence</span> <span class="n">a</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  <span class="kt">MyString</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Sequence</span> <span class="kt">Char</span>
</span></span><span class="line"><span class="cl">  <span class="kt">MyByte</span>   <span class="ow">::</span> <span class="kt">Word8</span>  <span class="ow">-&gt;</span> <span class="kt">Sequence</span> <span class="kt">Bool</span>
</span></span><span class="line"><span class="cl">  <span class="kt">MyArray</span>  <span class="ow">::</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="kt">Num</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">List</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Sequence</span> <span class="kt">Number</span></span></span></code></pre></div>
<p><code>Sequence</code> is a <em>GADT</em>. What makes it different from <code>List</code> above? For <strong>any type <code>a</code></strong>, values of type <code>List a</code> are build using the two constructors <code>Nil</code> and <code>Cons</code>. Note that it does not depend on what <code>a</code> is. Values of type <code>List Int</code> are build using the exact same constructors than <code>List Bool</code>, <code>List String</code>, <code>List (List Char)</code>, etc. <code>Sequence</code> have three constructors <code>MyString</code>, <code>MyByte</code> and <code>MyArray</code>. But values of type <code>Sequence[Character]</code> can only be built by the constructor <code>MyString</code> while values of type <code>Sequence[Boolean]</code> can only be built by the constructor <code>MyByte</code> and values of type <code>Sequence[Number]</code> can only be built by the constructor <code>MyArray</code>. What about values of type <code>Sequence[Unit]</code> or <code>Sequence[String]</code>, etc? There is simply no constructor to build values of these types, so <em>there is no values of these types</em>!</p>
<p>We can rewrite the methods on <code>Sequence</code> and the <code>guess</code> function to use patten-matching:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">length</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">Sequence</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">MyByte</span><span class="o">(</span><span class="k">_</span><span class="o">)</span>     <span class="k">=&gt;</span> <span class="mi">8</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">MyString</span><span class="o">(</span><span class="n">str</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">str</span><span class="o">.</span><span class="n">length</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">MyArray</span><span class="o">(</span><span class="n">arr</span><span class="o">)</span>  <span class="k">=&gt;</span> <span class="n">arr</span><span class="o">.</span><span class="n">size</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">getNthElement</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">Sequence</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">nth</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">MyByte</span><span class="o">(</span><span class="n">bte</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="c1">// So A is actually Boolean
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span> <span class="o">(</span><span class="n">nth</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nth</span> <span class="o">&lt;=</span> <span class="mi">7</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">(</span><span class="n">bte</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">nth</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">      <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="k">throw</span> <span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">IndexOutOfBoundsException</span><span class="o">(</span><span class="s">&#34;&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">MyString</span><span class="o">(</span><span class="n">str</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="c1">// So A is actually Character
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">str</span><span class="o">.</span><span class="n">charAt</span><span class="o">(</span><span class="n">nth</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">MyArray</span><span class="o">(</span><span class="n">array</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="c1">// So A is actually a sub-class of Number
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">array</span><span class="o">(</span><span class="n">nth</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">guess</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span> <span class="k">:</span> <span class="kt">Sequence</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">MyByte</span><span class="o">(</span><span class="n">bte</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="n">println</span><span class="o">(</span><span class="s">&#34;I guess A is actually Boolean, let&#39;s check!&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">println</span><span class="o">(</span><span class="n">getNthElement</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="mi">0</span><span class="o">).</span><span class="n">getClass</span><span class="o">.</span><span class="n">getName</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">MyString</span><span class="o">(</span><span class="n">str</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="n">println</span><span class="o">(</span><span class="s">&#34;I guess A is actually Character&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">println</span><span class="o">(</span><span class="n">getNthElement</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="mi">0</span><span class="o">).</span><span class="n">getClass</span><span class="o">.</span><span class="n">getName</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">MyArray</span><span class="o">(</span><span class="n">array</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="n">println</span><span class="o">(</span><span class="s">&#34;I guess A is a sub-class of Number but i can not guess which one&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">println</span><span class="o">(</span><span class="n">getNthElement</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="mi">0</span><span class="o">).</span><span class="n">getClass</span><span class="o">.</span><span class="n">getName</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
<p>As you can see <code>getNthElement</code> must returns a value of type <code>A</code> but the case <code>MyByte</code> returns a <code>Boolean</code>. It means <em>Scala</em> is aware that in this case <code>A</code> is actually <em>Boolean</em>. Likewise in the case <code>MyString</code>, <em>Scala</em> knowns that the only possible concrete type for <code>A</code> is <code>Character</code> so it accepts we return one. <em>Scala</em> is (most of the time) able to guess, depending on the case, what are the constraints on <code>A</code>. This is all the magic behind GADTs: specialized constructors like in <em>object-oriented-with-generics</em> programming and closed types (i.e. with a fixed number of cases) on which we can pattern-match like in usual <em>functional</em> programming.</p>
<p>How are <em>GADTs</em> useful? First of all, there are handy when you have a specialized constructor like in every day life <em>object-oriented</em> programming. It makes sense for a byte (resp. string) to be sequence of booleans (resp. characters) but not a sequence of anything. A prolific use of this is writing implicits in Scala as <em>GADTs</em>. This way we can pattern-match on the structure of the implicits to derive instances (see <a href="https://gist.github.com/chrilves/c3db91813cfe693fa708a34f7a27795f" rel="external" target="_self">this gist</a> for more details). They are also very useful to encode properties on types. As i said above, not all types <code>Sequence[A]</code> have (non-null) values! There is no (non-null) value of type <code>Sequence[Unit]</code> or <code>Sequence[String]</code> etc but there are values of type <code>Sequence[Boolean]</code>, <code>Sequence[Character]</code> and <code>Sequence[Number]</code>. So if i give you a value of type <code>Sequence[A]</code>, then you know <code>A</code> is either <code>Boolean</code>, <code>Character</code> or <code>Number</code>. If you don&rsquo;t believe me, try to call the function <code>guess</code> on a type <code>A</code> which is neither <code>Boolean</code> nor <code>Character</code> nor <code>Number</code> (without using <code>null</code>)! Let me give you some useful examples.</p>
<p>The first one is restricting a generic type like in the code below. The <em>GADT</em> <code>IsIntOrString</code> forces <code>A</code> to be either <code>String</code> or <code>Int</code> in the function and the case class.</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">IsIntOrString</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">implicit</span> <span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">IsInt</span>    <span class="k">extends</span> <span class="nc">IsIntOrString</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">implicit</span> <span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">IsString</span> <span class="k">extends</span> <span class="nc">IsIntOrString</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">canOnlyBeCalledOnIntOrString</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">IsIntOrString</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">ev</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">IsInt</span> <span class="k">=&gt;</span> <span class="c1">// A is Int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">a</span> <span class="o">+</span> <span class="mi">7</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">IsString</span> <span class="k">=&gt;</span> <span class="c1">// A is String
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">a</span><span class="o">.</span><span class="n">reverse</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">AStringOrAnIntButNothingElse</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="k">val</span> <span class="n">proof</span> <span class="k">:</span> <span class="kt">IsIntOrString</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span></span></span></code></pre></div>
<p>Another handy use is encoding effects:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">trait</span> <span class="nc">UserId</span>
</span></span><span class="line"><span class="cl"><span class="k">trait</span> <span class="nc">User</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">BusinessEffect</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">GetUser</span><span class="o">(</span><span class="n">userId</span><span class="k">:</span> <span class="kt">UserId</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">BusinessEffect</span><span class="o">[</span><span class="kt">User</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">SetUser</span><span class="o">(</span><span class="n">user</span><span class="k">:</span> <span class="kt">User</span><span class="o">)</span>     <span class="k">extends</span> <span class="nc">BusinessEffect</span><span class="o">[</span><span class="kt">UserId</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">DelUser</span><span class="o">(</span><span class="n">userId</span><span class="k">:</span> <span class="kt">UserId</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">BusinessEffect</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span></span></span></code></pre></div>
<p>Have you ever heard that <code>Set</code> is not a functor? With the usual definition of a functor, indeed <code>Set</code> is not one.</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">trait</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p>The reason is you can only have a <code>Set[A]</code> for types <code>A</code> such that you can compare values. As an example let <code>A</code> be <code>Int =&gt; Int</code>. The two following functions are arguably equal:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">doubleByMult</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">doubleByPlus</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Set</span><span class="o">(</span><span class="n">doubleByMult</span><span class="o">).</span><span class="n">contains</span><span class="o">(</span><span class="n">doubleByPlus</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="n">res0</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span></span></span></code></pre></div>
<p>This is just impossible, in the general case, to know if two functions compute the same thing. I didn&rsquo;t just say we don&rsquo;t know how to do it. It is actually proven that this is impossible (like no one can, and no one could for ever!). Have a look at this <a href="https://en.wikipedia.org/wiki/List_of_undecidable_problems" rel="external" target="_self">List of undecidable problems</a> for more information on the subject. Using extensional equality (the one where <code>f == g</code> <em>if and only</em> <code>f(x) == g(x)</code> for all <code>x</code>), there is just no implementation of <code>Set[Int =&gt; Int]</code>. But if <code>Set</code> was a functor, it would be trivial using <code>map</code> to get a <code>Set[Int =&gt; Int]</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="nc">Set</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">](</span><span class="kc">true</span><span class="o">,</span> <span class="kc">false</span><span class="o">).</span><span class="n">map</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="kc">true</span>  <span class="k">=&gt;</span> <span class="n">doubleByMult</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="kc">false</span> <span class="k">=&gt;</span> <span class="n">doubleByPlus</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span> <span class="k">=&gt;</span> <span class="kt">Int</span><span class="o">]</span></span></span></code></pre></div>
<p>The conclusion is that <code>Set</code> is not a functor &hellip; in the usual (i.e. <em>Scal</em>) category. But it is in for some categories. The problem with <code>Functor</code> is <code>map</code> can be applied on any <code>A</code> and <code>B</code> which is impossible for <code>Set</code>. But if we restrict <code>A</code> and <code>B</code> such that they have interesting properties (like having an <code>Ordering</code>), then it works. In the code below, the <em>GADT</em> <code>predicate</code> is used to restrict on which <code>A</code> and <code>B</code> <code>map</code> can be applied on:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">trait</span> <span class="nc">GenFunctor</span><span class="o">[</span><span class="kt">predicate</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">proofA</span><span class="k">:</span> <span class="kt">predicate</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">proofB</span><span class="k">:</span> <span class="kt">predicate</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p>Then <code>Set</code> is becomes a functor with <code>Ordering</code> as <code>predicate</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">object</span> <span class="nc">SetInstance</span> <span class="k">extends</span> <span class="nc">GenFunctor</span><span class="o">[</span><span class="kt">Ordering</span>, <span class="kt">Set</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">orderingA</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">orderingB</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>  <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">val</span> <span class="n">set</span> <span class="k">=</span> <span class="nc">TreeSet</span><span class="o">.</span><span class="n">newBuilder</span><span class="o">(</span><span class="n">orderingB</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="o">(</span><span class="n">a</span> <span class="k">&lt;-</span> <span class="n">fa</span><span class="o">)</span> <span class="n">set</span> <span class="o">+=</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">set</span><span class="o">.</span><span class="n">result</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p>Surprisingly even <code>String</code> can be a functor (with <code>A</code> and <code>B</code> being both <code>Char</code>)!!!</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">IsItChar</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">implicit</span> <span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">YesItIsChar</span> <span class="k">extends</span> <span class="nc">IsItChar</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">type</span> <span class="kt">StringK</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">String</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">object</span> <span class="nc">StringInstance</span> <span class="k">extends</span> <span class="nc">GenFunctor</span><span class="o">[</span><span class="kt">IsItChar</span>, <span class="kt">StringK</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">String</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">proofA</span><span class="k">:</span> <span class="kt">IsItChar</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">proofB</span><span class="k">:</span> <span class="kt">IsItChar</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="o">(</span><span class="n">proofA</span><span class="o">,</span> <span class="n">proofB</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="o">(</span><span class="nc">YesItIsChar</span><span class="o">,</span> <span class="nc">YesItIsChar</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="c1">// A and B are both Char!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">fa</span><span class="o">.</span><span class="n">toList</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">f</span><span class="o">).</span><span class="n">mkString</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p><em>GADTs</em> are an example of <em>Bushnell&rsquo;s law</em>. As you can see, they are easy to learn but can be used in very tricky situations which makes them hard to master. They are clearly very helpful in many situations but it seems they are still unfortunately very little used. <em>Haskell</em> supports them very well! <em>Scala</em>&rsquo;s support is actually very good but not as good as <em>Haskell</em>&rsquo;s. <em>Scala 3</em> will probably support them as well as <em>Haskell</em> since <em>Dotty</em>&rsquo;s support is excellent. The only two other mainstream languages i know supporting them are <em>OCaml</em> and <em>Haxe</em>. Even if those two have a very good support, their lack of <em>Higer-Kinded types</em> forbids the most interesting uses.</p>
<p>As you probably know, it is possible to define a <code>fold</code> functor for every <em>Algebraic Data Type</em>. It is also possible to define <code>fold</code> functions for every <em>GADT</em>. As an exercise, try to define fold functions for the following <em>GADTs</em>:</p>
<ul>
<li>
<p>This <em>GADT</em> encode the equality between two types <code>A</code> and <code>B</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Eq</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Refl</span><span class="o">[</span><span class="kt">A</span><span class="o">]()</span> <span class="k">extends</span> <span class="nc">Eq</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">A</span><span class="o">]</span></span></span></code></pre></div>
</li>
<li>
<p>This <em>GADT</em> represent an unknown type for which we have an instance of a type-class:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Ex</span><span class="o">[</span><span class="kt">TypeClass</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span>
</span></span><span class="line"><span class="cl"><span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">MakeEx</span><span class="o">[</span><span class="kt">TypeClass</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span><span class="kt">A</span><span class="o">,</span> <span class="n">instance</span><span class="k">:</span> <span class="kt">TypeClass</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Ex</span><span class="o">[</span><span class="kt">TypeClass</span><span class="o">]</span></span></span></code></pre></div>
</li>
</ul>
<p>You&rsquo;ll find how to define such <code>fold</code> functions <a href="https://chrilves.github.io/posts/folds/" rel="external" target="_self">here</a>. Have fun and spread the love of <em>GADTs</em> everywhere :)</p>

  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="lets-meet-the-charming-fold-family">Let&#39;s meet the charming fold family</h1>
    <p class="article-meta default"><em>30 Nov 2018 - 1800 Words</em></p>

<p>Today we will meet an amazing family: the <code>fold</code> functions!</p>
<h2 id="the-well-known-foldright">The well known <code>foldRight</code></h2>
<p><a href="https://en.wikipedia.org/wiki/List_(abstract_data_type)" rel="external" target="_self">Lists</a> is one of the first
data structure every developer/computer scientist meet in her/his journey into programming:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">List</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">Nil</span>                              <span class="k">extends</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">Cons</span><span class="o">[</span><span class="kt">+A</span><span class="o">](</span><span class="n">head</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span></span></span></code></pre></div>
<p>It means means values of type <code>List[A]</code> can be of (only) two forms:</p>
<ul>
<li>either <code>Nil</code></li>
<li>or <code>Cons(head, tail)</code> for some values <code>head</code> of type <code>A</code> and <code>tail</code> of type <code>List[A]</code></li>
</ul>
<p>For example we can define the following lists:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">empty</span> <span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Nil</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">l1</span> <span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Cons</span><span class="o">(</span><span class="mi">61</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">l2</span> <span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Cons</span><span class="o">(</span><span class="mi">34</span><span class="o">,</span> <span class="nc">Cons</span><span class="o">(</span><span class="mi">61</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">))</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">l3</span> <span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Cons</span><span class="o">(</span><span class="s">&#34;a&#34;</span><span class="o">,</span> <span class="nc">Cons</span><span class="o">(</span><span class="s">&#34;b&#34;</span><span class="o">,</span> <span class="nc">Cons</span><span class="o">(</span><span class="s">&#34;c&#34;</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)))</span></span></span></code></pre></div>
<p>In addition, <code>Nil</code> and <code>Cons</code> can be seen as constants and functions returning <code>List[A]</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">nil</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Nil</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">cons</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">head</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Lis</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Cons</span><span class="o">(</span><span class="n">head</span><span class="o">,</span> <span class="n">tail</span><span class="o">)</span></span></span></code></pre></div>
<p>The <strong>fold</strong> function, often called <code>foldRight</code>, answers the question:</p>
<blockquote>
<p><em>What would have happened if, instead of having used <code>Nil</code> and <code>Cons</code> in the construction of a list <code>l:List[A]</code>, we would have used
another constant <code>z:T</code> and another function <code>f:(A, T) =&gt; T</code> for some type <code>T</code>?</em></p>
</blockquote>
<p>Let&rsquo;s illustrate this using the previous examples:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">empty</span> <span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1">// z = 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">v1</span> <span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">max</span><span class="o">(</span><span class="mi">61</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="c1">// z = 0, f = max
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">v2</span> <span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">mult</span><span class="o">(</span><span class="mi">34</span><span class="o">,</span> <span class="n">mult</span><span class="o">(</span><span class="mi">61</span><span class="o">,</span> <span class="mi">1</span><span class="o">))</span> <span class="c1">// z = 1, f = mult
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">v3</span> <span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">concat</span><span class="o">(</span><span class="s">&#34;a&#34;</span><span class="o">,</span> <span class="n">concat</span><span class="o">(</span><span class="s">&#34;b&#34;</span><span class="o">,</span> <span class="n">concat</span><span class="o">(</span><span class="s">&#34;c&#34;</span><span class="o">,</span> <span class="s">&#34;&#34;</span><span class="o">)))</span>
</span></span><span class="line"><span class="cl">  <span class="o">--</span> <span class="n">z</span> <span class="k">=</span> <span class="s">&#34;&#34;</span><span class="o">,</span> <span class="n">f</span> <span class="k">=</span> <span class="n">concat</span></span></span></code></pre></div>
<p>The definition of <code>foldRight</code> illustrates well the transformation process. It deconstructs the list <code>l:List[A]</code>
and replace <code>Nil</code> by <code>z</code> and <code>Cons</code> by <code>f</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">foldList</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">T</span><span class="o">](</span><span class="n">z</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span><span class="kt">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">T</span> <span class="k">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">transform</span><span class="o">(</span><span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="n">l</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="n">z</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">Cons</span><span class="o">(</span><span class="n">head</span><span class="o">,</span> <span class="n">tail</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="k">val</span> <span class="n">transformedTail</span> <span class="k">=</span> <span class="n">transform</span><span class="o">(</span><span class="n">tail</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">f</span><span class="o">(</span><span class="n">head</span><span class="o">,</span> <span class="n">transformedTail</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="n">transform</span> <span class="k">_</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<h2 id="the-simple-cases-enum-types">The simple cases: Enum Types</h2>
<p><code>fold</code> functions can be defined for a wide range of data structures. As a first example, let&rsquo;s take this type:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">SingletonType</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">SingleValue</span> <span class="k">extends</span> <span class="nc">SingletonType</span></span></span></code></pre></div>
<p>The type <code>SingletonType</code> admits one and only one value: <code>SingleValue</code>. Folding over <code>SingletonType</code> means,
replacing <code>SingleValue</code> by a constant <code>z:T</code> for some type <code>T</code> :</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">foldSingletonType</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">z</span><span class="k">:</span><span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">SingletonType</span> <span class="o">=&gt;</span> <span class="n">T</span> <span class="k">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">transform</span><span class="o">(</span><span class="n">v</span><span class="k">:</span> <span class="kt">SingletonType</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="n">v</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">SingleValue</span> <span class="k">=&gt;</span> <span class="n">z</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">transform</span> <span class="k">_</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p>While <code>SingletonType</code> has only one value, the type <code>Boolean</code> have exactly two values <code>True</code> and <code>False</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Boolean</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">True</span>  <span class="k">extends</span> <span class="nc">Boolean</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">False</span> <span class="k">extends</span> <span class="nc">Boolean</span></span></span></code></pre></div>
<p>So folding over <code>Boolean</code>s mean, given a type <code>T</code> and two constants <code>tt:T</code> and <code>ff:T</code>, replacing <code>True</code> by <code>tt</code> and <code>False</code> by <code>ff</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">foldBoolean</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">tt</span><span class="k">:</span><span class="kt">T</span><span class="o">,</span> <span class="n">ff</span><span class="k">:</span><span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=&gt;</span> <span class="n">T</span> <span class="k">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">transform</span><span class="o">(</span><span class="n">v</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="n">v</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">True</span>  <span class="k">=&gt;</span> <span class="n">tt</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">False</span> <span class="k">=&gt;</span> <span class="n">ff</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">transform</span> <span class="k">_</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p>And so on for every <strong>enum type</strong>.</p>
<h2 id="beyond-enums">Beyond enums</h2>
<p>You may start the see general process. If values of type <code>C</code> are build using <strong>constructors</strong> (<code>Nil</code> and <code>Cons[A]</code> for <code>List[A]</code>,
<code>SingleValue</code> for <code>SingletonType</code>, <code>True</code> and <code>False</code> for <code>Boolean</code>), then <strong>folding is all about transforming values of type <code>C</code>
into another type <code>T</code> by replacing each constructor of <code>C</code> by a constant or function on <code>T</code> of the same shape</strong>. Let&rsquo;s consider
the type <code>Either[A,B]</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Either</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Left</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span>  <span class="k">extends</span> <span class="nc">Either</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Right</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Either</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span></span></span></code></pre></div>
<p>To transform values of type <code>Either[A,B]</code> into <code>T</code> we need two functions on <code>T</code>:</p>
<ul>
<li><code>Left</code> being of type <code>A =&gt; Either[A,B]</code> we need a function <code>f: A =&gt; T</code>.</li>
<li><code>Right</code> being of type <code>B =&gt; Either[A,B]</code> we need a function <code>g: B =&gt; T</code>.</li>
</ul>
<p>Then we can operate the transformation:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">foldEither</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span>,<span class="kt">T</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">,</span> <span class="n">g</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">T</span> <span class="k">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">transform</span><span class="o">(</span><span class="n">v</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="n">v</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">Left</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>  <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">Right</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">g</span><span class="o">(</span><span class="n">b</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">transform</span> <span class="k">_</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<h2 id="recursive-types">Recursive Types</h2>
<p>Folding over recursive types obey the previous rules. Recursion is handled by transforming sub-terms first. Let&rsquo;s consider
the type of binary trees:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Tree</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">Empty</span> <span class="k">extends</span> <span class="nc">Tree</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">Node</span><span class="o">[</span><span class="kt">+A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span><span class="kt">A</span><span class="o">,</span> <span class="n">left</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">right</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Tree</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span></span></span></code></pre></div>
<p>To transform values of type <code>Tree[A]</code> into <code>T</code> we need:</p>
<ul>
<li><code>Empty</code> being a constant of type <code>Tree[A]</code>, we need a constant <code>z:T</code>.</li>
<li><code>Node</code> being a function of type <code>(A, Tree[A], Tree[A]) =&gt; Tree[A]</code> we need a function <code>f: (A, T, T) =&gt; T</code>.
Note how all occurrences of <code>Tree[A]</code> have been replaced by <code>T</code> in the type.</li>
</ul>
<p>Then we can operate the transformation:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">foldTree</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">T</span><span class="o">](</span><span class="n">z</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">T</span><span class="o">,</span> <span class="n">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">T</span> <span class="k">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">transform</span><span class="o">(</span><span class="n">v</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="n">v</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">Empty</span> <span class="k">=&gt;</span> <span class="n">z</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">Node</span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">l</span><span class="o">,</span><span class="n">r</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="k">val</span> <span class="n">g</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="n">transform</span><span class="o">(</span><span class="n">l</span><span class="o">)</span> <span class="c1">// Transforming sub-term l
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">val</span> <span class="n">d</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="n">transform</span><span class="o">(</span><span class="n">r</span><span class="o">)</span> <span class="c1">// Transforming sub-term r
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">g</span><span class="o">,</span><span class="n">d</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">transform</span> <span class="k">_</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<h2 id="generalized-algebraic-data-types-gadt">Generalized Algebraic Data Types (GADT)</h2>
<p>Instead of giving a formal definition of what <a href="https://en.wikipedia.org/wiki/Generalized_algebraic_data_type" rel="external" target="_self">Generalized Algebraic Data Types</a>
i will show you some examples.</p>
<h3 id="type-equalities">Type Equalities</h3>
<p>Consider the type:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">EmptyOrSingleton</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">SingleValueIfAisInt</span> <span class="k">extends</span> <span class="nc">EmptyOrSingleton</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span></span></span></code></pre></div>
<p>This type looks very similar to <code>SingletonType</code> but, while <code>SingleValue</code> was <strong>always</strong> a value of <code>SingletonType</code>,
<code>SingleValueIfAisInt</code> is <strong>only</strong> a value of <code>EmptyOrSingleton[Int]</code>, i.e. when <code>A</code> is <code>Int</code>. So what happens to
<code>EmptyOrSingleton[A]</code> when <code>A</code> is not <code>Int</code>? Then there is no constructor for <code>EmptyOrSingleton[A]</code> so no value
for <code>SingletonIfInt[A]</code> (excluding <code>null</code> which we will pretend no to exist).</p>
<p>GADTs are very useful to encode predicates over types. Imagine you have a <strong>value</strong> <code>v:EmptyOrSingleton[A]</code> for
some type <code>A</code>  (remember we pretend <code>null</code> does not exist). What could you say about <code>A</code>? The <strong>only</strong> way to get
a <strong>value</strong> of type <code>EmptyOrSingleton[A]</code> is through <code>SingleValueIfAisInt</code>. Thus <code>v</code> is <code>SingleValueIfAisInt</code>
which is of type <code>EmptyOrSingleton[Int]</code> so is <code>v</code>. We can conclude that <code>A</code> is actually <code>Int</code>. Not convinced?
Let <code>A</code> be <code>String</code>, can you build a <strong>value</strong> of type <code>EmptyOrSingleton[String]</code> without using <code>null</code>? Try it.</p>
<p>To find how to fold <code>EmptyOrSingleton[A]</code> into <code>T</code>, let&rsquo;s apply the technique we used in the previous sections.
<code>EmptyOrSingleton[A]</code> has only one constructor, <code>SingleValueIfAisInt</code>,  so we need a constant <code>z:T</code>. But
<code>SingleValueIfAisInt</code> is not of type <code>EmptyOrSingleton[A]</code> but <code>EmptyOrSingleton[Int]</code>. The argument <code>A</code> matters
so let <code>T</code> depend on <code>A</code>: we want to transform values of type <code>EmptyOrSingleton[A]</code> into <code>T[A]</code>.</p>
<ul>
<li><code>SingleValueIfAisInt</code> being of type <code>EmptyOrSingleton[Int]</code> we need a constant <code>z:T[Int]</code></li>
</ul>
<p>Then we can operate the transformation:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">foldEmptyOrSingleton</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">T</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">z</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">EmptyOrSingleton</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">T</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">transform</span><span class="o">(</span><span class="n">v</span><span class="k">:</span> <span class="kt">EmptyOrSingleton</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="n">v</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">SingleValueIfAisInt</span> <span class="k">=&gt;</span> <span class="n">z</span> <span class="c1">// Because we know A = Int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">transform</span> <span class="k">_</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p><code>foldEmptyOrSingleton</code> means that, for some <code>T[_]</code>, if you have a value <code>z:T[Int]</code> then you can transform any value
<code>EmptyOrSingleton[A]</code> into <code>T[A]</code>. For example, let&rsquo;s take</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">type</span> <span class="kt">T</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span> <span class="k">=</span> <span class="n">X</span> <span class="o">=:=</span> <span class="nc">Int</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">z</span><span class="k">:</span><span class="kt">T</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">Int</span> <span class="kt">=:=</span> <span class="kt">Int</span><span class="o">]</span></span></span></code></pre></div>
<p>Then <code>foldEmptyOrSingleton[A,T](z)</code> gives us, for any value <code>v:EmptyOrSingleton[A]</code> a proof that <code>A =:= Int</code>. Another
important use case is asserting type equality:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Eq</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Refl</span><span class="o">[</span><span class="kt">X</span><span class="o">]()</span> <span class="k">extends</span> <span class="nc">Eq</span><span class="o">[</span><span class="kt">X</span>,<span class="kt">X</span><span class="o">]</span></span></span></code></pre></div>
<p>Any <strong>non-null value</strong> <code>v:Eq[A,B]</code> must be a <code>Refl[X]() : Eq[X,X]</code> for some <code>X</code>, then <code>Eq[A,B] = Eq[X,X]</code> proving that
<code>A = X = B</code>. To transform a value of type <code>Eq[A,B]</code> into <code>T[A,B]</code> we need:</p>
<ul>
<li><code>Refl[X]()</code> is essentially a constant of type <code>Eq[X,X]</code> for all type <code>X</code> (note: <em>Scala</em> write this type <code>[X]Eq[X,X]</code>).
We need a constant <code>z:T[X,X]</code> for all type <code>X</code> (so the type <code>[X]T[X,X]</code>). <em>Scala</em> does not support transparent higher-ranked
types, we need to emulate them with a <code>trait</code>:</li>
</ul>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">trait</span> <span class="nc">ElimRefl</span><span class="o">[</span><span class="kt">T</span><span class="o">[</span><span class="k">_</span>,<span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">X</span>,<span class="kt">X</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p>Then we could have hoped to be able to operate the transformation like previous section. But given a value <code>v:Eq[A,B]</code>,
convincing <em>Scala</em> that <code>A = B</code> is a bit tough. Instead we can write the <code>fold</code> as a method:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Eq</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">T</span><span class="o">[</span><span class="k">_</span>,<span class="k">_</span><span class="o">]](</span><span class="n">z</span><span class="k">:</span> <span class="kt">ElimRefl</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Refl</span><span class="o">[</span><span class="kt">X</span><span class="o">]()</span> <span class="k">extends</span> <span class="nc">Eq</span><span class="o">[</span><span class="kt">X</span>,<span class="kt">X</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">T</span><span class="o">[</span><span class="k">_</span>,<span class="k">_</span><span class="o">]](</span><span class="n">z</span><span class="k">:</span> <span class="kt">ElimRefl</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">X</span>,<span class="kt">X</span><span class="o">]</span> <span class="k">=</span> <span class="n">z</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">foldEq</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">T</span><span class="o">[</span><span class="k">_</span>,<span class="k">_</span><span class="o">]](</span><span class="n">z</span><span class="k">:</span> <span class="kt">ElimRefl</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Eq</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">T</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="o">(</span><span class="n">v</span><span class="k">:</span><span class="kt">Eq</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">fold</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">z</span><span class="o">)</span></span></span></code></pre></div>
<p>Ingenious definition of <code>T[_,_]</code> leads to interesting results:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">trait</span> <span class="nc">C</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nc">type</span> <span class="n">T1</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">C</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">=:=</span> <span class="n">C</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">z1</span><span class="k">:</span> <span class="kt">ElimRefl</span><span class="o">[</span><span class="kt">T1</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="k">new</span> <span class="nc">ElimRefl</span><span class="o">[</span><span class="kt">T1</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span><span class="k">:</span> <span class="kt">T1</span><span class="o">[</span><span class="kt">X</span>,<span class="kt">X</span><span class="o">]</span> <span class="k">=</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">C</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span> <span class="kt">=:=</span> <span class="kt">C</span><span class="o">[</span><span class="kt">X</span><span class="o">]]</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">transform</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span><span class="k">:</span> <span class="kt">Eq</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">C</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">=:=</span> <span class="n">C</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">foldEq</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span>,<span class="kt">T1</span><span class="o">](</span><span class="n">z1</span><span class="o">)</span></span></span></code></pre></div>
<h3 id="existential-quantification">Existential Quantification</h3>
<p>GADTs not only provide useful type equalities, they also offer existential quantification!</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Ex</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">type</span> <span class="kt">hidden</span>
</span></span><span class="line"><span class="cl">  <span class="k">val</span> <span class="n">value</span><span class="k">:</span> <span class="kt">hidden</span>
</span></span><span class="line"><span class="cl">  <span class="k">val</span> <span class="n">evidence</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">hidden</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">MakeEx</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">evidence</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Ex</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">type</span> <span class="kt">hidden</span> <span class="o">=</span> <span class="n">A</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p>Any value <code>v:Ex[F]</code> has to be an instance of <code>MakeEx[F,A]</code> for some type <code>A</code>. Which means we have a value,
<code>v.value</code>, of type <code>A</code> and an instance of the type-class <code>F</code> for <code>A</code> (for example an instance of <code>Monoid[A]</code>
with <code>F[X] = Monoid[X]</code>).</p>
<p>To transform values of type <code>Ex[F]</code> into <code>T</code> we need:</p>
<ul>
<li><code>MakeEx[F[_],?]</code> being of type <code>[A](A, F[A]) =&gt; Ex[F]</code> meaning: <code>For_all_type A, (A, F[A]) =&gt; Ex[F]</code>, we
need a function <code>f</code> of type <code>[A](A, F[A]) =&gt; T</code>. <em>Scala</em> still does not support transparent higher ranked
types, we need to emulate them with another <code>trait</code>:</li>
</ul>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">trait</span> <span class="nc">ElimMakeEx</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">evidence</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p>Then we can operate the transformation:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">foldEx</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">T</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">ElimMakeEx</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Ex</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">T</span> <span class="k">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">transform</span><span class="o">(</span><span class="n">v</span><span class="k">:</span> <span class="kt">Ex</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="n">v</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="n">w</span><span class="nd">@MakeEx</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="n">evidence</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">[</span><span class="kt">w.hidden</span><span class="o">](</span><span class="n">value</span><span class="o">,</span> <span class="n">evidence</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">transform</span> <span class="k">_</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<h2 id="duality">Duality</h2>
<p>In this post we have deduced the <code>fold</code> functions from the definition of each type. It is possible to
do the opposite: each constructor can be derived from the <code>fold</code> function of its type. For example:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">trait</span> <span class="nc">List</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">z</span><span class="k">:</span><span class="kt">T</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span><span class="kt">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">nil</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="k">new</span> <span class="nc">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">z</span><span class="k">:</span><span class="kt">T</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span><span class="kt">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="n">z</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">cons</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">head</span><span class="k">:</span><span class="kt">A</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="k">new</span> <span class="nc">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">z</span><span class="k">:</span><span class="kt">T</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span><span class="kt">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="n">f</span><span class="o">(</span><span class="n">head</span><span class="o">,</span> <span class="n">tail</span><span class="o">.</span><span class="n">fold</span><span class="o">(</span><span class="n">z</span><span class="o">,</span><span class="n">f</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">equality</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">l1</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">l2</span><span class="k">:</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">???</span> <span class="o">//</span> <span class="nc">Difficult</span> <span class="n">but</span> <span class="n">worthy</span> <span class="n">exercice</span></span></span></code></pre></div>
<h2 id="conclusion">Conclusion</h2>
<p>I hope i convinced you folds are immensely useful. First, they let us write simply complex transform functions.
But this not the most interesting property. It is sometimes easier to define a type by its <code>fold</code> function.
<em>Java</em>, for example, does not have support for neither <code>sealed</code> classes nor pattern-matching. How could we define
the <code>List</code> type so that <code>Nil</code> and <code>Cons</code> are the two only cases? The <code>fold</code> function forces any instance of <code>List</code>
to fit into the desired shape (if some rules are obeyed like no <code>null</code> and no runtime-reflection).
It can also happen that type-inference is not smart enough, <code>fold</code> function provide an alternative way which is
often easier for the <code>Scala</code> type-checker.</p>

  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="how-to-make-game-in-the-browser-thanks-to-scalajs">How to make game in the browser thanks to ScalaJS</h1>
    <p class="article-meta default"><em>18 Sep 2018 - 200 Words</em></p>

<p>A few month ago, the <a href="https://www.meetup.com/fr-FR/Paris-Scala-User-Group-PSUG/" rel="external" target="_self">Paris Scala User Group</a> kindly invited me present a <a href="https://www.meetup.com/fr-FR/Paris-Scala-User-Group-PSUG/events/251045516/" rel="external" target="_self">workshop</a> introducing [Scala.js(https://www.scala-js.org/). Even better, i had the chance to present it at <a href="https://scala.io/talks.html#/%23PGM-9348" rel="external" target="_self">ScalaIO 2018</a>. The <a href="../scalajs-workshop">workshop materials are here</a>.</p>
<p>I will present how to develop a web application in Scala.js. This talk is for Scala developers having a penchant for web development but rebuffed by JavaScript. It goes from ScalaJS basics to the implementation of a naive virtual DOM written in Scala. It presents:</p>
<ul>
<li>how to setup Sbt for cross compilation</li>
<li>what is the DOM and how to manipulate it</li>
<li>events and their propagation</li>
<li>the Model/View/Update architecture (a.k.a the ELM architecture)</li>
</ul>
<p>The final result can be experimented with at <a href="../slimetrail">slimetrail</a>. The english material for the ScalaIO workshop are not yet available but the ones for the PSUG workshop, in french are <a href="https://github.com/chrilves/slimetrail.scalajs" rel="external" target="_self">here</a>.</p>
<h2 id="the-applicationhttpschrilvesgithubioslimetrailindexhtml"><a href="https://chrilves.github.io/slimetrail/index.html" rel="external" target="_self">The Application</a></h2>
<iframe width="1024" height="768" src="https://chrilves.github.io/slimetrail/index.html"></iframe>
  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="json-to-xml-the-probably-a-tiny-bit-over-engineered-way">JSON to XML: the probably a tiny bit over engineered way</h1>
    <p class="article-meta default"><em>18 Sep 2018 - 2200 Words</em></p>

<p><strong><a href="../slides/json2xml/json2xml.scala">The complete code of the article</a>. You need  <a href="https://typelevel.org/cats/" rel="external" target="_self">Cats</a> and <a href="https://github.com/playframework/play-json" rel="external" target="_self">Play-Json</a> in order to run it.</strong></p>
<p><strong><a href="../slides/json2xml/index.html">The Slides are here</a></strong></p>
<p>It happens regularly in software development that we have to connect systems speaking different languages. JSON is nowadays ubiquitous in service communication, especially in web development but XML still has its fair amount of bastions. Imagine you need to pass information provided by a JSON API through an XML layer, you need a converter.</p>
<h2 id="the-easy-way">The easy way</h2>
<p>This translation is actually pretty trivial, it takes essentially 6 lines of simple pattern-matching code in <a href="https://www.scala-lang.org/" rel="external" target="_self">Scala</a>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">import</span> <span class="nn">play.api.libs.json._</span>
</span></span><span class="line"><span class="cl"><span class="k">import</span> <span class="nn">scala.xml._</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">json2xml</span><span class="o">(</span><span class="n">json</span><span class="k">:</span> <span class="kt">JsValue</span><span class="o">,</span> <span class="n">rootLabel</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Elem</span> <span class="o">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// XML node creation helper
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">def</span> <span class="n">mkElem</span><span class="o">(</span><span class="n">jsType</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">children</span><span class="k">:</span> <span class="kt">Node*</span><span class="o">)</span><span class="k">:</span> <span class="kt">Elem</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="nc">Elem</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="n">rootLabel</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">         <span class="k">new</span> <span class="nc">UnprefixedAttribute</span><span class="o">(</span><span class="s">&#34;type&#34;</span><span class="o">,</span> <span class="n">jsType</span><span class="o">,</span> <span class="n">scala</span><span class="o">.</span><span class="n">xml</span><span class="o">.</span><span class="nc">Null</span><span class="o">),</span>
</span></span><span class="line"><span class="cl">         <span class="nc">TopScope</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="n">children</span><span class="k">:</span> <span class="k">_</span><span class="kt">*</span>
</span></span><span class="line"><span class="cl">        <span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// The real translation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">json</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">JsNull</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="n">mkElem</span><span class="o">(</span><span class="s">&#34;null&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">JsString</span><span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="n">mkElem</span><span class="o">(</span><span class="s">&#34;string&#34;</span><span class="o">,</span> <span class="nc">PCData</span><span class="o">(</span><span class="n">s</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">JsNumber</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="n">mkElem</span><span class="o">(</span><span class="s">&#34;number&#34;</span><span class="o">,</span> <span class="nc">Text</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="n">toString</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">JsBoolean</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="n">mkElem</span><span class="o">(</span><span class="s">&#34;boolean&#34;</span><span class="o">,</span> <span class="nc">Text</span><span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="n">toString</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">JsArray</span><span class="o">(</span><span class="n">l</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="n">mkElem</span><span class="o">(</span><span class="s">&#34;array&#34;</span><span class="o">,</span> <span class="n">l</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">json2xml</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="s">s&#34;</span><span class="si">${</span><span class="n">rootLabel</span><span class="si">}</span><span class="s">Item&#34;</span><span class="o">))</span><span class="k">:_</span><span class="kt">*</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">JsObject</span><span class="o">(</span><span class="n">m</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="n">mkElem</span><span class="o">(</span><span class="s">&#34;object&#34;</span><span class="o">,</span> <span class="n">m</span><span class="o">.</span><span class="n">toList</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">k</span><span class="o">,</span><span class="n">v</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">json2xml</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">k</span><span class="o">)</span> <span class="o">}</span><span class="k">:</span> <span class="k">_</span><span class="kt">*</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p>The trickiest part of this example is figuring out how to build XML nodes in <em>Scala</em>. It translates the following JSON:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="p">[</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span> <span class="nt">&#34;title&#34;</span><span class="p">:</span> <span class="s2">&#34;2001 : A Space Odyssey&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;release&#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span> <span class="nt">&#34;day&#34;</span><span class="p">:</span> <span class="mi">27</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;month&#34;</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;year&#34;</span><span class="p">:</span> <span class="mi">1968</span>
</span></span><span class="line"><span class="cl">      <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;genres&#34;</span> <span class="p">:</span> <span class="p">[</span> <span class="s2">&#34;Science fiction&#34;</span> <span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;actors&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span> <span class="nt">&#34;lastName&#34;</span><span class="p">:</span> <span class="s2">&#34;Dullea&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;firstName&#34;</span><span class="p">:</span> <span class="s2">&#34;Keir&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;role&#34;</span><span class="p">:</span> <span class="s2">&#34;Dr. David Bowman&#34;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;directors&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span> <span class="nt">&#34;lastName&#34;</span><span class="p">:</span> <span class="s2">&#34;Kubrick&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;firstName&#34;</span><span class="p">:</span> <span class="s2">&#34;Stanley&#34;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span></span></span></code></pre></div>
<p>into</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="nt">&lt;films</span> <span class="na">type=</span><span class="s">&#34;array&#34;</span><span class="nt">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;filmsItem</span> <span class="na">type=</span><span class="s">&#34;object&#34;</span><span class="nt">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;title</span> <span class="na">type=</span><span class="s">&#34;string&#34;</span><span class="nt">&gt;</span><span class="cp">&lt;![CDATA[2001 : A Space Odyssey]]&gt;</span><span class="nt">&lt;/title&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;release</span> <span class="na">type=</span><span class="s">&#34;object&#34;</span><span class="nt">&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;day</span> <span class="na">type=</span><span class="s">&#34;number&#34;</span><span class="nt">&gt;</span>27<span class="nt">&lt;/day&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;month</span> <span class="na">type=</span><span class="s">&#34;number&#34;</span><span class="nt">&gt;</span>9<span class="nt">&lt;/month&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;year</span> <span class="na">type=</span><span class="s">&#34;number&#34;</span><span class="nt">&gt;</span>1968<span class="nt">&lt;/year&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;/release&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;genres</span> <span class="na">type=</span><span class="s">&#34;array&#34;</span><span class="nt">&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;genresItem</span> <span class="na">type=</span><span class="s">&#34;string&#34;</span><span class="nt">&gt;</span><span class="cp">&lt;![CDATA[Science fiction]]&gt;</span><span class="nt">&lt;/genresItem&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;/genres&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;actors</span> <span class="na">type=</span><span class="s">&#34;array&#34;</span><span class="nt">&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;actorsItem</span> <span class="na">type=</span><span class="s">&#34;object&#34;</span><span class="nt">&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;lastName</span> <span class="na">type=</span><span class="s">&#34;string&#34;</span><span class="nt">&gt;</span><span class="cp">&lt;![CDATA[Dullea]]&gt;</span><span class="nt">&lt;/lastName&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;firstName</span> <span class="na">type=</span><span class="s">&#34;string&#34;</span><span class="nt">&gt;</span><span class="cp">&lt;![CDATA[Keir]]&gt;</span><span class="nt">&lt;/firstName&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;role</span> <span class="na">type=</span><span class="s">&#34;string&#34;</span><span class="nt">&gt;</span><span class="cp">&lt;![CDATA[Dr. David Bowman]]&gt;</span><span class="nt">&lt;/role&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;/actorsItem&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;/actors&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;directors</span> <span class="na">type=</span><span class="s">&#34;array&#34;</span><span class="nt">&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;directorsItem</span> <span class="na">type=</span><span class="s">&#34;object&#34;</span><span class="nt">&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;lastName</span> <span class="na">type=</span><span class="s">&#34;string&#34;</span><span class="nt">&gt;</span><span class="cp">&lt;![CDATA[Kubrick]]&gt;</span><span class="nt">&lt;/lastName&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&lt;firstName</span> <span class="na">type=</span><span class="s">&#34;string&#34;</span><span class="nt">&gt;</span><span class="cp">&lt;![CDATA[Stanley]]&gt;</span><span class="nt">&lt;/firstName&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&lt;/directorsItem&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;/directors&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&lt;/filmsItem&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/films&gt;</span></span></span></code></pre></div>
<p>Note that, unlike JSON, XML have no notion of booleans, number or null, so we add type information as attribute on each node. This has the benefit of enabling us to convert such XML back to their former JSON form. Also note that, we need <em>CDATA</em> sections to preserve spaces.</p>
<p>Problem solved? Yes! But we can go much much further on this subject&hellip;</p>
<h2 id="the-rocket-science-way">The Rocket Science way</h2>
<p>There much more thing to say about this example, first let&rsquo;s expose some properties of JSON values.</p>
<h3 id="inviting-coalgebras-to-the-party">Inviting (Co)Algebras to the Party</h3>
<p>JSON values can be modelled with an <a href="https://en.wikipedia.org/wiki/Algebraic_data_type" rel="external" target="_self">Algebraic Data Type</a> or <em>ADT</em> for short. <a href="https://github.com/playframework/play-json" rel="external" target="_self">Play-Json</a> represents them by the type <code>JsValue</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">JsValue</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">JsNull</span> <span class="k">extends</span> <span class="nc">JsValue</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">JsNumber</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">BigDecimal</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">JsValue</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">JsBoolean</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">JsValue</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">JsString</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">JsValue</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">JsArray</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">JsValue</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">JsValue</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">JsObject</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">JsValue</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">JsValue</span></span></span></code></pre></div>
<p>But in order to simplify the presentation, we will use slightly different, but <strong>equivalent</strong>, definition of JSON values:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Atomic</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">Null</span> <span class="k">extends</span> <span class="nc">Atomic</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Bool</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Atomic</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Number</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">BigDecimal</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Atomic</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Str</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Atomic</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">JsValue</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">JsAtom</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">Atomic</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">JsValue</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">JsArray</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">JsValue</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">JsValue</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">JsObject</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">JsValue</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">JsValue</span></span></span></code></pre></div>
<p>Like in any Algebraic Data Type, the <strong>constructors</strong> of <code>JsValues</code> can be seen as operations on it. <code>JsAtom</code> informs us that every number, boolean, string and <code>null</code> give rise to a distinct JSON value. <code>JsArray</code> and <code>JsObject</code> tells us that each (qualified) list of JSON values forms a distinct JSON value itself. Considering that JSON values are defined in terms of these operations, and that we want to translate JSON into XML, it would make sense to define them on XML as well. First, let&rsquo;s explicit these operations:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">JsLike</span><span class="o">[</span><span class="kt">+R</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Atom</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">Atomic</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">JsLike</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Arr</span><span class="o">[</span><span class="kt">+R</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">R</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">JsLike</span><span class="o">[</span><span class="kt">R</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Obj</span><span class="o">[</span><span class="kt">+R</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">R</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">JsLike</span><span class="o">[</span><span class="kt">R</span><span class="o">]</span></span></span></code></pre></div>
<p>The interesting point here is we can translate back and forth between <code>JsValue</code> and <code>JsLike[JsValue]</code>. These translations are even the inverse of each other, meaning both types are totally equivalent!</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">jsLike2JsValue</span><span class="k">:</span> <span class="kt">JsLike</span><span class="o">[</span><span class="kt">JsValue</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">JsValue</span> <span class="k">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nc">Atom</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>         <span class="k">=&gt;</span> <span class="nc">JsAtom</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nc">Arr</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>          <span class="k">=&gt;</span> <span class="nc">JsArray</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nc">Obj</span><span class="o">(</span><span class="n">m</span><span class="o">)</span>          <span class="k">=&gt;</span> <span class="nc">JsObject</span><span class="o">(</span><span class="n">m</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">jsValue2JsLike</span><span class="k">:</span> <span class="kt">JsValue</span> <span class="o">=&gt;</span> <span class="nc">JsLike</span><span class="o">[</span><span class="kt">JsValue</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nc">JsAtom</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>    <span class="k">=&gt;</span> <span class="nc">Atom</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nc">JsArray</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>   <span class="k">=&gt;</span> <span class="nc">Arr</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="n">toList</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nc">JsObject</span><span class="o">(</span><span class="n">m</span><span class="o">)</span>  <span class="k">=&gt;</span> <span class="nc">Obj</span><span class="o">(</span><span class="n">m</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p><code>jsLike2JsValue</code> is called a <code>JsLike</code>-Algebra because it has the form <code>JsLike[X] =&gt; X</code>. It means <code>jsLike2JsValue</code> is a way &ldquo;compute&rdquo; <code>JsLike</code> operation, i.e. it composes values to form new ones. On the opposite, <code>jsValue2JsLike</code> is called a <code>JsLike</code>-CoAlgebra because it has the form <code>X =&gt; JsLike[X]</code>. It is a way to expose how a value is built, i.e. it deconstructs values to expose their structure.</p>
<p>Can we find such functions for XML values? We are looking for two functions:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">jsLike2Elem</span><span class="k">:</span> <span class="kt">JsLike</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Elem</span> <span class="k">=</span> <span class="o">???</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">elem2JsLike</span><span class="k">:</span> <span class="kt">Elem</span> <span class="o">=&gt;</span> <span class="nc">JsLike</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span></span></span></code></pre></div>
<p>It would certainly be nice, but unfortunately this is not that simple! <code>5</code>, <code>true</code> and <code>null</code> are valid JSON values, So <code>jsLike2Elem(Atom(Number(5)))</code>, <code>jsLike2Elem(Atom(Bool(true)))</code> and <code>jsLike2Elem(Atom(Null)))</code> should be valid XML value! But what should be the root tag of the resulting elements? How to translate <code>5</code> into a valid XML? We know that it would have the form:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="nt">&lt;someRootTag</span> <span class="na">type=</span><span class="s">&#34;number&#34;</span><span class="nt">&gt;</span>5<span class="nt">&lt;/someRootTag&gt;</span></span></span></code></pre></div>
<p>But what <code>someRootTag</code> should be? We could pick an arbitrary one, but it would break composability (try it, you&rsquo;ll see!). There&rsquo;s no escape, all XML values need tags but not every JSON value have some! The situation suggest JSON values are closer to &ldquo;XML values with unknown root tags&rdquo; <code>&lt;X type=&quot;number&quot;&gt;5&lt;/X&gt;</code> where <code>X</code> as the unknown, i.e. the functional space <code>String =&gt; Elem</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">_5</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">Elem</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="o">(</span><span class="n">someRootTag</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">&lt;</span><span class="n">someRootTag</span> <span class="n">type</span><span class="o">=</span><span class="s">&#34;number&#34;</span><span class="o">&gt;</span><span class="mi">5</span><span class="o">&lt;/</span><span class="n">someRootTag</span><span class="o">&gt;</span></span></span></code></pre></div>
<p>Do you think we can define meaningful functions?</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">jsLike2xml</span><span class="k">:</span> <span class="kt">JsLike</span><span class="o">[</span><span class="kt">String</span> <span class="k">=&gt;</span> <span class="kt">Elem</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="nc">String</span> <span class="k">=&gt;</span> <span class="nc">Elem</span><span class="o">)</span> <span class="k">=</span> <span class="o">???</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">xml2JsLike</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span> <span class="o">=&gt;</span> <span class="kt">Elem</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">JsLike</span><span class="o">[</span><span class="kt">String</span> <span class="k">=&gt;</span> <span class="kt">Elem</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span></span></span></code></pre></div>
<p>Yes we can &hellip; partially. We can define <code>jsLike2xml</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">jsLike2xml</span><span class="k">:</span> <span class="kt">JsLike</span><span class="o">[</span><span class="kt">String</span> <span class="k">=&gt;</span> <span class="kt">Elem</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="nc">String</span> <span class="k">=&gt;</span> <span class="nc">Elem</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">mkRoot</span><span class="o">(</span><span class="n">jsType</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">children</span><span class="k">:</span> <span class="kt">Node*</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">Elem</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="o">(</span><span class="n">someRootTag</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nc">Elem</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">           <span class="n">someRootTag</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">           <span class="k">new</span> <span class="nc">UnprefixedAttribute</span><span class="o">(</span><span class="s">&#34;type&#34;</span><span class="o">,</span> <span class="n">jsType</span><span class="o">,</span> <span class="n">scala</span><span class="o">.</span><span class="n">xml</span><span class="o">.</span><span class="nc">Null</span><span class="o">),</span>
</span></span><span class="line"><span class="cl">           <span class="nc">TopScope</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">           <span class="kc">true</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">           <span class="n">children</span><span class="k">:</span> <span class="k">_</span><span class="kt">*</span>
</span></span><span class="line"><span class="cl">          <span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">(</span><span class="n">j</span><span class="k">:</span> <span class="kt">JsLike</span><span class="o">[</span><span class="kt">String</span> <span class="k">=&gt;</span> <span class="kt">Elem</span><span class="o">])</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="n">j</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">Atom</span><span class="o">(</span><span class="nc">Null</span><span class="o">)</span>   <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="n">mkRoot</span><span class="o">(</span><span class="s">&#34;null&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">Atom</span><span class="o">(</span><span class="nc">Str</span><span class="o">(</span><span class="n">s</span><span class="o">))</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="n">mkRoot</span><span class="o">(</span><span class="s">&#34;string&#34;</span><span class="o">,</span> <span class="nc">PCData</span><span class="o">(</span><span class="n">s</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">Atom</span><span class="o">(</span><span class="nc">Bool</span><span class="o">(</span><span class="n">b</span><span class="o">))</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="n">mkRoot</span><span class="o">(</span><span class="s">&#34;boolean&#34;</span><span class="o">,</span> <span class="nc">Text</span><span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="n">toString</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">Atom</span><span class="o">(</span><span class="nc">Number</span><span class="o">(</span><span class="n">n</span><span class="o">))</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="n">mkRoot</span><span class="o">(</span><span class="s">&#34;number&#34;</span><span class="o">,</span> <span class="nc">Text</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="n">toString</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">Arr</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="o">(</span><span class="n">root</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">mkRoot</span><span class="o">(</span><span class="s">&#34;array&#34;</span><span class="o">,</span> <span class="n">a</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">(</span><span class="s">s&#34;</span><span class="si">${</span><span class="n">root</span><span class="si">}</span><span class="s">Item&#34;</span><span class="o">))</span><span class="k">:</span> <span class="k">_</span><span class="kt">*</span><span class="o">)(</span><span class="n">root</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">Obj</span><span class="o">(</span><span class="n">m</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="n">mkRoot</span><span class="o">(</span><span class="s">&#34;object&#34;</span><span class="o">,</span> <span class="n">m</span><span class="o">.</span><span class="n">toList</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="o">(</span><span class="n">k</span><span class="o">)</span> <span class="o">}</span><span class="k">:</span> <span class="k">_</span><span class="kt">*</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p>but for <code>xml2JsLike</code>, we&rsquo;re facing two not-that-small issues:</p>
<ul>
<li>
<p>First, unlike<code>jsValue2JsLike</code>, we can not pattern-match on functions. We have no sane way to know that</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl">(someRootTag: String) =&gt; <span class="nt">&lt;someRootTag</span> <span class="na">type=</span><span class="s">&#34;number&#34;</span><span class="nt">&gt;</span>5<span class="nt">&lt;/someRootTag&gt;</span></span></span></code></pre></div>
<p>is built from <code>Atom(Number(5))</code>.</p>
</li>
<li>
<p>Even if we could pattern-match on functions, <code>jsLike2xml</code> is not surjective, i.e. not every XML element is the result of <code>jsLike2xml(f)</code> for some <code>f</code>. To deal with invalid input, the return type of <code>xml2JsLike</code> can not be <code>JsLike[String =&gt; Elem]</code> but <code>F[JsLike[String =&gt; Elem]]</code> for some functor <code>F</code> able to deal with errors like <code>Option</code>, <code>Either</code>, etc. For simplicity&rsquo;s sake, let&rsquo;s consider <code>F</code> to be <code>Option</code>.</p>
</li>
</ul>
<p>Let&rsquo;s once again take a step back. We want to decompose a function <code>(f: String =&gt; Elem)</code> into an <code>Option[JsLike[String =&gt; Elem]]</code> without pattern-matching it. The only reasonable thing we can do with functions is pass them some arguments:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">xml2JsLike</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span> <span class="o">=&gt;</span> <span class="kt">Elem</span><span class="o">))</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">JsLike</span><span class="o">[</span><span class="kt">Elem</span> <span class="k">=&gt;</span> <span class="kt">String</span><span class="o">]]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="o">(</span><span class="n">someRootTag</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">...</span> <span class="n">f</span><span class="o">(</span><span class="n">someRootTag</span><span class="o">)</span> <span class="o">...</span></span></span></code></pre></div>
<p>The type <code>String =&gt; Option[A]</code> is actually a monad, known as a <code>ReaderT[Option, String, A]</code>. Which makes <code>xml2JsLike</code> a monadic coalgebra. Let&rsquo;s give it a name:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">import</span> <span class="nn">cats.data.ReaderT</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">type</span> <span class="kt">TagOpt</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">ReaderT</span><span class="o">[</span><span class="kt">Option</span>, <span class="kt">String</span>, <span class="kt">A</span><span class="o">]</span></span></span></code></pre></div>
<p>As an exercise try to implement <code>xml2JsLike</code>. *To that end, it may be useful to notice that <code>JsLike</code> is a <code>Traverse</code>, i.e. that an instance of <code>Traverse[JsLike]</code> can be defined. Such an instance defines a function:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">`traverse[G[_]: Applicative, A, B](ja: JsLike[A])(f: A =&gt; G[B]): G[JsLike[B]]`</span></span></span></code></pre></div>
<p>To summarize this part, we have these four functions:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">jsLike2JsValue</span><span class="k">:</span> <span class="kt">JsLike</span><span class="o">[</span><span class="kt">JsValue</span><span class="o">]</span>    <span class="k">=&gt;</span> <span class="nc">JsValue</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">jsValue2JsLike</span><span class="k">:</span> <span class="kt">JsValue</span>            <span class="o">=&gt;</span> <span class="nc">JsLike</span><span class="o">[</span><span class="kt">JsValue</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">jsLike2xml</span><span class="k">:</span> <span class="kt">JsLike</span><span class="o">[</span><span class="kt">String</span> <span class="k">=&gt;</span> <span class="kt">Elem</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="nc">String</span> <span class="k">=&gt;</span> <span class="nc">Elem</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">xml2JsLike</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span> <span class="o">=&gt;</span> <span class="kt">Elem</span><span class="o">)</span>       <span class="k">=&gt;</span> <span class="nc">TagOpt</span><span class="o">[</span><span class="kt">JsLike</span><span class="o">[</span><span class="kt">String</span> <span class="k">=&gt;</span> <span class="kt">Elem</span><span class="o">]]</span></span></span></code></pre></div>
<p>Now we want to convert <code>JsValue</code> from/into <code>String =&gt; Elem</code>.</p>
<h4 id="converting-back-and-forth">Converting back and forth</h4>
<p>Now that we know how to compose and decompose both JSON and XML values. How do we write converters? For simplify&rsquo;s sake, let&rsquo;s be a bit more abstract. Let <code>A</code> and <code>B</code> be to types (like <code>JsValue</code> and <code>String =&gt; Elem</code>) and <code>F[_]</code> a type constructor (like <code>JsLike</code>) that have the nice property of being a functor (i.e. it has function <code>map: F[A] =&gt; (A =&gt; B) =&gt; F[B]</code>). In addition, let <code>decomposeA: A =&gt; F[A]</code> and <code>recomposeB: F[B] =&gt; B</code> (like <code>jsValue2JsLike</code> and <code>jsLike2xml</code>). We want a function <code>convert: A =&gt; B</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">trait</span> <span class="nc">Direct</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">import</span> <span class="nn">cats.Functor</span>
</span></span><span class="line"><span class="cl">  <span class="k">import</span> <span class="nn">cats.syntax.functor._</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">type</span> <span class="kt">A</span>
</span></span><span class="line"><span class="cl">  <span class="k">type</span> <span class="kt">B</span>
</span></span><span class="line"><span class="cl">  <span class="k">type</span> <span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">implicit</span> <span class="k">val</span> <span class="n">fHasMap</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">val</span> <span class="n">decomposeA</span><span class="k">:</span> <span class="kt">A</span>    <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">  <span class="k">val</span> <span class="n">recomposeB</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">B</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">final</span> <span class="k">def</span> <span class="n">convert</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">val</span> <span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">decomposeA</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">val</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">fa</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">convert</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">recomposeB</span><span class="o">(</span><span class="n">fb</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p>Or in a more compact way:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">hylo</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span>, <span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Functor</span><span class="o">](</span><span class="n">decompose</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">recompose</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span> <span class="k">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">convert</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="n">recompose</span><span class="o">(</span><span class="n">decompose</span><span class="o">(</span><span class="n">a</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">convert</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">convert</span> <span class="k">_</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p>And voila, a converter in just 1 lines of code:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">json2xml</span><span class="o">(</span><span class="n">json</span><span class="k">:</span> <span class="kt">JsValue</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">Elem</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">hylo</span><span class="o">(</span><span class="n">jsValue2JsLike</span><span class="o">,</span> <span class="n">jsLike2xml</span><span class="o">).</span><span class="n">apply</span><span class="o">(</span><span class="n">json</span><span class="o">)</span></span></span></code></pre></div>
<p>The way back is only a bit more involving. This time we require <code>F</code> to be <code>Traverse</code> and the function <code>decomposeA</code> to be of type <code>A =&gt; M[F[A]]</code> for some monad <code>M</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">trait</span> <span class="nc">WayBack</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">type</span> <span class="kt">A</span>
</span></span><span class="line"><span class="cl">  <span class="k">type</span> <span class="kt">B</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">type</span> <span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">  <span class="k">implicit</span> <span class="k">val</span> <span class="n">fHasTraverse</span><span class="k">:</span> <span class="kt">Traverse</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">type</span> <span class="kt">M</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">  <span class="k">implicit</span> <span class="k">val</span> <span class="n">mIsAMonad</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">M</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">val</span> <span class="n">decomposeA</span><span class="k">:</span> <span class="kt">A</span>    <span class="o">=&gt;</span> <span class="n">M</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span>
</span></span><span class="line"><span class="cl">  <span class="k">val</span> <span class="n">recomposeB</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">B</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">final</span> <span class="k">def</span> <span class="n">convert</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">fa</span> <span class="k">&lt;-</span> <span class="n">decomposeA</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">fb</span> <span class="k">&lt;-</span> <span class="n">fa</span><span class="o">.</span><span class="n">traverse</span><span class="o">(</span><span class="n">convert</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span> <span class="k">yield</span> <span class="n">recomposeB</span><span class="o">(</span><span class="n">fb</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p>Again, in a more compact way:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">hyloish</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span>, <span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Traverse</span>, <span class="kt">M</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span><span class="o">](</span><span class="n">decompose</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">M</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]],</span> <span class="n">recompose</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">M</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">convert</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">fa</span> <span class="k">&lt;-</span> <span class="n">decompose</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">fb</span> <span class="k">&lt;-</span> <span class="n">fa</span><span class="o">.</span><span class="n">traverse</span><span class="o">(</span><span class="n">convert</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span> <span class="k">yield</span> <span class="n">recompose</span><span class="o">(</span><span class="n">fb</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">convert</span> <span class="k">_</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p>which gives the way back as the oneliner:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">xml2json</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">Elem</span><span class="o">)</span><span class="k">:</span> <span class="kt">TagOpt</span><span class="o">[</span><span class="kt">JsValue</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="n">hyloish</span><span class="o">(</span><span class="n">xml2JsLike</span><span class="o">,</span> <span class="n">jsLike2JsValue</span><span class="o">).</span><span class="n">apply</span><span class="o">(</span><span class="n">f</span><span class="o">)</span></span></span></code></pre></div>
<p>Reorganizing a bit, it leads to the two conversion functions between <code>(String, JsValue)</code> and <code>Elem</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">json2xmlBetter</span><span class="k">:</span> <span class="o">((</span><span class="kt">String</span><span class="o">,</span> <span class="kt">JsValue</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="nc">Elem</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="o">(</span><span class="n">jsonPlusTag</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">JsValue</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">json2xml</span><span class="o">(</span><span class="n">jsonPlusTag</span><span class="o">.</span><span class="n">_2</span><span class="o">)(</span><span class="n">jsonPlusTag</span><span class="o">.</span><span class="n">_1</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">xml2jsonBetter</span><span class="k">:</span> <span class="kt">Elem</span> <span class="o">=&gt;</span> <span class="nc">TagOpt</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">JsValue</span><span class="o">)]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Elem</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">xml2json</span><span class="o">((</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">label</span> <span class="k">=</span> <span class="n">s</span><span class="o">)).</span><span class="n">map</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="n">label</span> <span class="o">-&gt;</span> <span class="k">_</span><span class="o">)</span></span></span></code></pre></div>
<h3 id="whats-the-point">What&rsquo;s the point?</h3>
<p>Apart from being so much more complicated that the trivial approach, is there some benefits? Actually yes.</p>
<ul>
<li>Firstly, given <code>n</code> formats, there are <code>n²</code> converters. Writing and testing <code>n²</code> functions is a lot of tedious and error-prone work. But if you find some common operations <code>F[_]</code>, you only need <code>2n</code> functions (one <code>X =&gt; F[X]</code> and one <code>F[X] =&gt; X</code> for each format <code>X</code>) to achieve the same goal. Furthermore, each of those functions will be easier to test, which is not to neglect.</li>
<li>Secondly, algebras (functions <code>X =&gt; F[X]</code>) and coalgebras (functions <code>F[X] =&gt; X</code>) operate one level at a time. They enable to treat format <code>X</code> as if it was an algebraic data type over operations <code>F</code>. Pattern-matching is such a nice feature!</li>
<li>Thirdly, you can write generic functions taking any type <code>X</code> for which you can provide functions <code>X =&gt; F[X]</code> and <code>F[X] =&gt; X</code>. These functions also have higher chances of being correct because there is less space for unexpected behaviour.</li>
</ul>
<p>If want to dive deeper in this subject, you can look at <a href="https://github.com/slamdata/matryoshka" rel="external" target="_self">Matryoshka</a>, read <a href="https://maartenfokkinga.github.io/utwente/mmf91m.pdf" rel="external" target="_self">Functional programming with bananas, lenses, envelopes and barbed wire</a> or any resource on <a href="https://en.wikipedia.org/wiki/F-algebra" rel="external" target="_self">F-Algebras</a> and <em>recursion schemes</em>.</p>
<h3 id="solution-to-exercises">Solution to exercises</h3>
<h4 id="jslike-instance-for-traverse"><code>JsLike</code> instance for <code>Traverse</code></h4>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">implicit</span> <span class="k">val</span> <span class="n">jsLikeInstances</span><span class="k">:</span> <span class="kt">Traverse</span><span class="o">[</span><span class="kt">JsLike</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="k">new</span> <span class="nc">Traverse</span><span class="o">[</span><span class="kt">JsLike</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">import</span> <span class="nn">cats.Eval</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="n">traverse</span><span class="o">[</span><span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">JsLike</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">G</span><span class="o">[</span><span class="kt">B</span><span class="o">])(</span>
</span></span><span class="line"><span class="cl">        <span class="k">implicit</span> <span class="n">G</span><span class="k">:</span> <span class="kt">Applicative</span><span class="o">[</span><span class="kt">G</span><span class="o">])</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">JsLike</span><span class="o">[</span><span class="kt">B</span><span class="o">]]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">fa</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nc">Atom</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">G</span><span class="o">.</span><span class="n">point</span><span class="o">(</span><span class="nc">Atom</span><span class="o">(</span><span class="n">a</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nc">Arr</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>  <span class="k">=&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">traverse</span><span class="o">[</span><span class="kt">G</span>, <span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="nc">Arr</span><span class="o">(</span><span class="k">_</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nc">Obj</span><span class="o">(</span><span class="n">m</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="n">m</span><span class="o">.</span><span class="n">toList</span>
</span></span><span class="line"><span class="cl">            <span class="o">.</span><span class="n">traverse</span><span class="o">[</span><span class="kt">G</span>, <span class="o">(</span><span class="kt">String</span>, <span class="kt">B</span><span class="o">)]</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="k">_</span><span class="o">)</span> <span class="o">}</span>
</span></span><span class="line"><span class="cl">            <span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nc">Obj</span><span class="o">(</span><span class="n">i</span><span class="o">.</span><span class="n">toMap</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">      <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="n">foldLeft</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">JsLike</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">B</span><span class="o">,</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">fa</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nc">Atom</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nc">Arr</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>  <span class="k">=&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="n">b</span><span class="o">)(</span><span class="n">f</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nc">Obj</span><span class="o">(</span><span class="n">m</span><span class="o">)</span>  <span class="k">=&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="n">b</span><span class="o">)(</span><span class="n">f</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="n">foldRight</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">JsLike</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">lb</span><span class="k">:</span> <span class="kt">Eval</span><span class="o">[</span><span class="kt">B</span><span class="o">])(</span>
</span></span><span class="line"><span class="cl">        <span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">Eval</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="nc">Eval</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Eval</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">fa</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nc">Atom</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">lb</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nc">Arr</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>  <span class="k">=&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">foldRight</span><span class="o">(</span><span class="n">lb</span><span class="o">)(</span><span class="n">f</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nc">Obj</span><span class="o">(</span><span class="n">m</span><span class="o">)</span>  <span class="k">=&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">foldRight</span><span class="o">(</span><span class="n">lb</span><span class="o">)(</span><span class="n">f</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="o">}</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
<h4 id="xml2jslike"><code>xml2JsLike</code></h4>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">xml2JsLike</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">Elem</span><span class="o">)</span><span class="k">:</span> <span class="kt">TagOpt</span><span class="o">[</span><span class="kt">JsLike</span><span class="o">[</span><span class="kt">String</span> <span class="k">=&gt;</span> <span class="kt">Elem</span><span class="o">]]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="nc">ReaderT</span><span class="o">[</span><span class="kt">Option</span>, <span class="kt">String</span>, <span class="kt">JsLike</span><span class="o">[</span><span class="kt">String</span> <span class="k">=&gt;</span> <span class="kt">Elem</span><span class="o">]]</span> <span class="o">{</span> <span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="k">val</span> <span class="n">elem</span><span class="k">:</span> <span class="kt">Elem</span> <span class="o">=</span> <span class="n">f</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">elem</span>
</span></span><span class="line"><span class="cl">      <span class="o">.</span><span class="n">attributes</span>
</span></span><span class="line"><span class="cl">      <span class="o">.</span><span class="n">asAttrMap</span>
</span></span><span class="line"><span class="cl">      <span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="s">&#34;type&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="o">.</span><span class="n">flatMap</span><span class="o">[</span><span class="kt">JsLike</span><span class="o">[</span><span class="kt">String</span> <span class="k">=&gt;</span> <span class="kt">Elem</span><span class="o">]]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="s">&#34;null&#34;</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="nc">Some</span><span class="o">(</span><span class="nc">Atom</span><span class="o">(</span><span class="nc">Null</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="s">&#34;boolean&#34;</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="n">elem</span><span class="o">.</span><span class="n">text</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">case</span> <span class="s">&#34;true&#34;</span>  <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Atom</span><span class="o">(</span><span class="nc">Bool</span><span class="o">(</span><span class="kc">true</span><span class="o">)))</span>
</span></span><span class="line"><span class="cl">            <span class="k">case</span> <span class="s">&#34;false&#34;</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Atom</span><span class="o">(</span><span class="nc">Bool</span><span class="o">(</span><span class="kc">false</span><span class="o">)))</span>
</span></span><span class="line"><span class="cl">            <span class="k">case</span> <span class="k">_</span>       <span class="k">=&gt;</span> <span class="nc">None</span>
</span></span><span class="line"><span class="cl">          <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="s">&#34;number&#34;</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="k">import</span> <span class="nn">scala.util.Try</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          <span class="nc">Try</span><span class="o">(</span><span class="nc">BigDecimal</span><span class="o">(</span><span class="n">elem</span><span class="o">.</span><span class="n">text</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">            <span class="o">.</span><span class="n">toOption</span>
</span></span><span class="line"><span class="cl">            <span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">n</span> <span class="k">=&gt;</span> <span class="nc">Atom</span><span class="o">(</span><span class="nc">Number</span><span class="o">(</span><span class="n">n</span><span class="o">)))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="s">&#34;string&#34;</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="nc">Some</span><span class="o">(</span><span class="nc">Atom</span><span class="o">(</span><span class="nc">Str</span><span class="o">(</span><span class="n">elem</span><span class="o">.</span><span class="n">text</span><span class="o">)))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="s">&#34;array&#34;</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="nc">Some</span><span class="o">(</span><span class="nc">Arr</span><span class="o">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">elem</span>
</span></span><span class="line"><span class="cl">              <span class="o">.</span><span class="n">child</span>
</span></span><span class="line"><span class="cl">              <span class="o">.</span><span class="n">toList</span>
</span></span><span class="line"><span class="cl">              <span class="o">.</span><span class="n">flatMap</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">case</span> <span class="n">e</span><span class="k">:</span> <span class="kt">Elem</span> <span class="o">=&gt;</span> <span class="nc">List</span><span class="o">((</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">label</span> <span class="k">=</span> <span class="n">s</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">                <span class="k">case</span> <span class="k">_</span>       <span class="k">=&gt;</span> <span class="nc">Nil</span>
</span></span><span class="line"><span class="cl">              <span class="o">}</span>
</span></span><span class="line"><span class="cl">          <span class="o">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="s">&#34;object&#34;</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="nc">Some</span><span class="o">(</span><span class="nc">Obj</span><span class="o">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">elem</span>
</span></span><span class="line"><span class="cl">              <span class="o">.</span><span class="n">child</span>
</span></span><span class="line"><span class="cl">              <span class="o">.</span><span class="n">toList</span>
</span></span><span class="line"><span class="cl">              <span class="o">.</span><span class="n">flatMap</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">case</span> <span class="n">e</span><span class="k">:</span> <span class="kt">Elem</span> <span class="o">=&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="n">label</span> <span class="o">-&gt;</span> <span class="o">((</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">label</span> <span class="k">=</span> <span class="n">s</span><span class="o">)))</span>
</span></span><span class="line"><span class="cl">                <span class="k">case</span> <span class="k">_</span>       <span class="k">=&gt;</span> <span class="nc">Nil</span>
</span></span><span class="line"><span class="cl">              <span class="o">}.</span><span class="n">toMap</span>
</span></span><span class="line"><span class="cl">          <span class="o">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="nc">None</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>

  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="f-algebra-talk-at-scalaio-2017-modéliser-astucieusement-vos-données">F-Algebra talk at ScalaIO 2017: Modéliser astucieusement vos données</h1>
    <p class="article-meta default"><em>18 Sep 2017 - 100 Words</em></p>

<p>I had the chance to present a talk about <em>F-Algebras</em> at <a href="https://scala.io/2017/talks.html#/%23SJO-8794" rel="external" target="_self">ScalaIO 2017</a>.</p>
<h2 id="the-video">The Video</h2>
<iframe width="1024" height="768" src="https://www.youtube.com/embed/MfxN6oSLKDU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>  
<h2 id="the-slidesslidesf-algebra-talk"><a href="../slides/f-algebra-talk/">The Slides</a></h2>
<iframe width="1024" height="768" src="../slides/f-algebra-talk/"></iframe>

  <footer class="footline">
  </footer>
</article>
          </section>
        </div>
      </main>
    </div>
    <script src="../js/clipboard.min.js?1731043964" defer></script>
    <script src="../js/perfect-scrollbar.min.js?1731043964" defer></script>
    <script>
      function useMathJax( config ){
        window.MathJax = Object.assign( window.MathJax || {}, {
          tex: {
            inlineMath:  [['\\(', '\\)'], ['$',  '$']],  
            displayMath: [['\\[', '\\]'], ['$$', '$$']], 
          },
          options: {
            enableMenu: false 
          }
        }, config );
      }
      useMathJax( JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="../js/mathjax/tex-mml-chtml.js?1731043964"></script>
    <script src="../js/theme.js?1731043964" defer></script>
  </body>
</html>
