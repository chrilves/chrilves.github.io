<!DOCTYPE html>
<html lang="en" dir="ltr" itemscope itemtype="http://schema.org/Article">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.136.3">
    <meta name="generator" content="Relearn 7.0.1+72a875f1db967152c77914cff4d53f8fcee0e619">
    <meta name="description" content="Introduction to catamorphisms on Algebraic Data Types">
    <meta name="author" content="chrilves">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Let&#39;s meet the charming fold family :: @chrilves&#39; Archives">
    <meta name="twitter:description" content="Introduction to catamorphisms on Algebraic Data Types">
  <meta name="twitter:site" content="@chrilves"/>
    <meta property="og:url" content="https://chrilves.github.io/posts/folds/index.html">
    <meta property="og:site_name" content="@chrilves&#39; Archives">
    <meta property="og:title" content="Let&#39;s meet the charming fold family :: @chrilves&#39; Archives">
    <meta property="og:description" content="Introduction to catamorphisms on Algebraic Data Types">
    <meta property="og:locale" content="en">
    <meta property="og:type" content="article">
    <meta property="article:section" content="Posts">
    <meta property="article:published_time" content="2018-11-30T14:13:12+01:00">
    <meta property="article:modified_time" content="2018-11-30T14:13:12+01:00">
    <meta itemprop="name" content="Let&#39;s meet the charming fold family :: @chrilves&#39; Archives">
    <meta itemprop="description" content="Introduction to catamorphisms on Algebraic Data Types">
    <meta itemprop="datePublished" content="2018-11-30T14:13:12+01:00">
    <meta itemprop="dateModified" content="2018-11-30T14:13:12+01:00">
    <meta itemprop="wordCount" content="1773">
    <meta itemprop="keywords" content="GADT,Types,Functor,Algebra,CoAlgebra,Recursion,Scheme,Inductive,Category Theory">
    <title>Let&#39;s meet the charming fold family :: @chrilves&#39; Archives</title>
    <link href="https://chrilves.github.io/posts/folds/index.html" rel="canonical" type="text/html" title="Let&#39;s meet the charming fold family :: @chrilves&#39; Archives">
    <link href="../../posts/folds/index.xml" rel="alternate" type="application/rss+xml" title="Let&#39;s meet the charming fold family :: @chrilves&#39; Archives">
    <link href="../../css/fontawesome-all.min.css?1729693097" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../css/fontawesome-all.min.css?1729693097" rel="stylesheet"></noscript>
    <link href="../../css/nucleus.css?1729693097" rel="stylesheet">
    <link href="../../css/auto-complete.css?1729693097" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../css/auto-complete.css?1729693097" rel="stylesheet"></noscript>
    <link href="../../css/perfect-scrollbar.min.css?1729693097" rel="stylesheet">
    <link href="../../css/fonts.css?1729693097" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../css/fonts.css?1729693097" rel="stylesheet"></noscript>
    <link href="../../css/theme.css?1729693097" rel="stylesheet">
    <link href="../../css/theme-relearn-auto.css?1729693097" rel="stylesheet" id="R-variant-style">
    <link href="../../css/chroma-relearn-auto.css?1729693097" rel="stylesheet" id="R-variant-chroma-style">
    <link href="../../css/print.css?1729693097" rel="stylesheet" media="print">
    <link href="../../css/format-print.css?1729693097" rel="stylesheet">
    <script src="../../js/variant.js?1729693097"></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.relBasePath='..\/..';
      window.relearn.relBaseUri='..\/..';
      window.relearn.absBaseUri='https:\/\/chrilves.github.io';
      window.relearn.disableAnchorCopy=false;
      window.relearn.disableAnchorScrolling=false;
      // variant stuff
      window.variants && variants.init( [ 'relearn-auto', 'relearn-light', 'relearn-dark', 'relearn-bright', 'zen-auto', 'zen-light', 'zen-dark', 'retro-auto', 'neon', 'learn', 'blue', 'green', 'red' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script>
  </head>
  <body class="mobile-support print disableInlineCopyToClipboard" data-url="../../posts/folds/index.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide"><button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)"><i class="fa-fw fas fa-bars"></i></button>
            </div>
            <div class="topbar-button topbar-button-toc" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="Table of Contents (CTRL&#43;ALT&#43;t)"><i class="fa-fw fas fa-list-alt"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper">
<nav class="TableOfContents">
  <ul>
    <li><a href="#the-well-known-foldright">The well known <code>foldRight</code></a></li>
    <li><a href="#the-simple-cases-enum-types">The simple cases: Enum Types</a></li>
    <li><a href="#beyond-enums">Beyond enums</a></li>
    <li><a href="#recursive-types">Recursive Types</a></li>
    <li><a href="#generalized-algebraic-data-types-gadt">Generalized Algebraic Data Types (GADT)</a>
      <ul>
        <li><a href="#type-equalities">Type Equalities</a></li>
        <li><a href="#existential-quantification">Existential Quantification</a></li>
      </ul>
    </li>
    <li><a href="#duality">Duality</a></li>
    <li><a href="#conclusion">Conclusion</a></li>
  </ul>
</nav>
                </div>
              </div>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="../../posts/index.html"><span itemprop="name">Posts</span></a><meta itemprop="position" content="1">&nbsp;>&nbsp;</li><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">Let&#39;s meet the charming fold family</span><meta itemprop="position" content="2"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
            <div class="topbar-button topbar-button-edit" data-content-empty="disable" data-width-s="area-more" data-width-m="show" data-width-l="show"><a class="topbar-control" href="https://github.com/chrilves/chrilves.github.io/edit/master/hugo/content/posts/folds.md" target="_self" title="Edit (CTRL&#43;ALT&#43;w)"><i class="fa-fw fas fa-pen"></i></a>
            </div>
            <div class="topbar-button topbar-button-print" data-content-empty="disable" data-width-s="area-more" data-width-m="show" data-width-l="show"><a class="topbar-control" href="../../posts/folds/index.print.html" title="Print whole chapter (CTRL&#43;ALT&#43;p)"><i class="fa-fw fas fa-print"></i></a>
            </div>
            <div class="topbar-button topbar-button-prev" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="../../posts/gadts_intro/index.html" title="Demystifying GADTs (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a>
            </div>
            <div class="topbar-button topbar-button-next" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="../../posts/slimetrail/index.html" title="How to make game in the browser thanks to ScalaJS (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a>
            </div>
            <div class="topbar-button topbar-button-more" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="More"><i class="fa-fw fas fa-ellipsis-v"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper">
                  <div class="topbar-area topbar-area-more" data-area="more">
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable posts" tabindex="-1">
        <div class="flex-block-wrapper">
<article class="default">
  <header class="headline">
  </header>

<h1 id="lets-meet-the-charming-fold-family">Let&#39;s meet the charming fold family</h1>
    <p class="article-meta default"><em>Fri, Nov 30, 2018 - 1800 Words</em></p>

<p>Today we will meet an amazing family: the <code>fold</code> functions!</p>
<h2 id="the-well-known-foldright">The well known <code>foldRight</code></h2>
<p><a href="https://en.wikipedia.org/wiki/List_(abstract_data_type)" rel="external" target="_self">Lists</a> is one of the first
data structure every developer/computer scientist meet in her/his journey into programming:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">List</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">Nil</span>                              <span class="k">extends</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">Cons</span><span class="o">[</span><span class="kt">+A</span><span class="o">](</span><span class="n">head</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span></span></span></code></pre></div>
<p>It means means values of type <code>List[A]</code> can be of (only) two forms:</p>
<ul>
<li>either <code>Nil</code></li>
<li>or <code>Cons(head, tail)</code> for some values <code>head</code> of type <code>A</code> and <code>tail</code> of type <code>List[A]</code></li>
</ul>
<p>For example we can define the following lists:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">empty</span> <span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Nil</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">l1</span> <span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Cons</span><span class="o">(</span><span class="mi">61</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">l2</span> <span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Cons</span><span class="o">(</span><span class="mi">34</span><span class="o">,</span> <span class="nc">Cons</span><span class="o">(</span><span class="mi">61</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">))</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">l3</span> <span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Cons</span><span class="o">(</span><span class="s">&#34;a&#34;</span><span class="o">,</span> <span class="nc">Cons</span><span class="o">(</span><span class="s">&#34;b&#34;</span><span class="o">,</span> <span class="nc">Cons</span><span class="o">(</span><span class="s">&#34;c&#34;</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)))</span></span></span></code></pre></div>
<p>In addition, <code>Nil</code> and <code>Cons</code> can be seen as constants and functions returning <code>List[A]</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">nil</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Nil</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">cons</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">head</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Lis</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Cons</span><span class="o">(</span><span class="n">head</span><span class="o">,</span> <span class="n">tail</span><span class="o">)</span></span></span></code></pre></div>
<p>The <strong>fold</strong> function, often called <code>foldRight</code>, answers the question:</p>
<blockquote>
<p><em>What would have happened if, instead of having used <code>Nil</code> and <code>Cons</code> in the construction of a list <code>l:List[A]</code>, we would have used
another constant <code>z:T</code> and another function <code>f:(A, T) =&gt; T</code> for some type <code>T</code>?</em></p>
</blockquote>
<p>Let&rsquo;s illustrate this using the previous examples:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">empty</span> <span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1">// z = 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">v1</span> <span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">max</span><span class="o">(</span><span class="mi">61</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="c1">// z = 0, f = max
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">v2</span> <span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">mult</span><span class="o">(</span><span class="mi">34</span><span class="o">,</span> <span class="n">mult</span><span class="o">(</span><span class="mi">61</span><span class="o">,</span> <span class="mi">1</span><span class="o">))</span> <span class="c1">// z = 1, f = mult
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">val</span> <span class="n">v3</span> <span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">concat</span><span class="o">(</span><span class="s">&#34;a&#34;</span><span class="o">,</span> <span class="n">concat</span><span class="o">(</span><span class="s">&#34;b&#34;</span><span class="o">,</span> <span class="n">concat</span><span class="o">(</span><span class="s">&#34;c&#34;</span><span class="o">,</span> <span class="s">&#34;&#34;</span><span class="o">)))</span>
</span></span><span class="line"><span class="cl">  <span class="o">--</span> <span class="n">z</span> <span class="k">=</span> <span class="s">&#34;&#34;</span><span class="o">,</span> <span class="n">f</span> <span class="k">=</span> <span class="n">concat</span></span></span></code></pre></div>
<p>The definition of <code>foldRight</code> illustrates well the transformation process. It deconstructs the list <code>l:List[A]</code>
and replace <code>Nil</code> by <code>z</code> and <code>Cons</code> by <code>f</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">foldList</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">T</span><span class="o">](</span><span class="n">z</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span><span class="kt">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">T</span> <span class="k">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">transform</span><span class="o">(</span><span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="n">l</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="n">z</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">Cons</span><span class="o">(</span><span class="n">head</span><span class="o">,</span> <span class="n">tail</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="k">val</span> <span class="n">transformedTail</span> <span class="k">=</span> <span class="n">transform</span><span class="o">(</span><span class="n">tail</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">f</span><span class="o">(</span><span class="n">head</span><span class="o">,</span> <span class="n">transformedTail</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="n">transform</span> <span class="k">_</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<h2 id="the-simple-cases-enum-types">The simple cases: Enum Types</h2>
<p><code>fold</code> functions can be defined for a wide range of data structures. As a first example, let&rsquo;s take this type:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">SingletonType</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">SingleValue</span> <span class="k">extends</span> <span class="nc">SingletonType</span></span></span></code></pre></div>
<p>The type <code>SingletonType</code> admits one and only one value: <code>SingleValue</code>. Folding over <code>SingletonType</code> means,
replacing <code>SingleValue</code> by a constant <code>z:T</code> for some type <code>T</code> :</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">foldSingletonType</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">z</span><span class="k">:</span><span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">SingletonType</span> <span class="o">=&gt;</span> <span class="n">T</span> <span class="k">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">transform</span><span class="o">(</span><span class="n">v</span><span class="k">:</span> <span class="kt">SingletonType</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="n">v</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">SingleValue</span> <span class="k">=&gt;</span> <span class="n">z</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">transform</span> <span class="k">_</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p>While <code>SingletonType</code> has only one value, the type <code>Boolean</code> have exactly two values <code>True</code> and <code>False</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Boolean</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">True</span>  <span class="k">extends</span> <span class="nc">Boolean</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">False</span> <span class="k">extends</span> <span class="nc">Boolean</span></span></span></code></pre></div>
<p>So folding over <code>Boolean</code>s mean, given a type <code>T</code> and two constants <code>tt:T</code> and <code>ff:T</code>, replacing <code>True</code> by <code>tt</code> and <code>False</code> by <code>ff</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">foldBoolean</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">tt</span><span class="k">:</span><span class="kt">T</span><span class="o">,</span> <span class="n">ff</span><span class="k">:</span><span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=&gt;</span> <span class="n">T</span> <span class="k">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">transform</span><span class="o">(</span><span class="n">v</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="n">v</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">True</span>  <span class="k">=&gt;</span> <span class="n">tt</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">False</span> <span class="k">=&gt;</span> <span class="n">ff</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">transform</span> <span class="k">_</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p>And so on for every <strong>enum type</strong>.</p>
<h2 id="beyond-enums">Beyond enums</h2>
<p>You may start the see general process. If values of type <code>C</code> are build using <strong>constructors</strong> (<code>Nil</code> and <code>Cons[A]</code> for <code>List[A]</code>,
<code>SingleValue</code> for <code>SingletonType</code>, <code>True</code> and <code>False</code> for <code>Boolean</code>), then <strong>folding is all about transforming values of type <code>C</code>
into another type <code>T</code> by replacing each constructor of <code>C</code> by a constant or function on <code>T</code> of the same shape</strong>. Let&rsquo;s consider
the type <code>Either[A,B]</code>:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Either</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Left</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span>  <span class="k">extends</span> <span class="nc">Either</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Right</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Either</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span></span></span></code></pre></div>
<p>To transform values of type <code>Either[A,B]</code> into <code>T</code> we need two functions on <code>T</code>:</p>
<ul>
<li><code>Left</code> being of type <code>A =&gt; Either[A,B]</code> we need a function <code>f: A =&gt; T</code>.</li>
<li><code>Right</code> being of type <code>B =&gt; Either[A,B]</code> we need a function <code>g: B =&gt; T</code>.</li>
</ul>
<p>Then we can operate the transformation:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">foldEither</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span>,<span class="kt">T</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">,</span> <span class="n">g</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">T</span> <span class="k">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">transform</span><span class="o">(</span><span class="n">v</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="n">v</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">Left</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>  <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">Right</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">g</span><span class="o">(</span><span class="n">b</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">transform</span> <span class="k">_</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<h2 id="recursive-types">Recursive Types</h2>
<p>Folding over recursive types obey the previous rules. Recursion is handled by transforming sub-terms first. Let&rsquo;s consider
the type of binary trees:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Tree</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">Empty</span> <span class="k">extends</span> <span class="nc">Tree</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">Node</span><span class="o">[</span><span class="kt">+A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span><span class="kt">A</span><span class="o">,</span> <span class="n">left</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">right</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Tree</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span></span></span></code></pre></div>
<p>To transform values of type <code>Tree[A]</code> into <code>T</code> we need:</p>
<ul>
<li><code>Empty</code> being a constant of type <code>Tree[A]</code>, we need a constant <code>z:T</code>.</li>
<li><code>Node</code> being a function of type <code>(A, Tree[A], Tree[A]) =&gt; Tree[A]</code> we need a function <code>f: (A, T, T) =&gt; T</code>.
Note how all occurrences of <code>Tree[A]</code> have been replaced by <code>T</code> in the type.</li>
</ul>
<p>Then we can operate the transformation:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">foldTree</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">T</span><span class="o">](</span><span class="n">z</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">T</span><span class="o">,</span> <span class="n">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">T</span> <span class="k">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">transform</span><span class="o">(</span><span class="n">v</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="n">v</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">Empty</span> <span class="k">=&gt;</span> <span class="n">z</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">Node</span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">l</span><span class="o">,</span><span class="n">r</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="k">val</span> <span class="n">g</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="n">transform</span><span class="o">(</span><span class="n">l</span><span class="o">)</span> <span class="c1">// Transforming sub-term l
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">val</span> <span class="n">d</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="n">transform</span><span class="o">(</span><span class="n">r</span><span class="o">)</span> <span class="c1">// Transforming sub-term r
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">g</span><span class="o">,</span><span class="n">d</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">transform</span> <span class="k">_</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<h2 id="generalized-algebraic-data-types-gadt">Generalized Algebraic Data Types (GADT)</h2>
<p>Instead of giving a formal definition of what <a href="https://en.wikipedia.org/wiki/Generalized_algebraic_data_type" rel="external" target="_self">Generalized Algebraic Data Types</a>
i will show you some examples.</p>
<h3 id="type-equalities">Type Equalities</h3>
<p>Consider the type:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">EmptyOrSingleton</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">SingleValueIfAisInt</span> <span class="k">extends</span> <span class="nc">EmptyOrSingleton</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span></span></span></code></pre></div>
<p>This type looks very similar to <code>SingletonType</code> but, while <code>SingleValue</code> was <strong>always</strong> a value of <code>SingletonType</code>,
<code>SingleValueIfAisInt</code> is <strong>only</strong> a value of <code>EmptyOrSingleton[Int]</code>, i.e. when <code>A</code> is <code>Int</code>. So what happens to
<code>EmptyOrSingleton[A]</code> when <code>A</code> is not <code>Int</code>? Then there is no constructor for <code>EmptyOrSingleton[A]</code> so no value
for <code>SingletonIfInt[A]</code> (excluding <code>null</code> which we will pretend no to exist).</p>
<p>GADTs are very useful to encode predicates over types. Imagine you have a <strong>value</strong> <code>v:EmptyOrSingleton[A]</code> for
some type <code>A</code>  (remember we pretend <code>null</code> does not exist). What could you say about <code>A</code>? The <strong>only</strong> way to get
a <strong>value</strong> of type <code>EmptyOrSingleton[A]</code> is through <code>SingleValueIfAisInt</code>. Thus <code>v</code> is <code>SingleValueIfAisInt</code>
which is of type <code>EmptyOrSingleton[Int]</code> so is <code>v</code>. We can conclude that <code>A</code> is actually <code>Int</code>. Not convinced?
Let <code>A</code> be <code>String</code>, can you build a <strong>value</strong> of type <code>EmptyOrSingleton[String]</code> without using <code>null</code>? Try it.</p>
<p>To find how to fold <code>EmptyOrSingleton[A]</code> into <code>T</code>, let&rsquo;s apply the technique we used in the previous sections.
<code>EmptyOrSingleton[A]</code> has only one constructor, <code>SingleValueIfAisInt</code>,  so we need a constant <code>z:T</code>. But
<code>SingleValueIfAisInt</code> is not of type <code>EmptyOrSingleton[A]</code> but <code>EmptyOrSingleton[Int]</code>. The argument <code>A</code> matters
so let <code>T</code> depend on <code>A</code>: we want to transform values of type <code>EmptyOrSingleton[A]</code> into <code>T[A]</code>.</p>
<ul>
<li><code>SingleValueIfAisInt</code> being of type <code>EmptyOrSingleton[Int]</code> we need a constant <code>z:T[Int]</code></li>
</ul>
<p>Then we can operate the transformation:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">foldEmptyOrSingleton</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">T</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">z</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">EmptyOrSingleton</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">T</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">transform</span><span class="o">(</span><span class="n">v</span><span class="k">:</span> <span class="kt">EmptyOrSingleton</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="n">v</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">SingleValueIfAisInt</span> <span class="k">=&gt;</span> <span class="n">z</span> <span class="c1">// Because we know A = Int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">transform</span> <span class="k">_</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p><code>foldEmptyOrSingleton</code> means that, for some <code>T[_]</code>, if you have a value <code>z:T[Int]</code> then you can transform any value
<code>EmptyOrSingleton[A]</code> into <code>T[A]</code>. For example, let&rsquo;s take</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">type</span> <span class="kt">T</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span> <span class="k">=</span> <span class="n">X</span> <span class="o">=:=</span> <span class="nc">Int</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">z</span><span class="k">:</span><span class="kt">T</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">Int</span> <span class="kt">=:=</span> <span class="kt">Int</span><span class="o">]</span></span></span></code></pre></div>
<p>Then <code>foldEmptyOrSingleton[A,T](z)</code> gives us, for any value <code>v:EmptyOrSingleton[A]</code> a proof that <code>A =:= Int</code>. Another
important use case is asserting type equality:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Eq</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Refl</span><span class="o">[</span><span class="kt">X</span><span class="o">]()</span> <span class="k">extends</span> <span class="nc">Eq</span><span class="o">[</span><span class="kt">X</span>,<span class="kt">X</span><span class="o">]</span></span></span></code></pre></div>
<p>Any <strong>non-null value</strong> <code>v:Eq[A,B]</code> must be a <code>Refl[X]() : Eq[X,X]</code> for some <code>X</code>, then <code>Eq[A,B] = Eq[X,X]</code> proving that
<code>A = X = B</code>. To transform a value of type <code>Eq[A,B]</code> into <code>T[A,B]</code> we need:</p>
<ul>
<li><code>Refl[X]()</code> is essentially a constant of type <code>Eq[X,X]</code> for all type <code>X</code> (note: <em>Scala</em> write this type <code>[X]Eq[X,X]</code>).
We need a constant <code>z:T[X,X]</code> for all type <code>X</code> (so the type <code>[X]T[X,X]</code>). <em>Scala</em> does not support transparent higher-ranked
types, we need to emulate them with a <code>trait</code>:</li>
</ul>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">trait</span> <span class="nc">ElimRefl</span><span class="o">[</span><span class="kt">T</span><span class="o">[</span><span class="k">_</span>,<span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">X</span>,<span class="kt">X</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p>Then we could have hoped to be able to operate the transformation like previous section. But given a value <code>v:Eq[A,B]</code>,
convincing <em>Scala</em> that <code>A = B</code> is a bit tough. Instead we can write the <code>fold</code> as a method:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Eq</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">T</span><span class="o">[</span><span class="k">_</span>,<span class="k">_</span><span class="o">]](</span><span class="n">z</span><span class="k">:</span> <span class="kt">ElimRefl</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Refl</span><span class="o">[</span><span class="kt">X</span><span class="o">]()</span> <span class="k">extends</span> <span class="nc">Eq</span><span class="o">[</span><span class="kt">X</span>,<span class="kt">X</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">T</span><span class="o">[</span><span class="k">_</span>,<span class="k">_</span><span class="o">]](</span><span class="n">z</span><span class="k">:</span> <span class="kt">ElimRefl</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span><span class="o">[</span><span class="kt">X</span>,<span class="kt">X</span><span class="o">]</span> <span class="k">=</span> <span class="n">z</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">foldEq</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">T</span><span class="o">[</span><span class="k">_</span>,<span class="k">_</span><span class="o">]](</span><span class="n">z</span><span class="k">:</span> <span class="kt">ElimRefl</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Eq</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">T</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="o">(</span><span class="n">v</span><span class="k">:</span><span class="kt">Eq</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">fold</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">z</span><span class="o">)</span></span></span></code></pre></div>
<p>Ingenious definition of <code>T[_,_]</code> leads to interesting results:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">trait</span> <span class="nc">C</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nc">type</span> <span class="n">T1</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">C</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">=:=</span> <span class="n">C</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">z1</span><span class="k">:</span> <span class="kt">ElimRefl</span><span class="o">[</span><span class="kt">T1</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="k">new</span> <span class="nc">ElimRefl</span><span class="o">[</span><span class="kt">T1</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span><span class="k">:</span> <span class="kt">T1</span><span class="o">[</span><span class="kt">X</span>,<span class="kt">X</span><span class="o">]</span> <span class="k">=</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">C</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span> <span class="kt">=:=</span> <span class="kt">C</span><span class="o">[</span><span class="kt">X</span><span class="o">]]</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">transform</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span><span class="k">:</span> <span class="kt">Eq</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">C</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">=:=</span> <span class="n">C</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">foldEq</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span>,<span class="kt">T1</span><span class="o">](</span><span class="n">z1</span><span class="o">)</span></span></span></code></pre></div>
<h3 id="existential-quantification">Existential Quantification</h3>
<p>GADTs not only provide useful type equalities, they also offer existential quantification!</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Ex</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">type</span> <span class="kt">hidden</span>
</span></span><span class="line"><span class="cl">  <span class="k">val</span> <span class="n">value</span><span class="k">:</span> <span class="kt">hidden</span>
</span></span><span class="line"><span class="cl">  <span class="k">val</span> <span class="n">evidence</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">hidden</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">MakeEx</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">evidence</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Ex</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">type</span> <span class="kt">hidden</span> <span class="o">=</span> <span class="n">A</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p>Any value <code>v:Ex[F]</code> has to be an instance of <code>MakeEx[F,A]</code> for some type <code>A</code>. Which means we have a value,
<code>v.value</code>, of type <code>A</code> and an instance of the type-class <code>F</code> for <code>A</code> (for example an instance of <code>Monoid[A]</code>
with <code>F[X] = Monoid[X]</code>).</p>
<p>To transform values of type <code>Ex[F]</code> into <code>T</code> we need:</p>
<ul>
<li><code>MakeEx[F[_],?]</code> being of type <code>[A](A, F[A]) =&gt; Ex[F]</code> meaning: <code>For_all_type A, (A, F[A]) =&gt; Ex[F]</code>, we
need a function <code>f</code> of type <code>[A](A, F[A]) =&gt; T</code>. <em>Scala</em> still does not support transparent higher ranked
types, we need to emulate them with another <code>trait</code>:</li>
</ul>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">trait</span> <span class="nc">ElimMakeEx</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">evidence</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p>Then we can operate the transformation:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">foldEx</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">T</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">ElimMakeEx</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Ex</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">T</span> <span class="k">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">transform</span><span class="o">(</span><span class="n">v</span><span class="k">:</span> <span class="kt">Ex</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="n">v</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="n">w</span><span class="nd">@MakeEx</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="n">evidence</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">[</span><span class="kt">w.hidden</span><span class="o">](</span><span class="n">value</span><span class="o">,</span> <span class="n">evidence</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">transform</span> <span class="k">_</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<h2 id="duality">Duality</h2>
<p>In this post we have deduced the <code>fold</code> functions from the definition of each type. It is possible to
do the opposite: each constructor can be derived from the <code>fold</code> function of its type. For example:</p>
<div class="highlight wrap-code"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">trait</span> <span class="nc">List</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">z</span><span class="k">:</span><span class="kt">T</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span><span class="kt">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">nil</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="k">new</span> <span class="nc">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">z</span><span class="k">:</span><span class="kt">T</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span><span class="kt">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="n">z</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">cons</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">head</span><span class="k">:</span><span class="kt">A</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="k">new</span> <span class="nc">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">z</span><span class="k">:</span><span class="kt">T</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span><span class="kt">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="n">f</span><span class="o">(</span><span class="n">head</span><span class="o">,</span> <span class="n">tail</span><span class="o">.</span><span class="n">fold</span><span class="o">(</span><span class="n">z</span><span class="o">,</span><span class="n">f</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">equality</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">l1</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">l2</span><span class="k">:</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">???</span> <span class="o">//</span> <span class="nc">Difficult</span> <span class="n">but</span> <span class="n">worthy</span> <span class="n">exercice</span></span></span></code></pre></div>
<h2 id="conclusion">Conclusion</h2>
<p>I hope i convinced you folds are immensely useful. First, they let us write simply complex transform functions.
But this not the most interesting property. It is sometimes easier to define a type by its <code>fold</code> function.
<em>Java</em>, for example, does not have support for neither <code>sealed</code> classes nor pattern-matching. How could we define
the <code>List</code> type so that <code>Nil</code> and <code>Cons</code> are the two only cases? The <code>fold</code> function forces any instance of <code>List</code>
to fit into the desired shape (if some rules are obeyed like no <code>null</code> and no runtime-reflection).
It can also happen that type-inference is not smart enough, <code>fold</code> function provide an alternative way which is
often easier for the <code>Scala</code> type-checker.</p>

  <footer class="footline">
  </footer>
</article>
        </div>
      </main>
    </div>
    <script src="../../js/clipboard.min.js?1729693097" defer></script>
    <script src="../../js/perfect-scrollbar.min.js?1729693097" defer></script>
    <script>
      function useMathJax( config ){
        window.MathJax = Object.assign( window.MathJax || {}, {
          tex: {
            inlineMath:  [['\\(', '\\)'], ['$',  '$']],  
            displayMath: [['\\[', '\\]'], ['$$', '$$']], 
          },
          options: {
            enableMenu: false 
          }
        }, config );
      }
      useMathJax( JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="../../js/mathjax/tex-mml-chtml.js?1729693097"></script>
    <script src="../../js/theme.js?1729693097" defer></script>
  </body>
</html>
