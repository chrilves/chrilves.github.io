<!DOCTYPE html>
<html lang="en" dir="ltr" itemscope itemtype="http://schema.org/Article" data-r-output-format="print">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.147.7">
    <meta name="generator" content="Relearn 7.6.1+4407b4364ab6f7477f7671fbd20c0494bade40ee">
    <meta name="description" content="Découvrez les ADT généralisés en vous amusant.">
    <meta name="author" content="chrilves">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Les GADTs Par l&#39;Exemple :: @chrilves&#39; Archives">
    <meta name="twitter:description" content="Découvrez les ADT généralisés en vous amusant.">
    <meta name="twitter:site" content="@chrilves"/>
    <meta property="og:url" content="https://chrilves.github.io/posts/les_gadts_par_l_exemple/index.html">
    <meta property="og:site_name" content="@chrilves&#39; Archives">
    <meta property="og:title" content="Les GADTs Par l&#39;Exemple :: @chrilves&#39; Archives">
    <meta property="og:description" content="Découvrez les ADT généralisés en vous amusant.">
    <meta property="og:locale" content="en">
    <meta property="og:type" content="article">
    <meta property="article:section" content="Posts">
    <meta property="article:published_time" content="2019-10-27T22:30:00+02:00">
    <meta property="article:modified_time" content="2019-10-27T22:30:00+02:00">
    <meta itemprop="name" content="Les GADTs Par l&#39;Exemple :: @chrilves&#39; Archives">
    <meta itemprop="description" content="Découvrez les ADT généralisés en vous amusant.">
    <meta itemprop="datePublished" content="2019-10-27T22:30:00+02:00">
    <meta itemprop="dateModified" content="2019-10-27T22:30:00+02:00">
    <meta itemprop="wordCount" content="7888">
    <meta itemprop="keywords" content="GADT,GADTs,Generalized Algebraic Data Types,ADT,Algebraic Data Types,Functional Programming,Interface,Free Monad">
    <title>Les GADTs Par l&#39;Exemple :: @chrilves&#39; Archives</title>
    <link href="https://chrilves.github.io/posts/les_gadts_par_l_exemple/index.html" rel="canonical" type="text/html" title="Les GADTs Par l&#39;Exemple :: @chrilves&#39; Archives">
    <link href="../../posts/les_gadts_par_l_exemple/index.xml" rel="alternate" type="application/rss+xml" title="Les GADTs Par l&#39;Exemple :: @chrilves&#39; Archives">
    <link href="../../fonts/fontawesome/css/fontawesome-all.min.css?1750073986" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="../../fonts/fontawesome/css/fontawesome-all.min.css?1750073986" rel="stylesheet"></noscript>
    <link href="../../css/perfect-scrollbar/perfect-scrollbar.min.css?1750073986" rel="stylesheet">
    <link href="../../css/theme.min.css?1750073986" rel="stylesheet">
    <link href="../../css/format-print.min.css?1750073986" rel="stylesheet" id="R-format-style">
    <link href="../../css/auto-complete/auto-complete.min.css?1750073986" rel="stylesheet">
    <script src="../../js/auto-complete/auto-complete.min.js?1750073986" defer></script>
    <script src="../../js/lunr/lunr.min.js?1750073986" defer></script>
    <script src="../../js/lunr/lunr.stemmer.support.min.js?1750073986" defer></script>
    <script src="../../js/lunr/lunr.multi.min.js?1750073986" defer></script>
    <script src="../../js/lunr/lunr.en.min.js?1750073986" defer></script>
    <script src="../../js/search.min.js?1750073986" defer></script>
    <script>
      window.relearn = window.relearn || {};
      // configuration
      window.relearn.min = `.min`;
      window.relearn.path='\/posts\/les_gadts_par_l_exemple\/index.html';
      window.relearn.relBasePath='..\/..';
      window.relearn.relBaseUri='..\/..';
      window.relearn.absBaseUri='https:\/\/chrilves.github.io';
      window.relearn.contentLangs=['en'];
      window.relearn.index_js_url="../../searchindex.en.js?1750073986";
      window.relearn.disableAnchorCopy=false;
      window.relearn.disableAnchorScrolling=false;
      window.relearn.disableInlineCopyToClipboard=true;
      window.relearn.enableBlockCodeWrap=true;
      // legal
      window.relearn.getItem = (s,n) => {return s.getItem(n)};
      window.relearn.setItem = (s,n,v) => {return s.setItem(n,v)};
      window.relearn.removeItem = (s,n) => {return s.removeItem(n)};
      // variant stuff
      window.relearn.themevariants = [ 'relearn-auto', 'relearn-light', 'relearn-dark', 'relearn-bright', 'zen-auto', 'zen-light', 'zen-dark', 'retro-auto', 'neon', 'learn', 'blue', 'green', 'red' ];
      window.relearn.customvariantname = "my-custom-variant";
      window.relearn.changeVariant = function(variant) {
        var oldVariant = document.documentElement.dataset.rThemeVariant;
        window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
        document.documentElement.dataset.rThemeVariant = variant;
        if (oldVariant != variant) {
          document.dispatchEvent( new CustomEvent('themeVariantLoaded', { detail: { variant, oldVariant } }) );
          window.relearn.markVariant();
        }
      }
      window.relearn.markVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant");
        document.querySelectorAll(".R-variantswitcher select").forEach((select) => {select.value = variant;});
      }
      window.relearn.initVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant") ?? "";
        if( variant == window.relearn.customvariantname ){
        }else if( !variant || !window.relearn.themevariants.includes(variant) ){
          variant = window.relearn.themevariants[0];
          window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
        }
        document.documentElement.dataset.rThemeVariant = variant;
      }
      window.relearn.initVariant();
      window.relearn.markVariant();
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script>
  </head>
  <body class="mobile-support print" data-url="../../posts/les_gadts_par_l_exemple/index.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide"><button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)"><i class="fa-fw fas fa-bars"></i></button>
            </div>
            <div class="topbar-button topbar-button-toc" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="Table of Contents (CTRL&#43;ALT&#43;t)"><i class="fa-fw fas fa-list-alt"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper">
<nav class="TableOfContents">
  <ul>
    <li><a href="#remerciements">Remerciements</a></li>
    <li><a href="#lisez-moi">LISEZ-MOI</a></li>
    <li><a href="#échauffements">Échauffements</a>
      <ul>
        <li><a href="#valeurs-et-types"><em>Valeurs</em> et <em>Types</em>?</a></li>
        <li><a href="#combien-de-types">Combien de types?</a></li>
        <li><a href="#combien-de-valeurs">Combien de valeurs?</a></li>
      </ul>
    </li>
    <li><a href="#premier-contact">Premier Contact</a>
      <ul>
        <li><a href="#cas-dutilisation-preuve-dune-propriété">Cas d&rsquo;Utilisation: Preuve d&rsquo;une propriété</a></li>
        <li><a href="#cas-dutilisation-la-seule-chose-que-je-sais-est-quil-existe">Cas d&rsquo;Utilisation: La seule chose que je sais, est qu&rsquo;il existe</a></li>
        <li><a href="#conclusion-intermédiaire">Conclusion Intermédiaire</a></li>
      </ul>
    </li>
    <li><a href="#cas-dutilisation-simples-et-utiles-relations-sur-les-types">Cas d&rsquo;utilisation simples et utiles: relations sur les types</a>
      <ul>
        <li><a href="#cas-dutilisation-témoin-dégalité-entre-types">Cas d&rsquo;Utilisation: Témoin d&rsquo;Égalité entre Types</a></li>
        <li><a href="#cas-dutilisation-témoin-de-sous-typage">Cas d&rsquo;Utilisation: Témoin de Sous-Typage</a></li>
        <li><a href="#cas-dutilisation-éviter-les-messages-derreur-de-scalac-à-propos-des-bornes-non-respectées">Cas d&rsquo;Utilisation: Éviter les messages d&rsquo;erreur de <em>scalac</em> à propos des bornes non respectées</a></li>
        <li><a href="#cas-dutilisation-fournir-les-bonnes-données-au-bon-diagramme">Cas d&rsquo;Utilisation: Fournir les bonnes données au bon diagramme</a></li>
      </ul>
    </li>
    <li><a href="#cas-dutilisation-plus-avancés">Cas d&rsquo;Utilisation Plus Avancés</a>
      <ul>
        <li><a href="#cas-dutilisation-les-effets">Cas d&rsquo;Utilisation: Les Effets!</a></li>
        <li><a href="#cas-dutilisation-sassurer-que-les-types-sont-pris-en-charge-par-la-base-de-données">Cas d&rsquo;Utilisation: S&rsquo;assurer que les types sont pris en charge par la Base De Données.</a></li>
        <li><a href="#cas-dutilisation-simplifier-les-implicites">Cas d&rsquo;Utilisation: Simplifier les Implicites</a></li>
      </ul>
    </li>
    <li><a href="#conclusion">Conclusion</a></li>
  </ul>
</nav>
                </div>
              </div>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList">
            <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class="a11y-only"><a itemprop="item" href="../../index.html"><span itemprop="name">@chrilves&#39; Archives</span></a><meta itemprop="position" content="1">&nbsp;>&nbsp;</li>
            <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><a itemprop="item" href="../../posts/index.html"><span itemprop="name">Posts</span></a><meta itemprop="position" content="2">&nbsp;>&nbsp;</li>
            <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><span itemprop="name">Les GADTs Par l&#39;Exemple</span><meta itemprop="position" content="3"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
            <div class="topbar-button topbar-button-edit" data-content-empty="disable" data-width-s="area-more" data-width-m="show" data-width-l="show"><a class="topbar-control" href="https://github.com/chrilves/chrilves.github.io/edit/master/hugo/content/posts/les_gadts_par_l_exemple.md" rel="external" target="_self" title="Edit (CTRL+ALT+w)"><i class="fa-fw fas fa-pen"></i></a>
            </div>
            <div class="topbar-button topbar-button-print" data-content-empty="disable" data-width-s="area-more" data-width-m="show" data-width-l="show"><a class="topbar-control" href="../../posts/les_gadts_par_l_exemple/index.print.html" title="Print whole chapter (CTRL+ALT+p)"><i class="fa-fw fas fa-print"></i></a>
            </div>
            <div class="topbar-button topbar-button-prev" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="../../posts/probability_in_scala_3_all_sides/index.html" title="Playing with Probability in Scala 3 (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a>
            </div>
            <div class="topbar-button topbar-button-next" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="../../posts/gadts_by_use_cases/index.html" title="GADTs By Use Cases (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a>
            </div>
            <div class="topbar-button topbar-button-more" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="More"><i class="fa-fw fas fa-ellipsis-v"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper">
                  <div class="topbar-area topbar-area-more" data-area="more">
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable posts" tabindex="-1">
        <div class="flex-block-wrapper">
<article class="default">
  <header class="headline">
  </header>

<h1 id="les-gadts-par-lexemple">Les GADTs Par l&#39;Exemple</h1>
    <p class="article-meta default"><i class='fa-fw fas fa-calendar'></i><em>27 Oct 2019 - 7900 Words</em></p>

<p>Soyez les bienvenu·e·s! Cette session a le dessein de vous présenter
un outil de programmation très puissant. Alors que la plupart des
introductions sur le sujet commencent par une présentation de ses
fondements théoriques d&rsquo;une manière très formelle, nous avons choisi
de vous le présenter à travers de courts exemples et des cas
d&rsquo;utilisation concrets.</p>
<p>Cet atelier est composé de trois parties. La dernière présente trois
des cas d&rsquo;utilisation des plus utiles. Ils forment les usages majeurs
en pratique. Mais ne vous y aventurez pas sans préparation! Cette partie
est la dernière pour une bonne raison: elle s&rsquo;appuie massivement sur
les leçons des parties précédentes.
Commencez par <a href="../../posts/les_gadts_par_l_exemple/index.html#premier-contact">Premier Contact</a>, elle vous exposera,
via les plus simples exemples, les idées clefs. Son but est
d&rsquo;ouvrir votre esprit à des manières d&rsquo;utiliser les types et données
que vous n&rsquo;avez vraisemblablement jamais soupçonnées.
Arpentez ensuite
<a href="../../posts/les_gadts_par_l_exemple/index.html#cas-d-utilisation-simples-et-utiles-relations-sur-les-types">Cas d’utilisation simples et utiles: relations sur les types</a>,
pour un premier défi devant un usage pratique.
Après cela seulement vous serez prêt·e pour
<a href="../../posts/les_gadts_par_l_exemple/index.html#cas-d-utilisation-plus-avancés">Cas d’Utilisation Plus Avancés</a>.</p>
<p>Assurez vous de <strong>lire <a href="../../posts/les_gadts_par_l_exemple/index.html#lisez-moi">LISEZ-MOI</a></strong>, cette section contient de précieuses
astuces pour faciliter votre parcours.</p>
<h2 id="remerciements">Remerciements</h2>
<p>Nous tenons à remercier <a href="http://www.laure-juglaret.fr/" rel="external" target="_self">Laure Juglaret</a> pour
ses nombreuses relectures, ses précieuses remarques et corrections.</p>
<h2 id="lisez-moi">LISEZ-MOI</h2>
<p>Durant toute cette présentation, nous considérerons que:</p>
<ul>
<li><code>null</code> <strong>n&rsquo;existe pas!</strong></li>
<li><strong>La réflexion au runtime n&rsquo;existe pas!</strong> (c.-à-d. <code>isInstanceOf</code>, <code>getClass</code>, etc)</li>
</ul>
<p>Cette présentation considère que <em>ces fonctionnalités n&rsquo;existent pas du tout!</em>.</p>
<p><strong>Leur utilisation n&rsquo;amènera jamais à une réponse correcte aux questions.</strong>.</p>
<p>Pour faire cet atelier vous devez disposez du nécessaire pour écrire, compiler et
exécuter rapidement du code <em>Scala</em>. Le meilleur moyen est d&rsquo;ouvrir une session
interactive (<em>R.E.P.L.</em>). Si vous avez <em>Scala</em> d&rsquo;installé sur votre système, vous
pouvez facilement en démarrer une via la ligne de commande en exécutant le programme
<code>scala</code>:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">system</span><span class="o">-</span><span class="n">command</span><span class="o">-</span><span class="n">line</span><span class="k">#</span> <span class="n">scala</span>
</span></span><span class="line"><span class="cl"><span class="nc">Welcome</span> <span class="n">to</span> <span class="nc">Scala</span> <span class="mf">2.13</span><span class="o">.</span><span class="mi">1</span> <span class="o">(</span><span class="nc">OpenJDK</span> <span class="mi">64</span><span class="o">-</span><span class="nc">Bit</span> <span class="nc">Server</span> <span class="nc">VM</span><span class="o">,</span> <span class="nc">Java</span> <span class="mf">1.8</span><span class="o">.</span><span class="mi">0</span><span class="n">_222</span><span class="o">).</span>
</span></span><span class="line"><span class="cl"><span class="nc">Type</span> <span class="n">in</span> <span class="n">expressions</span> <span class="k">for</span> <span class="n">evaluation</span><span class="o">.</span> <span class="nc">Or</span> <span class="k">try</span> <span class="k">:</span><span class="kt">help.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">scala&gt;</span></span></span></code></pre></div>
<p>Pour rappel, dans une session interactive (<em>R.E.P.L.</em>),
la commande <code>:paste</code> permet de copier du code dans la session
et la commande <code>:reset</code> de repartir d&rsquo;un environnement vierge.</p>
<p>Si vous n&rsquo;avez pas <em>Scala</em> d&rsquo;installé, <strong>vous pouvez utiliser</strong> le
site <a href="https://scastie.scala-lang.org/" rel="external" target="_self">https://scastie.scala-lang.org/</a> .</p>
<h2 id="échauffements">Échauffements</h2>
<p>Cette section est un bref rappel de quelques définitions et propriétés sur
les types et les valeurs.</p>
<h3 id="valeurs-et-types"><em>Valeurs</em> et <em>Types</em>?</h3>
<p>Les <strong>valeurs</strong> sont les <em>données concrètes que vos programmes manipulent</em>
comme l&rsquo;entier <code>5</code>, le booléen <code>true</code>, la chaîne <code>&quot;Hello World!&quot;</code>,
la fonction <code>(x: Double) =&gt; x / 7.5</code>, la liste <code>List(1,2,3)</code>, etc.
Il est souvent pratique de classer les valeurs en groupes. Ces groupes sont appelés
des <strong>types</strong>. Par exemple:</p>
<ul>
<li><code>Int</code> est le groupe des valeurs entières, c.-à-d. les valeurs telles que <code>1</code>, <code>-7</code>, <code>19</code>, etc.</li>
<li><code>Boolean</code> est le groupe contenant exactement les valeurs
<code>true</code> et <code>false</code> (ni plus, ni moins!).</li>
<li><code>String</code> est le groupe dont les valeurs sont <code>&quot;Hello World!&quot;</code>, <code>&quot;&quot;</code>, <code>&quot;J' ❤️ les GADTs&quot;</code>, etc.</li>
<li><code>Double =&gt; Double</code> est le groupe dont les valeurs sont les fonctions prenant en argument
n&rsquo;importe quel <code>Double</code> et renvoyant également un double <code>Double</code>.</li>
</ul>
<p>Pour indiquer que la valeur <code>v</code> appartient au type (c.-à-d. groupe de valeurs) <code>T</code>,
la notation est <code>v : T</code>. En <em>Scala</em>, tester si une valeur <code>v</code> appartient au type <code>T</code>
est très simple: il suffit de taper <code>v : T</code> dans la session interactive (<em>REPL</em>):</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="mi">5</span> <span class="k">:</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl"><span class="n">res7</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">5</span></span></span></code></pre></div>
<p>Si <em>Scala</em> l&rsquo;accepte, alors <code>v</code> appartient bien au type <code>T</code>. Si <em>Scala</em> râle,
ce n&rsquo;est probablement pas le cas:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="mi">5</span> <span class="k">:</span> <span class="kt">String</span>
</span></span><span class="line"><span class="cl">       <span class="o">^</span>
</span></span><span class="line"><span class="cl">       <span class="n">error</span><span class="k">:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">found</span>   <span class="k">:</span> <span class="kt">Int</span><span class="o">(</span><span class="err">5</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="kt">required:</span> <span class="kt">String</span></span></span></code></pre></div>
<h3 id="combien-de-types">Combien de types?</h3>
<p>Créons maintenant quelques types et quelques unes de leurs valeurs (quand cela est possible!).</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">UnType</span></span></span></code></pre></div>
<ul>
<li>
<p><strong>Question 1:</strong> Combien de types la ligne <code>class UnType</code> définit-elle?</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<p>Comme son nom le suggère, la ligne <code>class UnType</code> définit seulement un type, nommé <code>UnType</code>.</p>
  </details>
</li>
</ul>
<p>Passons maintenant à:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">UnTypePourChaque</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span></span></span></code></pre></div>
<ul>
<li>
<p><strong>Question 2:</strong> Combien de types la ligne <code>class UnTypePourChaque[A]</code> définit-elle?</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<p>Comme son nom le suggère, chaque type concret <code>A</code> donne lieu à
un type distinct <code>UnTypePourChaque[A]</code>.</p>
<p>Par exemple, une liste d&rsquo;entiers n&rsquo;est ni une liste de booléens,
ni une liste de chaîne de caractères, ni une liste de fonctions, ni &hellip;
En effet les types <code>List[Int]</code>, <code>List[Boolean]</code>,
<code>List[Int =&gt; Int]</code>, etc sont tous des types distincts.</p>
<p>la ligne <code>class UnTypePourChaque[A]</code> définit
<strong>un type distinct pour chaque type concret</strong> <code>A</code>.
Il y a une infinité de types concrets <code>A</code>,
donc une infinité de de types distincts <code>UnTypePourChaque[A]</code>.</p>
  </details>
</li>
<li>
<p><strong>Question 3:</strong> Donnez une valeur qui appartient à la fois aux types
<code>UnTypePourChaque[Int]</code> et <code>UnTypePourChaque[Boolean]</code>.</p>
<p><strong>Pour rappel, <code>null</code> n&rsquo;existe pas!</strong></p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<p>C&rsquo;est en fait impossible. Chaque type concret <code>A</code> donne lieu
à un type distinct <code>UnTypePourChaque[A]</code> qui n&rsquo;a aucune valeur en commun
avec les autres types de la forme <code>UnTypePourChaque[B]</code> avec <code>B ≠ A</code>.</p>
  </details>
</li>
</ul>
<h3 id="combien-de-valeurs">Combien de valeurs?</h3>
<p>En considérant le type suivant:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">final</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">PasDeValeurPourCeType</span></span></span></code></pre></div>
<ul>
<li>
<p><strong>Question 1:</strong> Donnez une valeur appartenant au type <code>PasDeValeurPourCeType</code>?
Combien de valeurs appartiennent au type <code>PasDeValeurPourCeType</code>?</p>
  <details>
    <summary><em>Astuce (cliquer pour dévoiler)</em></summary>
<ul>
<li>Qu&rsquo;est ce qu&rsquo;une classe <code>final</code>? En quoi est-ce qu&rsquo;elle diffère d&rsquo;une classe normale (non finale)?</li>
<li>Qu&rsquo;est ce qu&rsquo;une classe <code>abstract</code>? En quoi est-ce qu&rsquo;elle diffère d&rsquo;une classe concrète?</li>
</ul>
  </details>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<p>La classe <code>PasDeValeurPourCeType</code> est déclarée comme <code>abstract</code>.
Cela signifie qu&rsquo;il est interdit de créer des instances directes de cette classe:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="k">new</span> <span class="nc">PasDeValeurPourCeType</span>
</span></span><span class="line"><span class="cl">       <span class="o">^</span>
</span></span><span class="line"><span class="cl">       <span class="n">error</span><span class="k">:</span> <span class="kt">class</span> <span class="kt">PasDeValeurPourCeType</span> <span class="kt">is</span> <span class="kt">abstract</span><span class="o">;</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">instantiated</span></span></span></code></pre></div>
<p>La seule manière de créer une instance d&rsquo;une classe abstraite est de créer une
une sous-classe concrète. Mais le mot clef <code>final</code> interdit la création de
telles sous-classes:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">SousClasseConcrete</span> <span class="k">extends</span> <span class="nc">PasDeValeurPourCeType</span>
</span></span><span class="line"><span class="cl">                                        <span class="o">^</span>
</span></span><span class="line"><span class="cl">        <span class="n">error</span><span class="k">:</span> <span class="kt">illegal</span> <span class="kt">inheritance</span> <span class="kt">from</span> <span class="kt">final</span> <span class="kt">class</span> <span class="kt">PasDeValeurPourCeType</span></span></span></code></pre></div>
<p>Il n&rsquo;existe aucun moyen de créer une instance pour <code>PasDeValeurPourCeType</code>.</p>
  </details>
</li>
</ul>
<p>Prenons un autre exemple:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">ExactementUneValeur</span>
</span></span><span class="line"><span class="cl"><span class="k">case</span> <span class="k">object</span> <span class="nc">LaSeuleValeur</span> <span class="k">extends</span> <span class="nc">ExactementUneValeur</span></span></span></code></pre></div>
<ul>
<li>
<p><strong>Question 2:</strong> Donnez une valeur appartenant au type <code>ExactementUneValeur</code>?</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<p>Par définition, <code>LaSeuleValeur</code> est une valeur du type <code>ExactementUneValeur</code>.</p>
  </details>
</li>
<li>
<p><strong>Question 3:</strong> Combien de valeurs appartiennent à <code>ExactementUneValeur</code>?</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<p>Comme ci-dessus, <code>ExactementUneValeur</code>, étant un <code>trait</code>, est <em>abstrait</em>. Étant <code>sealed</code>,
l&rsquo;étendre en dehors de son fichier source est interdit.
Donc <code>LaSeuleValeur</code> est la seule valeur du type <code>ExactementUneValeur</code>.</p>
  </details>
</li>
</ul>
<h2 id="premier-contact">Premier Contact</h2>
<p>Cette partie présente les idées clefs. Il y a en fait seulement
deux idées! Vous trouverez ici des exemples épurés illustrant chacune
de ces deux idées.</p>
<h3 id="cas-dutilisation-preuve-dune-propriété">Cas d&rsquo;Utilisation: Preuve d&rsquo;une propriété</h3>
<p>Définissons un simple <em>sealed trait</em>:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">ATrait</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">case</span> <span class="k">object</span> <span class="nc">AValue</span> <span class="k">extends</span> <span class="nc">ATrait</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span></span></span></code></pre></div>
<ul>
<li>
<p><strong>Question 1:</strong> Donnez une valeur du type <code>ATrait[Char]</code>.</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<p>Par définition, <code>AValue</code> est une valeur du type <code>ATrait[Char]</code>.</p>
  </details>
</li>
<li>
<p><strong>Question 2:</strong> Donnez une valeur du type <code>ATrait[Double]</code>.</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<p>Il n&rsquo;existe aucun moyen d&rsquo;obtenir une instance du type <code>ATrait[Double]</code>.
Il n&rsquo;existe en fait aucun moyen d&rsquo;obtenir une instance de <code>ATrait[B]</code> pour <code>B ≠ Char</code>
parce que la seule valeur possible est <code>AValue</code> qui est de type <code>ATrait[Char]</code>.</p>
  </details>
</li>
<li>
<p><strong>Question 3:</strong> Que pouvez vous conclure sur le type <code>A</code> si vous avez une valeur
<code>ev</code> de type <code>ATrait[A]</code> (c.-à-d. <code>ev: ATrait[A]</code>)?</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<p>La seule valeur possible est <code>AValue</code>, donc <code>ev == AValue</code>.
De plus <code>AValue</code> est de type <code>ATrait[Char]</code> donc <code>A = Char</code>.</p>
  </details>
</li>
<li>
<p><strong>Question 4:</strong> Dans la session interactive (<em>REPL</em>), entrez le code suivant:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">f</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">ATrait</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Char</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">x</span></span></span></code></pre></div>
</li>
<li>
<p><strong>Question 5:</strong> Essayez maintenant en utilisant un filtrage par motif
(pattern matching) sur <code>ev: ATrait[A]</code></p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">f</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">ATrait</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Char</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">ev</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">AValue</span> <span class="k">=&gt;</span> <span class="n">x</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
<p>Le filtrage par motif (pattern-matching) est il exhaustif?</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<p>Le filtrage par motif est exhaustif parce la seule et unique valeur possible
pour <code>ev</code> est en fait <code>AValue</code>. De plus <code>AValue</code> est de type <code>ATrait[Char]</code> ce qui signifie
que <code>ev : ATrait[Char]</code> parce que <code>ev == AValue</code>. Donc <code>A = Char</code> et <code>x : Char</code>.</p>
  </details>
</li>
<li>
<p><strong>Question 6:</strong> Appelez <code>f</code> avec <code>x = 'w' : Char</code>.</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">[</span><span class="kt">Char</span><span class="o">](</span><span class="sc">&#39;w&#39;</span><span class="o">,</span> <span class="nc">AValue</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="n">res0</span><span class="k">:</span> <span class="kt">Char</span> <span class="o">=</span> <span class="n">w</span></span></span></code></pre></div>
  </details>
</li>
<li>
<p><strong>Question 7:</strong> Appelez <code>f</code> avec <code>x =  5.2 : Double</code>.</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<p>C&rsquo;est impossible parce que cela demenderait de fournir une valeur
<code>ev : ATrait[Double]</code>, ce qui n&rsquo;existe pas!</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">[</span><span class="kt">Double</span><span class="o">](</span><span class="mi">5</span><span class="o">,</span> <span class="nc">AValue</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">                    <span class="o">^</span>
</span></span><span class="line"><span class="cl">          <span class="n">error</span><span class="k">:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">found</span>   <span class="k">:</span> <span class="kt">AValue.type</span>
</span></span><span class="line"><span class="cl">            <span class="n">required</span><span class="k">:</span> <span class="kt">ATrait</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span></span></span></code></pre></div>
  </details>
</li>
</ul>
<details>
  <summary><strong>Remarque pour les personnes à l'aise en <em>Scala</em></strong> <em>(cliquer pour dévoiler)</em></summary>
<p>En utilisant toutes les chouettes fonctionnalités syntaxiques de <em>Scala</em>,
la version satisfaisante en production du code ci-dessus est:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">IsChar</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">object</span> <span class="nc">IsChar</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">implicit</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">Evidence</span> <span class="k">extends</span> <span class="nc">IsChar</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">implicit</span> <span class="n">evidence</span><span class="k">:</span> <span class="kt">IsChar</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">IsChar</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="n">evidence</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">f</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">IsChar</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Char</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="nc">IsChar</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">IsChar</span><span class="o">.</span><span class="nc">Evidence</span> <span class="k">=&gt;</span> <span class="n">x</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
</details>
<h3 id="cas-dutilisation-la-seule-chose-que-je-sais-est-quil-existe">Cas d&rsquo;Utilisation: La seule chose que je sais, est qu&rsquo;il existe</h3>
<p>Que feriez vous si vous vouliez que votre application tienne un journal d’évènements (c.-à-d. un <em>log</em>),
mais que vous vouliez être sur qu&rsquo;elle ne dépende d&rsquo;aucun détail d&rsquo;implémentation de la méthode
de journalisation (c.-à-d. du <em>logger</em>), de telle manière que vous puissiez changer son implémentation
sans risquer de casser votre application?</p>
<p>En considérant le type suivant, <code>UnknownLogger</code>, des méthodes de journalisation:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">UnknownLogger</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">LogWith</span><span class="o">[</span><span class="kt">X</span><span class="o">](</span><span class="n">logs</span> <span class="k">:</span> <span class="kt">X</span><span class="o">,</span> <span class="n">appendMessage</span><span class="k">:</span> <span class="o">(</span><span class="kt">X</span><span class="o">,</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">X</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">UnknownLogger</span></span></span></code></pre></div>
<p>La première méthode (c.-à-d. *<em>logger</em>) que nous créons stocke les messages dans une <code>String</code>:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">loggerStr</span> <span class="k">:</span> <span class="kt">UnknownLogger</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="nc">LogWith</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">&#34;&#34;</span><span class="o">,</span> <span class="o">(</span><span class="n">logs</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">message</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">logs</span> <span class="o">++</span> <span class="n">message</span><span class="o">)</span></span></span></code></pre></div>
<p>La seconde méthode les stocke dans une <code>List[String]</code>:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">loggerList</span> <span class="k">:</span> <span class="kt">UnknownLogger</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="nc">LogWith</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]](</span><span class="nc">Nil</span><span class="o">,</span> <span class="o">(</span><span class="n">logs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span> <span class="n">message</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">message</span> <span class="k">:</span><span class="kt">:</span> <span class="kt">logs</span><span class="o">)</span></span></span></code></pre></div>
<p>La troisième méthode de journalisation imprime directement les messages sur la sortie standard:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">loggerStdout</span> <span class="k">:</span> <span class="kt">UnknownLogger</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="nc">LogWith</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]((),</span> <span class="o">(</span><span class="n">logs</span><span class="k">:</span> <span class="kt">Unit</span><span class="o">,</span> <span class="n">message</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">message</span><span class="o">))</span></span></span></code></pre></div>
<p>Notez que ces trois méthodes de journalisation ont toutes le même type
(c.-à-d. <code>UnknownLogger</code>) mais qu&rsquo;elles stockent les messages en utilisant
différents types <code>X</code> (<code>String</code>, <code>List[String]</code> et <code>Unit</code>).</p>
<ul>
<li>
<p><strong>Question 1:</strong> Soit <code>v</code> une valeur de type <code>UnknownLogger</code>.
Clairement <code>v</code> doit être une instance de la classe <code>LogWith[X]</code> pour un certain <code>X</code>.
Que pouvez vous dire sur le type <code>X</code>? Pouvez-vous deviner quel type concret est <code>X</code>?</p>
<p><strong>Pour rappel, il est interdit d&rsquo;utiliser la réflexion au runtime!</strong> (c.-à-d. <code>isInstanceOf</code>, <code>getClass</code>, etc)</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<p>Nous ne savons presque rien sur <code>X</code>. La seule chose que nous avons est qu&rsquo;il existe au
moins une valeur (<code>v.logs</code>) de type <code>X</code>. À part cela, <code>X</code> peut être n&rsquo;importe quel type.</p>
<p>Ne pas savoir quel type concret est <code>X</code> est très utile pour garantir que le code qui utilisera
<code>v : UnknownLogger</code> ne dépendra pas de la nature de <code>X</code>. Si ce code savait que <code>X</code> était
<code>String</code> par exemple, il pourrait exécuter des opérations que nous voulons interdir comme inverser
la liste, ne retenir que les <em>n</em> premiers caractères, etc. En cachant la nature de<code>X</code>, nous forçons
notre application à ne pas dépendre du type concret derrière<code>X</code> mais de n&rsquo;utiliser que la
fonnction fournie <code>v.appendMessage</code>.
Ainsi changer l&rsquo;implémentation réelle de la méthode de journalisation ne cassera aucun code.</p>
  </details>
</li>
<li>
<p><strong>Question 2:</strong> Écrivez la fonction <code>def log(message: String, v: UnknownLogger): UnknownLogger</code>
qui utilise <code>v.appendMessage</code> pour ajouter le <code>message</code> au journal <code>v.logs</code>
et retourne un nouvel <code>UnknownLogger</code> contenant le nouveau journal (c.-à-d. le nouveau <code>log</code>).</p>
<p>Pour rappel, en <em>Scala</em>, le motif (c.-à-d. pattern) <code>case ac : AClass[t] =&gt;</code>
est possible dans les expressions de type <code>match/case</code> comme alternative au motif
<code>case AClass(v) =&gt; </code>:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">AClass</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">value</span> <span class="k">:</span> <span class="kt">A</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">f</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">v</span><span class="k">:</span> <span class="kt">AClass</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">v</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="n">ac</span> <span class="k">:</span> <span class="kt">AClass</span><span class="o">[</span><span class="kt">t</span><span class="o">]</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// La variable `t` is une variable de type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// Le type `t` est `A`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">val</span> <span class="n">r</span> <span class="k">:</span> <span class="kt">t</span> <span class="o">=</span> <span class="n">ac</span><span class="o">.</span><span class="n">value</span>
</span></span><span class="line"><span class="cl">      <span class="n">r</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
<p>Son principal avantage est d&rsquo;introduire la variable de type <code>t</code>.
Les variables de type se comportent comme des variables de motif classiques
(c.-à-d. pattern variables) à l&rsquo;exception prés qu&rsquo;elles représentent des
types et non des valeurs.
Avoir <code>t</code> sous la main nous permet d&rsquo;aider le compilateur en donnant
explicitement certains types (comme ci-dessus, expliciter que <code>r</code> est de type <code>t</code>).</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">log</span><span class="o">(</span><span class="n">message</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">v</span><span class="k">:</span> <span class="kt">UnknownLogger</span><span class="o">)</span><span class="k">:</span> <span class="kt">UnknownLogger</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">v</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="n">vx</span> <span class="k">:</span> <span class="kt">LogWith</span><span class="o">[</span><span class="kt">x</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">LogWith</span><span class="o">[</span><span class="kt">x</span><span class="o">](</span><span class="n">vx</span><span class="o">.</span><span class="n">appendMessage</span><span class="o">(</span><span class="n">vx</span><span class="o">.</span><span class="n">logs</span><span class="o">,</span> <span class="n">message</span><span class="o">),</span> <span class="n">vx</span><span class="o">.</span><span class="n">appendMessage</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
  </details>
</li>
<li>
<p><strong>Question 3:</strong> Exécutez <code>log(&quot;Hello World&quot;, loggerStr)</code> et <code>log(&quot;Hello World&quot;, loggerList)</code>
et <code>log(&quot;Hello World&quot;, loggerStdout)</code></p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">log</span><span class="o">(</span><span class="s">&#34;Hello World&#34;</span><span class="o">,</span> <span class="n">loggerStr</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="n">res0</span><span class="k">:</span> <span class="kt">UnknownLogger</span> <span class="o">=</span> <span class="nc">LogWith</span><span class="o">(</span><span class="nc">Hello</span> <span class="nc">World</span><span class="o">,</span><span class="nc">$$Lambda$988</span><span class="o">/</span><span class="mi">1455466014</span><span class="k">@</span><span class="mi">421</span><span class="n">ead7e</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">log</span><span class="o">(</span><span class="s">&#34;Hello World&#34;</span><span class="o">,</span> <span class="n">loggerList</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="n">res1</span><span class="k">:</span> <span class="kt">UnknownLogger</span> <span class="o">=</span> <span class="nc">LogWith</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="nc">Hello</span> <span class="nc">World</span><span class="o">),</span><span class="nc">$$Lambda$989</span><span class="o">/</span><span class="mi">1705282731</span><span class="k">@</span><span class="mi">655621</span><span class="n">fd</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">log</span><span class="o">(</span><span class="s">&#34;Hello World&#34;</span><span class="o">,</span> <span class="n">loggerStdout</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="nc">Hello</span> <span class="nc">World</span>
</span></span><span class="line"><span class="cl"><span class="n">res2</span><span class="k">:</span> <span class="kt">UnknownLogger</span> <span class="o">=</span> <span class="nc">LogWith</span><span class="o">((),</span><span class="nc">$$Lambda$990</span><span class="o">/</span><span class="mi">1835105031</span><span class="k">@</span><span class="mi">340</span><span class="n">c57e0</span><span class="o">)</span></span></span></code></pre></div>
  </details>
</li>
</ul>
<details>
  <summary><strong>Remarque pour les personnes à l'aise en <em>Scala</em></strong> <em>(cliquer pour dévoiler)</em></summary>
<p>Une fois encore, en utilisant toutes les chouettes fonctionnalités syntaxiques de <em>Scala</em>,
la version satisfaisante en production du code ci-dessus est:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">UnknownLogger</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">type</span> <span class="kt">LogsType</span>
</span></span><span class="line"><span class="cl">  <span class="k">val</span> <span class="n">logs</span> <span class="k">:</span> <span class="kt">LogsType</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">appendMessage</span><span class="o">(</span><span class="n">presentLogs</span><span class="k">:</span> <span class="kt">LogsType</span><span class="o">,</span> <span class="n">message</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">LogsType</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">object</span> <span class="nc">UnknownLogger</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">LogWith</span><span class="o">[</span><span class="kt">X</span><span class="o">](</span><span class="n">logs</span> <span class="k">:</span> <span class="kt">X</span><span class="o">,</span> <span class="n">appendMessage_</span> <span class="k">:</span> <span class="o">(</span><span class="kt">X</span><span class="o">,</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">X</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">UnknownLogger</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">type</span> <span class="kt">LogsType</span> <span class="o">=</span> <span class="n">X</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="n">appendMessage</span><span class="o">(</span><span class="n">presentLogs</span><span class="k">:</span> <span class="kt">LogsType</span><span class="o">,</span> <span class="n">message</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">LogsType</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">appendMessage_</span><span class="o">(</span><span class="n">presentLogs</span><span class="o">,</span> <span class="n">message</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">X</span><span class="o">](</span><span class="n">logs</span><span class="k">:</span> <span class="kt">X</span><span class="o">,</span> <span class="n">appendMessage</span><span class="k">:</span> <span class="o">(</span><span class="kt">X</span><span class="o">,</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">X</span><span class="o">)</span><span class="k">:</span> <span class="kt">UnknownLogger</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="nc">LogWith</span><span class="o">[</span><span class="kt">X</span><span class="o">](</span><span class="n">logs</span><span class="o">,</span> <span class="n">appendMessage</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
</details>
<h3 id="conclusion-intermédiaire">Conclusion Intermédiaire</h3>
<p>Les <em>GADTs</em> ne sont en fait que ceci: de simples <em>sealed trait</em> avec quelques
<em>case object</em> (possiblement aucun) et quelques <em>final case class</em> (également possiblement aucune!).
Dans les parties suivantes, nous explorerons quelques un des cas d&rsquo;utilisation
majeurs des <em>GADTs</em>.</p>
<h2 id="cas-dutilisation-simples-et-utiles-relations-sur-les-types">Cas d&rsquo;utilisation simples et utiles: relations sur les types</h2>
<p>Une faculté simple mais très utile des <em>GADTs</em> est l&rsquo;expression de relations sur les types telles que:</p>
<ul>
<li>Le type <code>A</code> est-il égal au type <code>B</code>?</li>
<li>Le type <code>A</code> est-il un sous-type de <code>B</code>?</li>
</ul>
<p>Notez bien que, par définition, tout type <code>A</code> est sous-type de lui-même (c.-à-d. <code>A &lt;: A</code>),
tout comme tout entier <code>x</code> est également inférieur ou égal à lui-même <code>x ≤ x</code>.</p>
<h3 id="cas-dutilisation-témoin-dégalité-entre-types">Cas d&rsquo;Utilisation: Témoin d&rsquo;Égalité entre Types</h3>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">EqT</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Evidence</span><span class="o">[</span><span class="kt">X</span><span class="o">]()</span> <span class="k">extends</span> <span class="nc">EqT</span><span class="o">[</span><span class="kt">X</span>,<span class="kt">X</span><span class="o">]</span></span></span></code></pre></div>
<ul>
<li>
<p><strong>Question 1:</strong> Donnez une valeur de type <code>EqT[Int, Int]</code></p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Evidence</span><span class="o">[</span><span class="kt">Int</span><span class="o">]()</span> <span class="k">:</span> <span class="kt">EqT</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="n">res0</span><span class="k">:</span> <span class="kt">EqT</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Evidence</span><span class="o">()</span></span></span></code></pre></div>
  </details>
</li>
<li>
<p><strong>Question 2:</strong> Donnez une valeur de type <code>EqT[String, Int]</code></p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<p>La classe <code>Evidence</code> est l&rsquo;unique sous-classe conctrète du trait <code>EqT</code> et il est
impossible d&rsquo;en créer une autre parce que <code>EqT</code> est <code>sealed</code>. Donc une valeur <code>v : EqT[A,B]</code>
ne peut être qu&rsquo;une instance de <code>Evidence[X]</code> pour un certain type <code>X</code>, qui elle-même est
de type <code>EqT[X,X]</code>.
Ainsi il n&rsquo;y a aucun moyen d&rsquo;obtenir une valeur de type <code>EqT[String, Int]</code></p>
  </details>
</li>
<li>
<p><strong>Question 3:</strong> Soient <code>A</code> et <code>B</code> deux types (inconnus).
Si je vous donne une valeur de type <code>EqT[A,B]</code>, que pouvez-vous en déduire sur <code>A</code> et <code>B</code>?</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<p>Si je vous donne une valeur <code>v : EqT[A,B]</code>, alors vous savez que <code>v</code> est une instance
de <code>Evidence[X]</code> pour un certain type <code>X</code> (inconnu). En effet la classe <code>Evidence</code>  est la seule
et unique sous-classe concrète du <code>sealed trait</code> <code>EqT</code>. En fait, <code>Evidence[X]</code> est un sous-type de
<code>EqT[X,X]</code>. Donc <code>v : EqT[X,X]</code>. Les types <code>EqT[A,B]</code> et <code>EqT[X,X]</code> n&rsquo;ont aucune valeur en commun
si <code>A ≠ X</code> ou <code>B ≠ X</code>, donc <code>A = X</code> et <code>B = X</code>. Et donc <code>A = B</code>. CQFD.</p>
  </details>
</li>
</ul>
<details>
  <summary><strong>Remarque pour les personnes à l'aise en <em>Scala</em></strong> <em>(cliquer pour dévoiler)</em></summary>
<p>En production, il est pratique de définir <code>EqT</code> de la manière suivante, qui est bien entendu équivalente:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">EqT</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">object</span> <span class="nc">EqT</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Evidence</span><span class="o">[</span><span class="kt">X</span><span class="o">]()</span> <span class="k">extends</span> <span class="nc">EqT</span><span class="o">[</span><span class="kt">X</span>,<span class="kt">X</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">implicit</span> <span class="k">def</span> <span class="n">evidence</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span> <span class="k">:</span> <span class="kt">EqT</span><span class="o">[</span><span class="kt">X</span>,<span class="kt">X</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Evidence</span><span class="o">[</span><span class="kt">X</span><span class="o">]()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">EqT</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">ev.</span><span class="k">type</span> <span class="o">=</span> <span class="n">ev</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
</details>
<h4 id="passer-dun-type-égal-à-lautre">Passer d&rsquo;un type égal à l&rsquo;autre</h4>
<p>Si <code>A</code> et <code>B</code> sont en fait le même type, alors <code>List[A]</code> est également le même
type que <code>List[B]</code>, <code>Option[A]</code> est également le même type que <code>Option[B]</code>,
etc. De manière générale, pour n&rsquo;importe quel <code>F[_]</code>, <code>F[A]</code> est également le même type
que <code>F[B]</code>.</p>
<ul>
<li>
<p><strong>Question 4:</strong> Écrivez la fonction <code>def coerce[F[_],A,B](eqT: EqT[A,B])(fa: F[A]): F[B]</code>.</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">coerce</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">eqT</span><span class="k">:</span> <span class="kt">EqT</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">])(</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">eqT</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="k">_</span> <span class="k">:</span> <span class="kt">Evidence</span><span class="o">[</span><span class="kt">x</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">fa</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
  </details>
</li>
</ul>
<p>La bibliothèque standard de <em>Scala</em> définit déjà une classe, nommée <code>=:=[A,B]</code>
(son nom est bel et bien <code>=:=</code>), représentant l&rsquo;égalité entre types.
Je vous recommande vivement de jeter un œil
<a href="https://www.scala-lang.org/api/current/scala/$eq$colon$eq.html" rel="external" target="_self">à sa documentation (cliquez ici)</a>.
Fort heureusement, pour plus de lisibilité, <em>Scala</em> nous permet d&rsquo;écrire <code>A =:= B</code> le type <code>=:=[A,B]</code>.</p>
<p>Étant donné deux types <code>A</code> et <code>B</code>, avoir une instance (c.-à-d. objet)
de <code>A =:= B</code> prouve que <code>A</code> et <code>B</code> sont en réalité le même type,
tout comme pour <code>EqT[A,B]</code>.
Pour rappel, <code>A =:= B</code> n&rsquo;est que du sucre syntaxique pour désigner le type <code>=:=[A,B]</code>.</p>
<p>Des instances de <code>A =:= B</code> peuvent êtres crées en utilisant la fonction
<a href="https://www.scala-lang.org/api/current/scala/$less$colon$less$.html#refl[A]:A=:=A" rel="external" target="_self"><code>(&lt;:&lt;).refl[X]: X =:= X</code>
(cliquer pour voir la documentation)</a>.
Le &ldquo;symbole&rdquo; <code>&lt;:&lt;</code> est en effet un nom d&rsquo;objet valide.</p>
<ul>
<li>
<p><strong>Question 5:</strong> En utilisant la fonction <code>coerce</code> ci-dessus,
écrivez la fonction <code>def toScalaEq[A,B](eqT: EqT[A,B]): A =:= B</code>.</p>
  <details>
    <summary><em>Astuce (cliquer pour dévoiler)</em></summary>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">toScalaEq</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">eqT</span><span class="k">:</span> <span class="kt">EqT</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span><span class="k">:</span><span class="o">=</span> <span class="n">B</span> <span class="k">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* Trouver une définition pour:
</span></span></span><span class="line"><span class="cl"><span class="cm">        - le constructeur de type `F`
</span></span></span><span class="line"><span class="cl"><span class="cm">        - la valeur `fa : F[A]`
</span></span></span><span class="line"><span class="cl"><span class="cm">  */</span>
</span></span><span class="line"><span class="cl">  <span class="k">type</span> <span class="kt">F</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</span></span><span class="line"><span class="cl">  <span class="k">val</span> <span class="n">fa</span> <span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Telles que cet appel: */</span>
</span></span><span class="line"><span class="cl">  <span class="n">coerce</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">eqT</span><span class="o">)(</span><span class="n">fa</span><span class="o">)</span> <span class="c1">// soit de type `F[B]`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}</span></span></span></code></pre></div>
  </details>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">toScalaEq</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">eqT</span><span class="k">:</span> <span class="kt">EqT</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span><span class="k">:</span><span class="o">=</span> <span class="n">B</span> <span class="k">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">type</span> <span class="kt">F</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span> <span class="k">=</span> <span class="n">A</span> <span class="o">=:=</span> <span class="n">X</span>
</span></span><span class="line"><span class="cl">  <span class="k">val</span> <span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">(&lt;:&lt;).</span><span class="n">refl</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">  <span class="n">coerce</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">eqT</span><span class="o">)(</span><span class="n">fa</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
  </details>
</li>
<li>
<p><strong>Question 6:</strong> En utilisant la <em>méthode</em> <code>substituteCo[F[_]](ff: F[A]): F[B]</code> des
objets de la classe <code>A =:= B</code>, dont la
<a href="https://www.scala-lang.org/api/current/scala/$eq$colon$eq.html#substituteCo[F[_]](ff:F[From]):F[To]" rel="external" target="_self">documentation est ici</a>,
écrivez la fonction <code>def fromScalaEq[A,B](scala: A =:= B): EqT[A,B]</code>.</p>
  <details>
    <summary><em>Astuce (cliquer pour dévoiler)</em></summary>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">fromScalaEq</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">scala</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span><span class="k">:</span><span class="o">=</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">EqT</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* Trouver une définition pour:
</span></span></span><span class="line"><span class="cl"><span class="cm">        - le constructeur de type `F`
</span></span></span><span class="line"><span class="cl"><span class="cm">        - la valeur `fa : F[A]`
</span></span></span><span class="line"><span class="cl"><span class="cm">  */</span>
</span></span><span class="line"><span class="cl">  <span class="k">type</span> <span class="kt">F</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</span></span><span class="line"><span class="cl">  <span class="k">val</span> <span class="n">fa</span> <span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Telles que cet appel: */</span>
</span></span><span class="line"><span class="cl">  <span class="n">scala</span><span class="o">.</span><span class="n">substituteCo</span><span class="o">[</span><span class="kt">F</span><span class="o">](</span><span class="n">fa</span><span class="o">)</span> <span class="c1">// soit de type `F[B]`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">}</span></span></span></code></pre></div>
  </details>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">fromScalaEq</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">scala</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span><span class="k">:</span><span class="o">=</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">EqT</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">type</span> <span class="kt">F</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span> <span class="k">=</span> <span class="nc">EqT</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">X</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">  <span class="k">val</span> <span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Evidence</span><span class="o">[</span><span class="kt">A</span><span class="o">]()</span>
</span></span><span class="line"><span class="cl">  <span class="n">scala</span><span class="o">.</span><span class="n">substituteCo</span><span class="o">[</span><span class="kt">F</span><span class="o">](</span><span class="n">fa</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
  </details>
</li>
</ul>
<h3 id="cas-dutilisation-témoin-de-sous-typage">Cas d&rsquo;Utilisation: Témoin de Sous-Typage</h3>
<p>Dans cette section, nous voulons créer les types <code>SubTypeOf[A,B]</code> dont les valeurs
prouvent que le type <code>A</code> est un sous-type de <code>B</code> (c.-à-d. <code>A &lt;: B</code>).
Une classe similaire, <em>mais différente</em>, est déjà définie dans la
bibliothèque standard de <em>Scala</em>.
Il s&rsquo;agit de la classe <code>&lt;:&lt;[A,B]</code>, qui est le plus souvent écrite <code>A &lt;:&lt; B</code>. Sa
<a href="https://www.scala-lang.org/api/current/scala/$less$colon$less.html" rel="external" target="_self">documentation est ici</a>.
Cette section étant dédiée à l&rsquo;implémentation d&rsquo;une variante de cette classe,
veuillez <strong>ne pas utiliser</strong> <code>&lt;:&lt;[A,B]</code> pour implémenter <code>SubTypeOf</code>.</p>
<ul>
<li>
<p><strong>Question 1:</strong> En utilisant uniquement des <em>bornes supérieures</em> (c.-à-d. <code>A &lt;: B</code>)
ou <em>bornes inférieures</em> (c.-à-d. <code>A &gt;: B</code>) et <strong>aucune</strong> <em>annotation de variance</em>
(c.-à-d. <code>[+A]</code> et <code>[-A]</code>),
créez le trait <code>SubTypeOf[A,B]</code> (et tout ce qui est nécessaire) tel que:</p>
<blockquote>
<p>Il existe une valeur de type <code>SubType[A,B]</code> <strong>si et seulement si</strong>
<code>A</code> est un sous-type de <code>B</code> (c.-à-d. <code>A &lt;: B</code>).</p></blockquote>
<p>Pour rappel, par définition, un type <code>A</code> est un sous-type de lui-même (c.-à-d. <code>A &lt;: A</code>).</p>
<p>Pour rappel, n&rsquo;utilisez pas la classe <code>&lt;:&lt;[A,B]</code>.</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">SubTypeOf</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">SubTypeEvidence</span><span class="o">[</span><span class="kt">A</span> <span class="k">&lt;:</span> <span class="kt">B</span>, <span class="kt">B</span><span class="o">]()</span> <span class="k">extends</span> <span class="nc">SubTypeOf</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span></span></span></code></pre></div>
  <details>
    <summary><strong>Remarque pour les personnes à l'aise en <em>Scala</em></strong> <em>(cliquer pour dévoiler)</em></summary>
<p>En production, il est pratique de définir <code>SubTypeOf</code> de la manière équivalente suivante:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">SubTypeOf</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">object</span> <span class="nc">SubTypeOf</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Evidence</span><span class="o">[</span><span class="kt">A</span> <span class="k">&lt;:</span> <span class="kt">B</span>, <span class="kt">B</span><span class="o">]()</span> <span class="k">extends</span> <span class="nc">SubTypeOf</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">implicit</span> <span class="k">def</span> <span class="n">evidence</span><span class="o">[</span><span class="kt">A</span> <span class="k">&lt;:</span> <span class="kt">B</span>, <span class="kt">B</span><span class="o">]</span><span class="k">:</span> <span class="kt">SubTypeOf</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Evidence</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">SubTypeOf</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">ev.</span><span class="k">type</span> <span class="o">=</span> <span class="n">ev</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
  </details>
  </details>
</li>
</ul>
<h3 id="cas-dutilisation-éviter-les-messages-derreur-de-scalac-à-propos-des-bornes-non-respectées">Cas d&rsquo;Utilisation: Éviter les messages d&rsquo;erreur de <em>scalac</em> à propos des bornes non respectées</h3>
<p>Dans cet exemple, nous voulons modéliser le régime alimentaire de certains animaux.
Commençons par définir le type <code>Food</code> (c.-à-d. nourriture) et quelques-uns de ces sous-types:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">trait</span> <span class="nc">Food</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Vegetable</span> <span class="k">extends</span> <span class="nc">Food</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Fruit</span> <span class="k">extends</span> <span class="nc">Food</span></span></span></code></pre></div>
<p>et maintenant la classe représentant les animaux mangeant de la nourriture de type <code>A</code>
(c.-à-d. <code>Vegetable</code>, <code>Fruit</code>, etc):</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">AnimalEating</span><span class="o">[</span><span class="kt">A</span> <span class="k">&lt;:</span> <span class="kt">Food</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nc">val</span> <span class="n">elephant</span> <span class="k">:</span> <span class="kt">AnimalEating</span><span class="o">[</span><span class="kt">Vegetable</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="k">new</span> <span class="nc">AnimalEating</span><span class="o">[</span><span class="kt">Vegetable</span><span class="o">]</span></span></span></code></pre></div>
<p>Définissons une fonction comme il en existe tant en <em>Programmation Fonctionnelle</em>
et passons lui <code>elephant</code> comme argument:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">dummy</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">&#34;Ok!&#34;</span></span></span></code></pre></div>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">dummy</span><span class="o">[</span><span class="kt">List</span>, <span class="kt">Int</span><span class="o">](</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">))</span>
</span></span><span class="line"><span class="cl"><span class="n">res0</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">Ok</span><span class="o">!</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">dummy</span><span class="o">[</span><span class="kt">Option</span>, <span class="kt">Boolean</span><span class="o">](</span><span class="nc">Some</span><span class="o">(</span><span class="kc">true</span><span class="o">))</span>
</span></span><span class="line"><span class="cl"><span class="n">res1</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">Ok</span><span class="o">!</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">dummy</span><span class="o">[</span><span class="kt">AnimalEating</span>, <span class="kt">Vegetable</span><span class="o">](</span><span class="n">elephant</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">            <span class="o">^</span>
</span></span><span class="line"><span class="cl">       <span class="n">error</span><span class="k">:</span> <span class="kt">kinds</span> <span class="kt">of</span> <span class="kt">the</span> <span class="k">type</span> <span class="kt">arguments</span> <span class="o">(</span><span class="kt">AnimalEating</span><span class="o">,</span><span class="kt">Vegetable</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">       <span class="k">do</span> <span class="n">not</span> <span class="n">conform</span> <span class="n">to</span> <span class="n">the</span> <span class="n">expected</span> <span class="n">kinds</span> <span class="n">of</span> <span class="n">the</span> <span class="k">type</span> <span class="kt">parameters</span> <span class="o">(</span><span class="k">type</span> <span class="kt">F</span><span class="o">,</span><span class="k">type</span> <span class="kt">A</span><span class="o">).</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">       <span class="nc">AnimalEating</span>&#39;s <span class="k">type</span> <span class="kt">parameters</span> <span class="kt">do</span> <span class="kt">not</span> <span class="kt">match</span> <span class="k">type</span> <span class="kt">F</span><span class="err">&#39;</span><span class="kt">s</span> <span class="kt">expected</span> <span class="kt">parameters:</span>
</span></span><span class="line"><span class="cl">       <span class="k">type</span> <span class="kt">A</span><span class="err">&#39;</span><span class="kt">s</span> <span class="kt">bounds</span> <span class="k">&lt;:</span> <span class="kt">Food</span> <span class="kt">are</span> <span class="kt">stricter</span> <span class="kt">than</span>
</span></span><span class="line"><span class="cl">       <span class="k">type</span> <span class="k">_</span><span class="err">&#39;</span><span class="kt">s</span> <span class="kt">declared</span> <span class="kt">bounds</span> <span class="k">&gt;:</span> <span class="kt">Nothing</span> <span class="k">&lt;:</span> <span class="kt">Any</span></span></span></code></pre></div>
<ul>
<li>
<p><strong>Question 1:</strong> Pourquoi <em>scalac</em> se plaint il?</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<p>La fonction <code>dummy</code> requiert que son argument <code>F</code>, qui est un constructeur
de type comme le sont <code>List</code>, <code>Option</code>, <code>Future</code>, etc, accepte n&rsquo;importe quel type
en argument afin qu&rsquo;il soit toujours possible d&rsquo;écrire <code>F[A]</code> pour n&rsquo;importe quel type <code>A</code>.
Hors <code>AnimalEating</code> impose que son argument soit un sous-type de <code>Food</code>.
Donc <code>AnimalEating</code> ne peut être utilisé comme argument <code>F</code> de <code>dummy</code>.</p>
  </details>
</li>
</ul>
<p>Le problème est que, en définissant <code>class AnimalEating[A &lt;: Food]</code>,
nous avons imposé à <code>A</code> d&rsquo;être un sous-type de <code>Food</code>. Donc <em>Scala</em>, tout comme <em>Java</em>,
nous interdit de donner à <code>AnimalEating</code>, en tant qu&rsquo;argument <code>A</code>, autre chose
qu&rsquo;un sous-type de <code>Food</code> (en incluant <code>Food</code> lui-même):</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="k">type</span> <span class="kt">T1</span> <span class="o">=</span> <span class="nc">AnimalEating</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">                 <span class="o">^</span>
</span></span><span class="line"><span class="cl">       <span class="n">error</span><span class="k">:</span> <span class="k">type</span> <span class="kt">arguments</span> <span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">do</span> <span class="n">not</span> <span class="n">conform</span>
</span></span><span class="line"><span class="cl">       <span class="n">to</span> <span class="k">class</span> <span class="nc">AnimalEating</span>&#39;s <span class="k">type</span> <span class="kt">parameter</span> <span class="kt">bounds</span> <span class="o">[</span><span class="kt">A</span> <span class="k">&lt;:</span> <span class="kt">Food</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="k">type</span> <span class="kt">T2</span> <span class="o">=</span> <span class="nc">AnimalEating</span><span class="o">[</span><span class="kt">Food</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="n">defined</span> <span class="k">type</span> <span class="kt">alias</span> <span class="kt">T2</span></span></span></code></pre></div>
<p>Nous sommes face à un dilemme: afin d&rsquo;utiliser la fonction <code>dummy</code>, que nous tenons
beaucoup à utiliser parce c&rsquo;est une fonction très utile, il nous faut supprimer la
contrainte <code>A &lt;: Food</code> de la définition <code>class AnimalEating[A &lt;: Food]</code>.
Mais nous tenons également au fait que les animaux ne mangent que de la nourriture (<code>Food</code>)
et pas des entiers, ni des booléens et encore moins des chaînes de caractères!</p>
<ul>
<li>
<p><strong>Question 2:</strong> Comment pouvez vous adapter la définition de <code>AnimalEating</code> telle que:</p>
<ul>
<li>
<p>Il soit possible d&rsquo;appeler <code>dummy</code> avec comme argument <code>elephant</code>! Nous voulons:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">dummy</span><span class="o">[</span><span class="kt">AnimalEating</span>, <span class="kt">Vegetable</span><span class="o">](</span><span class="n">elephant</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="n">res0</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">Ok</span><span class="o">!</span></span></span></code></pre></div>
</li>
<li>
<p><em>Si</em> <code>A</code> <strong>n&rsquo;est pas un sous-type</strong> de <code>Food</code> (<code>Food</code> lui-même inclus),
<em>alors</em> il doit être <strong>impossible</strong> de créer une instance de <code>AnimalEating[A]</code>.</p>
</li>
<li>
<p>La classe <code>AnimalEating</code> <strong>doit</strong> rester une classe ouverte
(c.-à-d. non <code>sealed</code> ou <code>final</code>)! Il doit toujours être possible pour n&rsquo;importe qui,
n&rsquo;importe quand, de créer librement des sous-classes de <code>AnimalEating</code>.
Bien évidemment, ces sous-classes doivent respecter les deux contraintes
ci-dessus.</p>
<details>
  <summary><em>Astuce (cliquer pour dévoiler)</em></summary>
<p>En <em>Scala</em>, <code>Nothing</code> est un type ne contenant aucune valeur.
Pouvez vous créer une valeur de type <code>(Nothing, Int)</code>? Pourquoi?</p>
</details>
<details>
  <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<p>Si, afin de créer une instance de <code>AnimalEating[A]</code>, nous forçons <strong>chaque</strong>
méthode créant des valeurs à prendre un paramètre supplémentaire de type <code>SubTypeOf[A, Food]</code>,
alors il sera uniquement possible de créer une instance de <code>AnimalEating[A]</code>
quand <code>A</code> sera un sous-type de <code>Food</code>:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">AnimalEating</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">ev</span> <span class="k">:</span> <span class="kt">SubTypeOf</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">Food</span><span class="o">])</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">elephant</span> <span class="k">:</span> <span class="kt">AnimalEating</span><span class="o">[</span><span class="kt">Vegetable</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="k">new</span> <span class="nc">AnimalEating</span><span class="o">[</span><span class="kt">Vegetable</span><span class="o">](</span><span class="nc">SubTypeEvidence</span><span class="o">[</span><span class="kt">Vegetable</span>, <span class="kt">Food</span><span class="o">])</span></span></span></code></pre></div>
<p>Pour créer une valeur de type <code>AnimalEating[A]</code>, nous avons besoin d&rsquo;appeler
le constructeur d&rsquo;<code>AnimalEating</code>. Pour appeler ce constructeur,
il nous faut fournir <code>ev : SubTypeOf[A, Food]</code>.</p>
<p>Il nous est désormais possible d&rsquo;appeler la fonction <code>dummy</code> sur <code>elephant</code>:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">dummy</span><span class="o">[</span><span class="kt">AnimalEating</span>, <span class="kt">Vegetable</span><span class="o">](</span><span class="n">elephant</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="n">res0</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">Ok</span><span class="o">!</span></span></span></code></pre></div>
<p>En pratique, en utilisant des implicites, le compilateur peut
fournir de lui-même le paramètre <code>ev : SubTypeOf[A, Food]</code>.</p>
<p>Notez qu&rsquo;il est désormais possible d&rsquo;écrire le type <code>AnimalEating[Int]</code>
mais vous ne pourrez jamais créer une valeur de ce type.</p>
</details>
</li>
</ul>
</li>
</ul>
<h3 id="cas-dutilisation-fournir-les-bonnes-données-au-bon-diagramme">Cas d&rsquo;Utilisation: Fournir les bonnes données au bon diagramme</h3>
<p>Ce cas d&rsquo;utilisation traite des méthodes pour garantir, à la compilation,
que seulement les valeurs du bon type peuvent être données à une fonction donnée.
L&rsquo;exemple choisi est celui de la conception d&rsquo;une bibliothèque de graphiques.
Afin de simplifier l&rsquo;exemple, nous considèrerons que notre bibliothèque n&rsquo;implémente
que deux types de graphique:
des <a href="https://www.google.com/search?q=pie+chart&tbm=isch" rel="external" target="_self">camemberts (c.-à-d. pie charts)</a>
et des <a href="https://www.google.com/search?q=xy+charts&tbm=isch" rel="external" target="_self">graphiques dit XY (c.-à-d. XY charts)</a>.
Cela s&rsquo;écrit en <em>Scala</em> via l&rsquo;énumération:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">ChartType</span>
</span></span><span class="line"><span class="cl"><span class="k">case</span> <span class="k">object</span> <span class="nc">PieChart</span> <span class="k">extends</span> <span class="nc">ChartType</span>
</span></span><span class="line"><span class="cl"><span class="k">case</span> <span class="k">object</span> <span class="nc">XYChart</span> <span class="k">extends</span> <span class="nc">ChartType</span></span></span></code></pre></div>
<p>Bien évidemment les camemberts (<em>Pie</em>) et graphiques <em>XY</em> s&rsquo;appuient sur des jeux de données de
nature différente. Encore une fois, pour simplifier, nous considèrerons que les deux types
de données sont <code>PieData</code> pour les camemberts et <code>XYData</code> pour les graphiques <em>XY</em>:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">PieData</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">XYData</span></span></span></code></pre></div>
<p>Un camembert (<code>PieChart</code>) n&rsquo;affiche <strong>que</strong> des données <code>PieData</code>,
alors qu&rsquo;un graphique <em>XY</em> (<code>XYChart</code>) n&rsquo;affiche <strong>que</strong> des données <code>XYData</code>.
Voici, grandement simplifiée, la fonction d&rsquo;affichage <code>draw</code>:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">draw</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">chartType</span><span class="k">:</span> <span class="kt">ChartType</span><span class="o">)(</span><span class="n">data</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">chartType</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">PieChart</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">pieData</span> <span class="k">=</span> <span class="n">data</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">PieData</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Faire des trucs pour tracer les données pieData
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="o">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">XYChart</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">xyData</span> <span class="k">=</span> <span class="n">data</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">XYData</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Faire des trucs pour tracer les données xyData
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="o">()</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
<p>Cette fonction repose sur l&rsquo;hypothèse que l&rsquo;utilisateur·rice n&rsquo;appellera la
fonction <code>draw</code> que sur le bon type de données.
Quand <code>chartType</code> vaut <code>PieChart</code>, la fonction présuppose, via
<code>data.asInstanceOf[PieData]</code> que <code>data</code> est en fait du type <code>PieData</code>.
Et quand <code>chartType</code> vaut <code>XYChart</code>, elle présuppose que <code>data</code> est en fait
de type <code>XYData</code>.</p>
<p>Le problème est que ces suppositions reposent sur l&rsquo;idée que les utilisateurs·rices et/ou
développeurs·euses s&rsquo;assureront toujours que ces hypothèses soient bien respectées.
Mais <strong>rien</strong> n&rsquo;empêche quelqu&rsquo;un·e d&rsquo;appeler <code>draw</code> sur un camembert (<code>PieChart</code>)
avec des données de type <code>XYData</code> (ou le contraire),
faisant planter le système misérablement en production!</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">draw</span><span class="o">(</span><span class="nc">PieChart</span><span class="o">)(</span><span class="k">new</span> <span class="nc">XYData</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">ClassCastException</span><span class="k">:</span> <span class="kt">XYData</span> <span class="kt">cannot</span> <span class="kt">be</span> <span class="kt">cast</span> <span class="kt">to</span> <span class="kt">PieData</span>
</span></span><span class="line"><span class="cl">  <span class="n">at</span> <span class="o">.</span><span class="n">draw</span><span class="o">(&lt;</span><span class="n">pastie</span><span class="k">&gt;:</span><span class="mi">11</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">...</span> <span class="mi">28</span> <span class="n">elided</span></span></span></code></pre></div>
<p>En tant que développeurs·euses, nous savons que les erreurs, ça arrive!
Nous voulons un moyen d&rsquo;empêcher ces bogues ennuyeux de survenir en production!
Nous voulons imposer, à la compilation, que seulement deux scenarii soit possibles:</p>
<ul>
<li>Quand <code>draw</code> est appelée avec <code>chartType == PieChart</code>:
l&rsquo;argument <code>data</code> doit être de type <code>PieData</code></li>
<li>Quand <code>draw</code> est appelée avec <code>chartType == XYChart</code>:
l&rsquo;argument <code>data</code> doit être de type <code>XYData</code>.</li>
</ul>
<p>Pour rappel, ces deux contraintes doivent être vérifiées à la compilation!</p>
<ul>
<li>
<p><strong>Question 1:</strong> Adaptez les définitions de <code>ChartType</code>, <code>PieChart</code>, <code>XYChart</code> et <code>draw</code> telles que:</p>
<ul>
<li>
<p>Tout scenario différent des deux ci-dessus fera échouer la compilation sur une erreur de type.</p>
</li>
<li>
<p><code>ChartType</code> doit toujours être un <code>sealed trait</code>. Mais il est autorisé à prendre des <em>paramètres de type</em> (c.-à-d. <em>generics</em>).</p>
</li>
<li>
<p><code>PieChart</code> et <code>XYChar</code> doivent toujours être des <code>case object</code>
et ils doivent toujours étendre <code>ChartType</code>.</p>
</li>
<li>
<p>Les déclarations de <code>ChartType</code>, <code>PieChart</code> et <code>XYChar</code>
ne doivent <strong>pas</strong> avoir <strong>de corps</strong> du tout
(c.-à-d. il ne doit pas y avoir d&rsquo;accolades <code>{ ... }</code> dans leurs déclarations);</p>
</li>
</ul>
  <details>
    <summary><em>Astuce (cliquer pour dévoiler)</em></summary>
<p>Le code ressemble à ceci:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">ChartType</span><span class="o">[</span><span class="kt">/*METTRE</span> <span class="kt">LES</span> <span class="kt">GENERICS</span> <span class="kt">ICI*/</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">case</span> <span class="k">object</span> <span class="nc">PieChart</span> <span class="k">extends</span> <span class="nc">ChartType</span><span class="o">[</span><span class="kt">/*Il</span> <span class="kt">y</span> <span class="kt">a</span> <span class="kt">quelque</span> <span class="kt">chose</span> <span class="kt">à</span> <span class="kt">écrire</span> <span class="kt">ici*/</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">case</span> <span class="k">object</span> <span class="nc">XYChart</span> <span class="k">extends</span> <span class="nc">ChartType</span><span class="o">[</span><span class="kt">/*Il</span> <span class="kt">y</span> <span class="kt">a</span> <span class="kt">quelque</span> <span class="kt">chose</span> <span class="kt">à</span> <span class="kt">écrire</span> <span class="kt">ici</span> <span class="kt">aussi*/</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">draw</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">chartType</span><span class="k">:</span> <span class="kt">ChartType</span><span class="o">[</span><span class="kt">/*Ecrire</span> <span class="kt">quelque</span> <span class="kt">chose</span> <span class="kt">ici*/</span><span class="o">])(</span><span class="n">data</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl"> <span class="n">chartType</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">PieChart</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">pieData</span> <span class="k">:</span> <span class="kt">PieData</span> <span class="o">=</span> <span class="n">data</span>
</span></span><span class="line"><span class="cl">      <span class="o">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">XYChart</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">xyData</span><span class="k">:</span> <span class="kt">XYData</span> <span class="o">=</span> <span class="n">data</span>
</span></span><span class="line"><span class="cl">      <span class="o">()</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span></span></span></code></pre></div>
  </details>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">ChartType</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">case</span> <span class="k">object</span> <span class="nc">PieChart</span> <span class="k">extends</span> <span class="nc">ChartType</span><span class="o">[</span><span class="kt">PieData</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">case</span> <span class="k">object</span> <span class="nc">XYChart</span> <span class="k">extends</span> <span class="nc">ChartType</span><span class="o">[</span><span class="kt">XYData</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">draw</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">chartType</span><span class="k">:</span> <span class="kt">ChartType</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">data</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl"> <span class="n">chartType</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">PieChart</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">pieData</span> <span class="k">:</span> <span class="kt">PieData</span> <span class="o">=</span> <span class="n">data</span>
</span></span><span class="line"><span class="cl">      <span class="o">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">XYChart</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">xyData</span><span class="k">:</span> <span class="kt">XYData</span> <span class="o">=</span> <span class="n">data</span>
</span></span><span class="line"><span class="cl">      <span class="o">()</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span></span></span></code></pre></div>
  </details>
</li>
</ul>
<p>Vous pouvez maintenant dormir sur vos deux oreilles avec l&rsquo;assurance que
votre code en production ne plantera pas à cause d&rsquo;une entrée non conforme
à cet endroit 😉</p>
<h2 id="cas-dutilisation-plus-avancés">Cas d&rsquo;Utilisation Plus Avancés</h2>
<p>Maintenant que vous avez vu ce que sont les <em>GADTs</em> et comment les utiliser dans
la vie de tous les jours, vous êtes prêt·e pour les cas d&rsquo;utilisations plus conséquents
ci-dessous.
Il y en a trois. Chacun illustre une manière différente d&rsquo;utiliser la puissance des <em>GADTs</em>.
Le <a href="../../posts/les_gadts_par_l_exemple/index.html#cas-d-utilisation-les-effets">premier</a> traite de l&rsquo;expression d&rsquo;effets,
ce qui est très largement utilisé dans chaque monade <em>IO</em> populaire ou effets algébriques.
Ne vous inquiétez pas de ne pas savoir ce que sont ces derniers, cette section l&rsquo;expliquera.
Le <a href="../../posts/les_gadts_par_l_exemple/index.html#cas-d-utilisation-s-assurer-que-les-types-sont-pris-en-charge-par-la-base-de-données">second</a>
s&rsquo;attache à montrer comment garantir des propriétés dans le système de types.
Ce point est illustré à travers l&rsquo;exemple de l’accommodation des techniques issues
de la programmation fonctionnelle aux contraintes issues des bases de données.
Le <a href="../../posts/les_gadts_par_l_exemple/index.html#cas-d-utilisation-simplifier-les-implicites">troisième</a> offre une manière plus simple
de travailler avec des implicites.</p>
<h3 id="cas-dutilisation-les-effets">Cas d&rsquo;Utilisation: Les Effets!</h3>
<p>Ce qui est appelé un effet est parfois juste une interface déclarant quelques
fonctions dépourvues d&rsquo;implémentation. Par exemple nous pouvons définir le
<code>trait</code> ci-dessous. Notez qu&rsquo;<em>aucune</em> de ces fonctions n&rsquo;a d&rsquo;implémentation.</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">trait</span> <span class="nc">ExampleEffectSig</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">echo</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">randomInt</span> <span class="k">:</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">ignore</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p>Les implémentations de ces interfaces (traits) sont données ailleurs, et il peut en avoir beaucoup!
Cela est utile quand il est désirable de changer facilement d&rsquo;implémentation:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">object</span> <span class="nc">ExampleEffectImpl</span> <span class="k">extends</span> <span class="nc">ExampleEffectSig</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">echo</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">value</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">randomInt</span> <span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">scala</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">Random</span><span class="o">.</span><span class="n">nextInt</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">ignore</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">()</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p>Une manière équivalente de définir <code>ExampleEffectSig</code> est via un <code>sealed trait</code>
muni de quelques <code>final case class</code> (peut-être aucune!) et/ou quelques <code>case object</code> (peut-être aucun!):</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">ExampleEffect</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">Echo</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">ExampleEffect</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">RandomInt</span> <span class="k">extends</span> <span class="nc">ExampleEffect</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">Ignore</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">ExampleEffect</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span></span></span></code></pre></div>
<p>De nouveau, nous avons des déclarations ne fournissant aucune implémentation!
De nouveau, leurs implémentations peuvent être fournies ailleurs et il peut en avoir beaucoup:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">runExampleEffect</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">effect</span><span class="k">:</span> <span class="kt">ExampleEffect</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">effect</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">Echo</span><span class="o">(</span><span class="n">value</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">value</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">RandomInt</span>   <span class="k">=&gt;</span> <span class="n">scala</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">Random</span><span class="o">.</span><span class="n">nextInt</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">Ignore</span><span class="o">(</span><span class="k">_</span><span class="o">)</span>   <span class="k">=&gt;</span> <span class="o">()</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
<p>Prenons un effet plus réaliste ainsi qu&rsquo;une de ses implémentations possibles:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">trait</span> <span class="nc">EffectSig</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">currentTimeMillis</span><span class="k">:</span> <span class="kt">Long</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">printLn</span><span class="o">(</span><span class="n">msg</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">mesure</span><span class="o">[</span><span class="kt">X</span>,<span class="kt">A</span><span class="o">](</span><span class="n">fun</span><span class="k">:</span> <span class="kt">X</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">,</span> <span class="n">arg</span><span class="k">:</span> <span class="kt">X</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">object</span> <span class="nc">EffectImpl</span> <span class="k">extends</span> <span class="nc">EffectSig</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">currentTimeMillis</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">printLn</span><span class="o">(</span><span class="n">msg</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="n">println</span><span class="o">(</span><span class="n">msg</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">mesure</span><span class="o">[</span><span class="kt">X</span>,<span class="kt">A</span><span class="o">](</span><span class="n">fun</span><span class="k">:</span> <span class="kt">X</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">,</span> <span class="n">arg</span><span class="k">:</span> <span class="kt">X</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">val</span> <span class="n">t0</span> <span class="k">=</span> <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">val</span> <span class="n">r</span>  <span class="k">=</span> <span class="n">fun</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">val</span> <span class="n">t1</span> <span class="k">=</span> <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">println</span><span class="o">(</span><span class="s">s&#34;Took </span><span class="si">${</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="si">}</span><span class="s"> milli-seconds&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">r</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<ul>
<li>
<p><strong>Question 1:</strong> Tout comme <code>ExampleEffect</code> est l&rsquo;équivalent de <code>ExampleEffectSig</code>
via la définition d&rsquo;un <code>sealed trait</code> muni de quelques <code>final case class</code> et
<code>case object</code>, écrivez l&rsquo;équivalent de <code>EffectSig</code> de la même manière.
Appelez ce trait <code>Effect</code>.</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">CurrentTimeMillis</span> <span class="k">extends</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">PrintLn</span><span class="o">(</span><span class="n">msg</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">Mesure</span><span class="o">[</span><span class="kt">X</span>,<span class="kt">A</span><span class="o">](</span><span class="n">fun</span><span class="k">:</span> <span class="kt">X</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">,</span> <span class="n">arg</span><span class="k">:</span> <span class="kt">X</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span></span></span></code></pre></div>
  </details>
</li>
<li>
<p><strong>Question 2:</strong> Écrivez la fonction <code>def run[A](effect: Effect[A]): A</code> qui reproduit l&rsquo;implémentation de
<code>EffectImpl</code> tout comme <code>runExampleEffect</code> reproduit celle de <code>ExampleEffectImpl</code>.</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">run</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">effect</span><span class="k">:</span> <span class="kt">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">effect</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">CurrentTimeMillis</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">PrintLn</span><span class="o">(</span><span class="n">msg</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="n">println</span><span class="o">(</span><span class="n">msg</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">Mesure</span><span class="o">(</span><span class="n">fun</span><span class="o">,</span> <span class="n">arg</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">t0</span> <span class="k">=</span> <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">r</span>  <span class="k">=</span> <span class="n">fun</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">t1</span> <span class="k">=</span> <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">      <span class="n">println</span><span class="o">(</span><span class="s">s&#34;Took </span><span class="si">${</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="si">}</span><span class="s"> milli-seconds&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">r</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
  </details>
</li>
</ul>
<p>Le type <code>Effect[A]</code> déclare des effets intéressants (<code>CurrentTimeMillis</code>,
<code>PrintLn</code> et <code>Mesure</code>) mais pour être réellement utile, il doit être possible
de chaîner ces effets! Pour ce faire, nous voulons pouvoir disposer des deux fonctions suivantes:</p>
<ul>
<li><code>def pure[A](value: A): Effect[A]</code></li>
<li><code>def flatMap[X,A](fx: Effect[X], f: X =&gt; Effect[A]): Effect[A]</code></li>
</ul>
<p>De nouveau, nous ne nous intéressons pas à leurs implémentations. Tout ce que nous
voulons, pour le moment, est déclarer ces deux opérations de la même manière que
nous avons déclaré <code>CurrentTimeMillis</code>, <code>PrintLn</code> et <code>Mesure</code>.</p>
<ul>
<li>
<p><strong>Question 3:</strong> Ajoutez deux <em>final case classes</em>, <code>Pure</code> et <code>FlatMap</code>,
à <code>Effect[A]</code> déclarant ces deux opérations.</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">CurrentTimeMillis</span> <span class="k">extends</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">PrintLn</span><span class="o">(</span><span class="n">msg</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">Mesure</span><span class="o">[</span><span class="kt">X</span>,<span class="kt">A</span><span class="o">](</span><span class="n">fun</span><span class="k">:</span> <span class="kt">X</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">,</span> <span class="n">arg</span><span class="k">:</span> <span class="kt">X</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">Pure</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">FlatMap</span><span class="o">[</span><span class="kt">X</span>,<span class="kt">A</span><span class="o">](</span><span class="n">fx</span><span class="k">:</span> <span class="kt">Effect</span><span class="o">[</span><span class="kt">X</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">X</span> <span class="o">=&gt;</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span></span></span></code></pre></div>
  </details>
</li>
<li>
<p><strong>Question 4:</strong> Adaptez la fonction <code>run</code> pour gérer ces deux nouveaux cas.</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">run</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">effect</span><span class="k">:</span> <span class="kt">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">effect</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">CurrentTimeMillis</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">PrintLn</span><span class="o">(</span><span class="n">msg</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="n">println</span><span class="o">(</span><span class="n">msg</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">Mesure</span><span class="o">(</span><span class="n">fun</span><span class="o">,</span> <span class="n">arg</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">t0</span> <span class="k">=</span> <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">r</span>  <span class="k">=</span> <span class="n">fun</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">t1</span> <span class="k">=</span> <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">      <span class="n">println</span><span class="o">(</span><span class="s">s&#34;Took </span><span class="si">${</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="si">}</span><span class="s"> milli-seconds&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">r</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">Pure</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="n">a</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">FlatMap</span><span class="o">(</span><span class="n">fx</span><span class="o">,</span> <span class="n">f</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">x</span>  <span class="k">=</span> <span class="n">run</span><span class="o">(</span><span class="n">fx</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">fa</span> <span class="k">:</span> <span class="kt">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">run</span><span class="o">(</span><span class="n">fa</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
  </details>
</li>
<li>
<p><strong>Question 5:</strong> Ajoutez les deux méthodes suivantes au trait <code>Effect[A]</code> pour obtenir:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">final</span> <span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Effect</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nc">FlatMap</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">f</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="k">final</span> <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Effect</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">]((</span><span class="n">a</span><span class="k">:</span><span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Pure</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)))</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p>Et exécutez le code suivant pour voir s&rsquo;il fonctionne:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">effect1</span><span class="k">:</span> <span class="kt">Effect</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">t0</span> <span class="k">&lt;-</span> <span class="nc">CurrentTimeMillis</span>
</span></span><span class="line"><span class="cl">    <span class="k">_</span>  <span class="k">&lt;-</span> <span class="nc">PrintLn</span><span class="o">(</span><span class="s">s&#34;The current time is </span><span class="si">$t0</span><span class="s">&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span> <span class="k">yield</span> <span class="o">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">run</span><span class="o">(</span><span class="n">effect1</span><span class="o">)</span></span></span></code></pre></div>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">final</span> <span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Effect</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nc">FlatMap</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">f</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="k">final</span> <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Effect</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">]((</span><span class="n">a</span><span class="k">:</span><span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Pure</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)))</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">CurrentTimeMillis</span> <span class="k">extends</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">PrintLn</span><span class="o">(</span><span class="n">msg</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">Mesure</span><span class="o">[</span><span class="kt">X</span>,<span class="kt">A</span><span class="o">](</span><span class="n">fun</span><span class="k">:</span> <span class="kt">X</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">,</span> <span class="n">arg</span><span class="k">:</span> <span class="kt">X</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">Pure</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">FlatMap</span><span class="o">[</span><span class="kt">X</span>,<span class="kt">A</span><span class="o">](</span><span class="n">fx</span><span class="k">:</span> <span class="kt">Effect</span><span class="o">[</span><span class="kt">X</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">X</span> <span class="o">=&gt;</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="n">run</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">effect</span><span class="k">:</span> <span class="kt">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">effect</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">CurrentTimeMillis</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">PrintLn</span><span class="o">(</span><span class="n">msg</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="n">println</span><span class="o">(</span><span class="n">msg</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">Mesure</span><span class="o">(</span><span class="n">fun</span><span class="o">,</span> <span class="n">arg</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">t0</span> <span class="k">=</span> <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">r</span>  <span class="k">=</span> <span class="n">fun</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">t1</span> <span class="k">=</span> <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">      <span class="n">println</span><span class="o">(</span><span class="s">s&#34;Took </span><span class="si">${</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="si">}</span><span class="s"> milli-seconds&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">r</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">Pure</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="n">a</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">FlatMap</span><span class="o">(</span><span class="n">fx</span><span class="o">,</span> <span class="n">f</span><span class="o">)</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">x</span>  <span class="k">=</span> <span class="n">run</span><span class="o">(</span><span class="n">fx</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">fa</span> <span class="k">:</span> <span class="kt">Effect</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">run</span><span class="o">(</span><span class="n">fa</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">effect1</span><span class="k">:</span> <span class="kt">Effect</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">t0</span> <span class="k">&lt;-</span> <span class="nc">CurrentTimeMillis</span>
</span></span><span class="line"><span class="cl">    <span class="k">_</span>  <span class="k">&lt;-</span> <span class="nc">PrintLn</span><span class="o">(</span><span class="s">s&#34;The current time is </span><span class="si">$t0</span><span class="s">&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span> <span class="k">yield</span> <span class="o">()</span></span></span></code></pre></div>
<p>En exécutant <code>run(effect1)</code> on obtient:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="n">scala</span><span class="o">&gt;</span> <span class="n">run</span><span class="o">(</span><span class="n">effect1</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="nc">The</span> <span class="n">current</span> <span class="n">time</span> <span class="n">is</span> <span class="mi">1569773175010</span></span></span></code></pre></div>
  </details>
</li>
</ul>
<p>Félicitations! Vous venez d&rsquo;écrire votre première monade <em>IO</em>! Il y
a de nombreux noms scientifiques au <code>sealed trait Effect[A]</code>:
vous pouvez l&rsquo;appeler un <em>effet algébrique</em>, une <em>monade libre</em>, une <em>IO</em>, etc.
Mais au bout du compte, ce n&rsquo;est qu&rsquo;un simple et banal <code>sealed trait</code> pour lequel
nous avons défini quelques <code>final case class</code> et <code>case object</code> afin de
représenter les fonctions dont nous voulions disposer sans fournir
leurs implémentations (<code>CurrentTimeMillis</code>, <code>PrintLn</code>, <code>Mesure</code>,
<code>Pure</code> et <code>FlatMap</code>). Vous pouvez les appeler des <em>méthodes virtuelles</em> si vous voulez.
<strong>Ce qui importe réellement est d&rsquo;avoir isolé la définition de ces fonctions de leurs implémentations.</strong>
Rappelez vous qu&rsquo;un <code>trait</code> est juste une interface après tout.</p>
<h3 id="cas-dutilisation-sassurer-que-les-types-sont-pris-en-charge-par-la-base-de-données">Cas d&rsquo;Utilisation: S&rsquo;assurer que les types sont pris en charge par la Base De Données.</h3>
<p>Les bases de données sont formidables. Nous pouvons y stocker des tables, des documents,
des paires clef/valeur, des graphes, etc.
Mais, pour n&rsquo;importe quelle base de données, il y a malheureusement seulement un nombre limité
de types pris en charge.
Prenez la base de données que vous voulez, je suis sûr de pouvoir trouver des types qu&rsquo;elle
ne prend pas en charge.</p>
<p>Dans cette section, nous allons nous intéresser au cas des structures des données
et du code qui ne marche pas pour tout les types, mais seulement certains! Ce cas d&rsquo;usage
ne se limite pas aux bases de données mais concerne chaque <em>interface de programmation</em> qui ne
supporte qu&rsquo;un nombre limité de types (la vaste majorité des <em>interfaces de programmation</em>).
Comment s&rsquo;assurer du respect de ces contraintes? Comment adapter les techniques que nous aimons
afin qu&rsquo;elles travaillent sous ces contraintes? Voilà ce dont il s&rsquo;agit dans cette section.</p>
<p>Nous considérerons une base de données fictive qui ne prend en charge <strong>que</strong> les types suivants:</p>
<ol>
<li><code>String</code></li>
<li><code>Double</code></li>
<li><code>(A,B)</code> où <code>A</code> et <code>B</code> sont également des types pris en charge par la base de données.</li>
</ol>
<p>Cela signifie que les valeurs stockées dans la base de données (dans des tables, des paires clef/valeur,
etc) <strong>doivent</strong> respecter les règles ci-dessus. Elle peut stocker <code>&quot;Hello World&quot;</code> parce que c&rsquo;est une
<code>String</code>, qui est est un type pris en charge par la base de données en vertu de la règle <em>1</em>.
Pour les mêmes raisons, elle peut stocker <code>5.2</code> parce que c&rsquo;est un <code>Double</code>,
mais elle ne peut <strong>pas</strong> stocker l&rsquo;entier <code>5</code> parce que c&rsquo;est un<code>Int</code>.
Elle peut stocker <code>(&quot;Hello World&quot;, 5.2)</code> grâce à la règle <em>3</em> ainsi que
<code>((&quot;Hello World&quot;, 5.2) , 8.9)</code>, de nouveau grâce à la règle <em>3</em>.</p>
<ul>
<li>
<p><strong>Question 1:</strong> Définissez le type <code>DBType[A]</code> tel que:</p>
<blockquote>
<p>Il existe une valeur de type <code>DBType[A]</code> <strong>si et seulement si</strong> <code>A</code>
est un type pris en charge par la base de données.</p></blockquote>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<p>La version simple est:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">DBType</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">DBString</span> <span class="k">extends</span> <span class="nc">DBType</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">DBDouble</span> <span class="k">extends</span> <span class="nc">DBType</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span>  <span class="nc">DBPair</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">first</span><span class="k">:</span> <span class="kt">DBType</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">second</span><span class="k">:</span> <span class="kt">DBType</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">DBType</span><span class="o">[(</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">)]</span></span></span></code></pre></div>
  <details>
  <summary><strong>Remarque pour les personnes à l'aise en <em>Scala</em></strong> <em>(cliquer pour dévoiler)</em></summary>
<p>En utilisant toutes les chouettes fonctionnalités syntaxiques de <em>Scala</em>,
la version satisfaisante en production du code ci-dessus est:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">DBType</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">object</span> <span class="nc">DBType</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">DBString</span> <span class="k">extends</span> <span class="nc">DBType</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">  <span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">DBDouble</span> <span class="k">extends</span> <span class="nc">DBType</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">DBPair</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">first</span><span class="k">:</span> <span class="kt">DBType</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">second</span><span class="k">:</span> <span class="kt">DBType</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">DBType</span><span class="o">[(</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">)]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">implicit</span> <span class="k">val</span> <span class="n">dbString</span> <span class="k">:</span> <span class="kt">DBType</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="nc">DBString</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">implicit</span> <span class="k">val</span> <span class="n">dbDouble</span> <span class="k">:</span> <span class="kt">DBType</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="nc">DBDouble</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">implicit</span> <span class="k">def</span> <span class="n">dbPair</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="k">implicit</span> <span class="n">first</span><span class="k">:</span> <span class="kt">DBType</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">second</span><span class="k">:</span> <span class="kt">DBType</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">DBType</span><span class="o">[(</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">)]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="nc">DBPair</span><span class="o">(</span><span class="n">first</span><span class="o">,</span> <span class="n">second</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">DBType</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">ev.</span><span class="k">type</span> <span class="o">=</span> <span class="n">ev</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
  </details>
  </details>
</li>
</ul>
<p>En utilisant <code>DBType</code>, nous pouvons coupler une valeur de type <code>A</code>
avec une valeur de type <code>DBType[A]</code>, fournissant ainsi la preuve que
le type <code>A</code> est pris en charge par la base de données:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">DBValue</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="k">val</span> <span class="n">dbType</span><span class="k">:</span> <span class="kt">DBType</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span></span></span></code></pre></div>
<p>Notez que le paramètre <code>dbType</code> n&rsquo;a nullement besoin d&rsquo;être implicite!
Ce qui compte est que pour créer une valeur de type <code>DBValue[A]</code>,
nous devons fournir une valeur de type <code>DBType[A]</code>
ce qui force <code>A</code> à être un type pris en charge par la base de données.</p>
<p>Un <em>foncteur</em> est, de manière informelle et approximative, un constructeur de type<code>F</code>,
comme <code>List</code>, <code>Option</code>, <code>DBValue</code>, etc,
pour lequel il est possible de fournir une instance du trait:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">trait</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p>où <code>map(fa)(f)</code> applique la fonction <code>f</code> à chaque valeur de type <code>A</code> contenue dans <code>fa</code>. Par exemple:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">implicit</span> <span class="k">object</span> <span class="nc">OptionFunctor</span> <span class="k">extends</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">Option</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="n">fa</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nc">None</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<ul>
<li>
<p><strong>Question 2:</strong> Écrivez une instance de <code>Functor[DBValue]</code>.</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<p>C&rsquo;est en fait impossible! Si nous tentions de compiler le code suivant:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">object</span> <span class="nc">DBValueFunctor</span> <span class="k">extends</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">DBValue</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">DBValue</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">DBValue</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="nc">DBValue</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="o">(</span><span class="n">fa</span><span class="o">.</span><span class="n">value</span><span class="o">))</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p><em>Scala</em> râlerait: <code>could not find implicit value for parameter dbType: DBType[B]</code>. En effet, les booléens
ne sont pas un type pris en charge par la base de données:
ils ne sont ni des chaînes de caractères, ni des nombres flottants, ni des paires de types pris en charge.</p>
<p>Supposons que nous puissions définir une instance de <code>Funcor</code> pour <code>DBValue</code>
(c.-à-d. que nous puissions définir une fonction <code>map</code> pour <code>DBValue</code>), alors nous pourrions écrire:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">val</span> <span class="n">dbValueString</span>  <span class="k">:</span> <span class="kt">DBValue</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>  <span class="k">=</span> <span class="nc">DBValue</span><span class="o">(</span><span class="s">&#34;A&#34;</span><span class="o">)(</span><span class="nc">DBString</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">dbValueBoolean</span> <span class="k">:</span> <span class="kt">DBValue</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="k">=</span> <span class="n">dbValueString</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">true</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">dbTypeBoooean</span>  <span class="k">:</span> <span class="kt">DBType</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span>  <span class="k">=</span> <span class="n">dbValueBoolean</span><span class="o">.</span><span class="n">dbType</span></span></span></code></pre></div>
<p>Nous obtiendrions une valeur (<code>dbTypeBoooean</code>) de type <code>DBType[Boolean]</code>
ce qui signifirait que le type <code>Boolean</code> est pris en charge par la base de données.
Mais il ne l&rsquo;est pas! Hors par définition:</p>
<blockquote>
<p>Il existe une valeur de type <code>DBType[A]</code> <strong>si et seulement si</strong> <code>A</code>
est un type pris en charge par la base de donnée.</p></blockquote>
<p>Donc il est impossible d&rsquo;obtenir une valeur de type <code>DBType[Boolean]</code>
et donc il est impossible d&rsquo;écrire une fonction <code>map</code> pout <code>DBValue</code>.
Ainsi il n&rsquo;y a aucun moyen de définir une instance de <code>Functor</code> pour <code>DBValue</code>. CQDF.</p>
  </details>
</li>
</ul>
<p>Un <em>Foncteur Généralisé</em> est très similaire à un <code>Functor</code> classique, à la différence près
que la fonction <code>map</code> ne doit pas obligatoirement être applicable à n&rsquo;importe quels
types <code>A</code> et <code>B</code> mais peut n&rsquo;être applicable qu&rsquo;à certains types <code>A</code> et <code>B</code> particuliers:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">trait</span> <span class="nc">GenFunctor</span><span class="o">[</span><span class="kt">P</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">evA</span><span class="k">:</span> <span class="kt">P</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">evB</span><span class="k">:</span> <span class="kt">P</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p>Par exemple, <code>Set</code> (plus précisément <code>TreeSet</code>) n&rsquo;est pas un foncteur!
En effet il n&rsquo;y a aucun moyen d&rsquo;écrire une fonction <code>map</code> qui fonctionne
pour n&rsquo;importe quel type <code>B</code> (parce qu&rsquo;il est nécessaire d&rsquo;avoir une relation d&rsquo;ordre sur <code>B</code>).
Mais si l&rsquo;on restreint <code>map</code> aux seuls types <code>B</code> disposant d&rsquo;une relation d&rsquo;ordre, alors il devient
possible d&rsquo;écrire:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">import</span> <span class="nn">scala.collection.immutable._</span>
</span></span><span class="line"><span class="cl"><span class="k">object</span> <span class="nc">TreeSetFunctor</span> <span class="k">extends</span> <span class="nc">GenFunctor</span><span class="o">[</span><span class="kt">Ordering</span>, <span class="kt">TreeSet</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">TreeSet</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">evA</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">evB</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">TreeSet</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="nc">TreeSet</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">evB</span><span class="o">)</span> <span class="o">++</span> <span class="n">fa</span><span class="o">.</span><span class="n">toSeq</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">f</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<ul>
<li>
<p><strong>Question 3:</strong> Écrivez une instance de <code>GenFunctor[DBType, DBValue]</code>.</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">object</span> <span class="nc">DBValueGenFunctor</span> <span class="k">extends</span> <span class="nc">GenFunctor</span><span class="o">[</span><span class="kt">DBType</span>, <span class="kt">DBValue</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">DBValue</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">evA</span><span class="k">:</span> <span class="kt">DBType</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">evB</span><span class="k">:</span> <span class="kt">DBType</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">DBValue</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="nc">DBValue</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="o">(</span><span class="n">fa</span><span class="o">.</span><span class="n">value</span><span class="o">))(</span><span class="n">evB</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
  </details>
</li>
</ul>
<p>Ce que nous avons fait ici avec <code>Functor</code> peut être fait avec de nombreuses structures de données et
techniques de programmation. Il est souvent possible de restreindre la plage des types sur lesquels
la structure de donnée ou la classe de types (<em>type class</em>) peut opérer en ajoutant un paramètre
supplémentaire comme <code>ev : DBType[A]</code> aux constructeurs et méthodes.</p>
<h3 id="cas-dutilisation-simplifier-les-implicites">Cas d&rsquo;Utilisation: Simplifier les Implicites</h3>
<p>Ce cas d&rsquo;utilisation est l&rsquo;un des plus intéressants, mais malheureusement, pas l&rsquo;un des plus simples.
Il montre comment il est possible d&rsquo;utiliser les <em>GADTs</em> pour simplifier la création de valeurs implicites.</p>
<p>Des listes de valeurs dont les éléments peuvent être de types différents sont appelées
<em>listes hétérogènes</em>. Elles sont généralement définies en <em>Scala</em> presque comme
les listes classiques:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">HNil</span><span class="o">()</span> <span class="c1">// La liste vide
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">HCons</span><span class="o">[</span><span class="kt">Head</span>,<span class="kt">Tail</span><span class="o">](</span><span class="n">head</span><span class="k">:</span> <span class="kt">Head</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">Tail</span><span class="o">)</span> <span class="c1">// L&#39;operation: `head :: tail`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">empty</span> <span class="k">:</span> <span class="kt">HNil</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">  <span class="nc">HNil</span><span class="o">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">oneTrueToto</span> <span class="k">:</span> <span class="kt">HCons</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">HCons</span><span class="o">[</span><span class="kt">Boolean</span>, <span class="kt">HCons</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">HNil</span><span class="o">]]]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="nc">HCons</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">HCons</span><span class="o">(</span><span class="kc">true</span><span class="o">,</span> <span class="nc">HCons</span><span class="o">(</span><span class="s">&#34;toto&#34;</span><span class="o">,</span> <span class="nc">HNil</span><span class="o">())))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">val</span> <span class="n">falseTrueFive</span><span class="k">:</span> <span class="kt">HCons</span><span class="o">[</span><span class="kt">Boolean</span>, <span class="kt">HCons</span><span class="o">[</span><span class="kt">Boolean</span>, <span class="kt">HCons</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">HNil</span><span class="o">]]]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="nc">HCons</span><span class="o">(</span><span class="kc">false</span><span class="o">,</span> <span class="nc">HCons</span><span class="o">(</span><span class="kc">true</span><span class="o">,</span> <span class="nc">HCons</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="nc">HNil</span><span class="o">())))</span></span></span></code></pre></div>
<p>Comme vous pouvez le voir, il n&rsquo;y a rien de vraiment spécial à propos de ces listes.
Nous voulons définir des relations d&rsquo;ordre sur les listes hétérogènes.
Une relation d&rsquo;ordre est une façon de comparer deux valeurs (<strong>du même type!</strong>):
elles peuvent êtres égales ou l&rsquo;une peut être strictement plus petite que l&rsquo;autre.
Une relation d&rsquo;ordre sur le type <code>A</code> peut se définir en <em>Scala</em> comme une instance
de <code>Order[A]</code> défini comme suit:</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">trait</span> <span class="nc">Order</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// vrai si et seulement si a1 &lt; a2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">def</span> <span class="n">lesserThan</span><span class="o">(</span><span class="n">a1</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* a1 et a2 sont égales si et seulement si
</span></span></span><span class="line"><span class="cl"><span class="cm">     aucune d&#39;entre elles n&#39;est strictement plus petite que l&#39;autre
</span></span></span><span class="line"><span class="cl"><span class="cm">  */</span>
</span></span><span class="line"><span class="cl">  <span class="k">final</span> <span class="k">def</span> <span class="n">areEqual</span><span class="o">(</span><span class="n">a1</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">!</span><span class="n">lesserThan</span><span class="o">(</span><span class="n">a1</span><span class="o">,</span> <span class="n">a2</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">lesserThan</span><span class="o">(</span><span class="n">a2</span><span class="o">,</span> <span class="n">a1</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// a1 &gt; a2 si et seulement si a2 &lt; a1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">final</span> <span class="k">def</span> <span class="n">greaterThan</span><span class="o">(</span><span class="n">a1</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">lesserThan</span><span class="o">(</span><span class="n">a2</span><span class="o">,</span> <span class="n">a1</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">final</span> <span class="k">def</span> <span class="n">lesserThanOrEqual</span><span class="o">(</span><span class="n">a1</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">!</span><span class="n">lesserThan</span><span class="o">(</span><span class="n">a2</span><span class="o">,</span> <span class="n">a1</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">final</span> <span class="k">def</span> <span class="n">greaterThanOrEqual</span><span class="o">(</span><span class="n">a1</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">!</span><span class="n">lesserThan</span><span class="o">(</span><span class="n">a1</span><span class="o">,</span> <span class="n">a2</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">object</span> <span class="nc">Order</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">ev.</span><span class="k">type</span> <span class="o">=</span> <span class="n">ev</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">make</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">lg_</span> <span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span><span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="k">new</span> <span class="nc">Order</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">def</span> <span class="n">lesserThan</span><span class="o">(</span><span class="n">a1</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">lg_</span><span class="o">(</span><span class="n">a1</span><span class="o">,</span><span class="n">a2</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">implicit</span> <span class="k">val</span> <span class="n">orderInt</span>    <span class="k">=</span> <span class="nc">Order</span><span class="o">.</span><span class="n">make</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="k">_</span> <span class="o">&lt;</span> <span class="k">_</span><span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="k">implicit</span> <span class="k">val</span> <span class="n">orderString</span> <span class="k">=</span> <span class="nc">Order</span><span class="o">.</span><span class="n">make</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="k">_</span> <span class="o">&lt;</span> <span class="k">_</span><span class="o">)</span></span></span></code></pre></div>
<p>Pour rappel, nous ne comparerons que des listes de <em>même type</em>:</p>
<ul>
<li>Les listes de type <code>HNil</code> seront uniquement comparées à d&rsquo;autres listes de type <code>HNil</code>.</li>
<li>Les listes de type <code>HCons[H,T]</code> seront uniquement comparées à d&rsquo;autres listes de type <code>HCons[H,T]</code>.</li>
</ul>
<p>Comparer des listes de type <code>HNil</code> est trivial parce qu&rsquo;il n&rsquo;y a qu&rsquo;une seule et unique valeur
de type <code>HNil</code> (la liste vide <code>HNil()</code>). Mais il existe de nombreuses façon de comparer des listes
de type <code>HCons[H,T]</code>.
Voici deux relations d&rsquo;ordre possibles (il en existe de nombreuses autres!):</p>
<ul>
<li>
<p>L&rsquo;<em>ordre lexicographique</em> (c.-à-d. l&rsquo;ordre du dictionnaire: de la gauche vers la droite)</p>
<blockquote>
<p><code>HCons(h1,t1) &lt; HCons(h2,t2)</code> <strong>si et seulement si</strong>
<code>h1 &lt; h2</code> <em>ou</em> (<code>h1 == h2</code> <em>et</em> <code>t1 &lt; t2</code> <em>par l&rsquo;ordre lexicographique</em>).</p></blockquote>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Lex</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">val</span> <span class="n">order</span> <span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">object</span> <span class="nc">Lex</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Lex</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">ev.</span><span class="k">type</span> <span class="o">=</span> <span class="n">ev</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">implicit</span> <span class="k">val</span> <span class="n">lexHNil</span><span class="k">:</span> <span class="kt">Lex</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="k">new</span> <span class="nc">Lex</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">order</span> <span class="k">=</span> <span class="nc">Order</span><span class="o">.</span><span class="n">make</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]((</span><span class="k">_</span><span class="o">,</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="kc">false</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">implicit</span> <span class="k">def</span> <span class="n">lexHCons</span><span class="o">[</span><span class="kt">Head</span>,<span class="kt">Tail</span><span class="o">](</span><span class="k">implicit</span>
</span></span><span class="line"><span class="cl">      <span class="n">orderHead</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">Head</span><span class="o">],</span>
</span></span><span class="line"><span class="cl">      <span class="n">lexTail</span><span class="k">:</span> <span class="kt">Lex</span><span class="o">[</span><span class="kt">Tail</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">    <span class="o">)</span><span class="k">:</span> <span class="kt">Lex</span><span class="o">[</span><span class="kt">HCons</span><span class="o">[</span><span class="kt">Head</span>, <span class="kt">Tail</span><span class="o">]]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="k">new</span> <span class="nc">Lex</span><span class="o">[</span><span class="kt">HCons</span><span class="o">[</span><span class="kt">Head</span>, <span class="kt">Tail</span><span class="o">]]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">orderTail</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">Tail</span><span class="o">]</span> <span class="k">=</span> <span class="n">lexTail</span><span class="o">.</span><span class="n">order</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">order</span> <span class="k">=</span> <span class="nc">Order</span><span class="o">.</span><span class="n">make</span><span class="o">[</span><span class="kt">HCons</span><span class="o">[</span><span class="kt">Head</span>, <span class="kt">Tail</span><span class="o">]]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="o">(</span><span class="nc">HCons</span><span class="o">(</span><span class="n">h1</span><span class="o">,</span><span class="n">t1</span><span class="o">),</span> <span class="nc">HCons</span><span class="o">(</span><span class="n">h2</span><span class="o">,</span><span class="n">t2</span><span class="o">))</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="n">orderHead</span><span class="o">.</span><span class="n">lesserThan</span><span class="o">(</span><span class="n">h1</span><span class="o">,</span><span class="n">h2</span><span class="o">)</span> <span class="o">||</span> <span class="o">(</span><span class="n">orderHead</span><span class="o">.</span><span class="n">areEqual</span><span class="o">(</span><span class="n">h1</span><span class="o">,</span><span class="n">h2</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">orderTail</span><span class="o">.</span><span class="n">lesserThan</span><span class="o">(</span><span class="n">t1</span><span class="o">,</span><span class="n">t2</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">      <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
</li>
<li>
<p>L&rsquo;<em>ordre lexicographique inversé</em> qui est la version à l&rsquo;envers de l&rsquo;ordre lexicographique
(c.-à-d. de droite à gauche)</p>
<blockquote>
<p><code>HCons(h1,t1) &lt; HCons(h2,t2)</code> <strong>si et seulement si</strong>
(<code>t1 &lt; t2</code> <em>par ordre lexicographique inversé</em>) <em>ou</em> (<code>t1 == t2</code> <em>et</em> <code>h1 &lt; h2</code>).</p></blockquote>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">RevLex</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">val</span> <span class="n">order</span> <span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">object</span> <span class="nc">RevLex</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">RevLex</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">ev.</span><span class="k">type</span> <span class="o">=</span> <span class="n">ev</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">implicit</span> <span class="k">val</span> <span class="n">revLexHNil</span><span class="k">:</span> <span class="kt">RevLex</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="k">new</span> <span class="nc">RevLex</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">order</span> <span class="k">=</span> <span class="nc">Order</span><span class="o">.</span><span class="n">make</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]((</span><span class="k">_</span><span class="o">,</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="kc">false</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">implicit</span> <span class="k">def</span> <span class="n">revLexHCons</span><span class="o">[</span><span class="kt">Head</span>,<span class="kt">Tail</span><span class="o">](</span><span class="k">implicit</span>
</span></span><span class="line"><span class="cl">      <span class="n">orderHead</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">Head</span><span class="o">],</span>
</span></span><span class="line"><span class="cl">      <span class="n">revLexTail</span><span class="k">:</span> <span class="kt">RevLex</span><span class="o">[</span><span class="kt">Tail</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">    <span class="o">)</span><span class="k">:</span> <span class="kt">RevLex</span><span class="o">[</span><span class="kt">HCons</span><span class="o">[</span><span class="kt">Head</span>, <span class="kt">Tail</span><span class="o">]]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="k">new</span> <span class="nc">RevLex</span><span class="o">[</span><span class="kt">HCons</span><span class="o">[</span><span class="kt">Head</span>, <span class="kt">Tail</span><span class="o">]]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">orderTail</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">Tail</span><span class="o">]</span> <span class="k">=</span> <span class="n">revLexTail</span><span class="o">.</span><span class="n">order</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">order</span> <span class="k">=</span> <span class="nc">Order</span><span class="o">.</span><span class="n">make</span><span class="o">[</span><span class="kt">HCons</span><span class="o">[</span><span class="kt">Head</span>, <span class="kt">Tail</span><span class="o">]]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="o">(</span><span class="nc">HCons</span><span class="o">(</span><span class="n">h1</span><span class="o">,</span><span class="n">t1</span><span class="o">),</span> <span class="nc">HCons</span><span class="o">(</span><span class="n">h2</span><span class="o">,</span><span class="n">t2</span><span class="o">))</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="n">orderTail</span><span class="o">.</span><span class="n">lesserThan</span><span class="o">(</span><span class="n">t1</span><span class="o">,</span><span class="n">t2</span><span class="o">)</span> <span class="o">||</span> <span class="o">(</span><span class="n">orderTail</span><span class="o">.</span><span class="n">areEqual</span><span class="o">(</span><span class="n">t1</span><span class="o">,</span><span class="n">t2</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">orderHead</span><span class="o">.</span><span class="n">lesserThan</span><span class="o">(</span><span class="n">h1</span><span class="o">,</span><span class="n">h2</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">      <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
</li>
</ul>
<p>Comme dit plus haut, il est possible de définir davantage de relations d&rsquo;ordre:</p>
<ul>
<li>
<p><strong>Question 1:</strong> L&rsquo;ordre <code>Alternate</code> est défini par:</p>
<blockquote>
<p><code>HCons(h1,t1) &lt; HCons(h2,t2)</code> <strong>si et seulement si</strong>
<code>h1 &lt; h2</code> <em>ou</em> (<code>h1 == h2</code> <em>et</em> <code>t1 &gt; t2</code> <em>par ordre</em> <code>Alternate</code>).</p></blockquote>
<p>En suivant la méthoe employée pour <code>Lex</code> and <code>RevLex</code>,
implémentez l&rsquo;ordre <code>Alternate</code>.</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Alternate</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">val</span> <span class="n">order</span> <span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">object</span> <span class="nc">Alternate</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Alternate</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">ev.</span><span class="k">type</span> <span class="o">=</span> <span class="n">ev</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">implicit</span> <span class="k">val</span> <span class="n">alternateHNil</span><span class="k">:</span> <span class="kt">Alternate</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="k">new</span> <span class="nc">Alternate</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">order</span> <span class="k">=</span> <span class="nc">Order</span><span class="o">.</span><span class="n">make</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]((</span><span class="k">_</span><span class="o">,</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="kc">false</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">implicit</span> <span class="k">def</span> <span class="n">alternateHCons</span><span class="o">[</span><span class="kt">Head</span>,<span class="kt">Tail</span><span class="o">](</span><span class="k">implicit</span>
</span></span><span class="line"><span class="cl">      <span class="n">orderHead</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">Head</span><span class="o">],</span>
</span></span><span class="line"><span class="cl">      <span class="n">alternateTail</span><span class="k">:</span> <span class="kt">Alternate</span><span class="o">[</span><span class="kt">Tail</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">    <span class="o">)</span><span class="k">:</span> <span class="kt">Alternate</span><span class="o">[</span><span class="kt">HCons</span><span class="o">[</span><span class="kt">Head</span>, <span class="kt">Tail</span><span class="o">]]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="k">new</span> <span class="nc">Alternate</span><span class="o">[</span><span class="kt">HCons</span><span class="o">[</span><span class="kt">Head</span>, <span class="kt">Tail</span><span class="o">]]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">orderTail</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">Tail</span><span class="o">]</span> <span class="k">=</span> <span class="n">alternateTail</span><span class="o">.</span><span class="n">order</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">order</span> <span class="k">=</span> <span class="nc">Order</span><span class="o">.</span><span class="n">make</span><span class="o">[</span><span class="kt">HCons</span><span class="o">[</span><span class="kt">Head</span>, <span class="kt">Tail</span><span class="o">]]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="o">(</span><span class="nc">HCons</span><span class="o">(</span><span class="n">h1</span><span class="o">,</span><span class="n">t1</span><span class="o">),</span> <span class="nc">HCons</span><span class="o">(</span><span class="n">h2</span><span class="o">,</span><span class="n">t2</span><span class="o">))</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="n">orderHead</span><span class="o">.</span><span class="n">lesserThan</span><span class="o">(</span><span class="n">h1</span><span class="o">,</span><span class="n">h2</span><span class="o">)</span> <span class="o">||</span> <span class="o">(</span><span class="n">orderHead</span><span class="o">.</span><span class="n">areEqual</span><span class="o">(</span><span class="n">h1</span><span class="o">,</span><span class="n">h2</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">orderTail</span><span class="o">.</span><span class="n">greaterThan</span><span class="o">(</span><span class="n">t1</span><span class="o">,</span><span class="n">t2</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">      <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
  </details>
</li>
</ul>
<p>Il existe de nombreuses manières de définir une relation d&rsquo;ordre valide sur les listes hétérogènes!
Créer une classe de type (<em>type class</em>) comme <code>Lex</code>, <code>RevLex</code> et <code>Alternate</code> pour chaque relation
d&rsquo;ordre voulue est fatigant et propice aux erreurs. Nous pouvons faire bien mieux &hellip;
avec un <em>GADT</em> 😉</p>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">HListOrder</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></span><span class="line"><span class="cl"><span class="nc">object</span> <span class="nc">HListOrder</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">HNilOrder</span> <span class="k">extends</span> <span class="nc">HListOrder</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">HConsOrder</span><span class="o">[</span><span class="kt">Head</span>,<span class="kt">Tail</span><span class="o">](</span>
</span></span><span class="line"><span class="cl">      <span class="n">orderHead</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">Head</span><span class="o">],</span>
</span></span><span class="line"><span class="cl">      <span class="n">hlistOrderTail</span><span class="k">:</span> <span class="kt">HListOrder</span><span class="o">[</span><span class="kt">Tail</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">    <span class="o">)</span> <span class="k">extends</span> <span class="nc">HListOrder</span><span class="o">[</span><span class="kt">HCons</span><span class="o">[</span><span class="kt">Head</span>,<span class="kt">Tail</span><span class="o">]]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Définitions des Implicites
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="k">implicit</span> <span class="k">val</span> <span class="n">hnilOrder</span> <span class="k">:</span> <span class="kt">HListOrder</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="nc">HNilOrder</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">implicit</span> <span class="k">def</span> <span class="n">hconsOrder</span><span class="o">[</span><span class="kt">Head</span>,<span class="kt">Tail</span><span class="o">](</span><span class="k">implicit</span>
</span></span><span class="line"><span class="cl">      <span class="n">orderHead</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">Head</span><span class="o">],</span>
</span></span><span class="line"><span class="cl">      <span class="n">hlistOrderTail</span><span class="k">:</span> <span class="kt">HListOrder</span><span class="o">[</span><span class="kt">Tail</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">    <span class="o">)</span><span class="k">:</span> <span class="kt">HListOrder</span><span class="o">[</span><span class="kt">HCons</span><span class="o">[</span><span class="kt">Head</span>,<span class="kt">Tail</span><span class="o">]]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">    <span class="nc">HConsOrder</span><span class="o">(</span><span class="n">orderHead</span><span class="o">,</span> <span class="n">hlistOrderTail</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">HListOrder</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">ev.</span><span class="k">type</span> <span class="o">=</span> <span class="n">ev</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div>
<p>Il est à noter que la définition de ces implicites est du pur boilerplate. Leur seule
raison d&rsquo;être est de passer leurs arguments au constructeur correspondant
(c.-à-d. <code>final case class</code> ou <code>case object</code>):
<code>hnilOrder</code> à <code>HListOrder</code> (O arguments) et <code>hconsOrder</code> à <code>HConsOrder</code> (2 arguments).</p>
<ul>
<li>
<p><strong>Question 2:</strong> Écrivez une fonction <code>def lex[A](implicit v : HListOrder[A]): Order[A]</code>
qui retourne l&rsquo;ordre lexicographique à partir d&rsquo;une valeur de type <code>HListOrder[A]</code>.</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">lex</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">implicit</span> <span class="n">v</span> <span class="k">:</span> <span class="kt">HListOrder</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">v</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">HListOrder</span><span class="o">.</span><span class="nc">HNilOrder</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nc">Order</span><span class="o">.</span><span class="n">make</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]((</span><span class="k">_</span><span class="o">,</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="kc">false</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="n">hc</span> <span class="k">:</span> <span class="kt">HListOrder.HConsOrder</span><span class="o">[</span><span class="kt">head</span>,<span class="kt">tail</span><span class="o">]</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">orderHead</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">head</span><span class="o">]</span> <span class="k">=</span> <span class="n">hc</span><span class="o">.</span><span class="n">orderHead</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">orderTail</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">tail</span><span class="o">]</span> <span class="k">=</span> <span class="n">lex</span><span class="o">(</span><span class="n">hc</span><span class="o">.</span><span class="n">hlistOrderTail</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="nc">Order</span><span class="o">.</span><span class="n">make</span><span class="o">[</span><span class="kt">HCons</span><span class="o">[</span><span class="kt">head</span>, <span class="kt">tail</span><span class="o">]]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="o">(</span><span class="nc">HCons</span><span class="o">(</span><span class="n">h1</span><span class="o">,</span><span class="n">t1</span><span class="o">),</span> <span class="nc">HCons</span><span class="o">(</span><span class="n">h2</span><span class="o">,</span><span class="n">t2</span><span class="o">))</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="n">orderHead</span><span class="o">.</span><span class="n">lesserThan</span><span class="o">(</span><span class="n">h1</span><span class="o">,</span><span class="n">h2</span><span class="o">)</span> <span class="o">||</span> <span class="o">(</span><span class="n">orderHead</span><span class="o">.</span><span class="n">areEqual</span><span class="o">(</span><span class="n">h1</span><span class="o">,</span><span class="n">h2</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">orderTail</span><span class="o">.</span><span class="n">lesserThan</span><span class="o">(</span><span class="n">t1</span><span class="o">,</span><span class="n">t2</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">      <span class="o">}</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
  </details>
</li>
<li>
<p><strong>Question 3:</strong> Écrivez une fonction <code>def revLex[A](implicit v : HListOrder[A]): Order[A]</code>
qui retourne l&rsquo;ordre lexicographique inversé à partir d&rsquo;une valeur de type <code>HListOrder[A]</code>.</p>
  <details>
    <summary><em>Solution (cliquer pour dévoiler)</em></summary>
<div class="highlight wrap-code" dir="auto"><pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl"><span class="k">def</span> <span class="n">revLex</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">implicit</span> <span class="n">v</span> <span class="k">:</span> <span class="kt">HListOrder</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">v</span> <span class="k">match</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nc">HListOrder</span><span class="o">.</span><span class="nc">HNilOrder</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nc">Order</span><span class="o">.</span><span class="n">make</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]((</span><span class="k">_</span><span class="o">,</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="kc">false</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="n">hc</span> <span class="k">:</span> <span class="kt">HListOrder.HConsOrder</span><span class="o">[</span><span class="kt">head</span>,<span class="kt">tail</span><span class="o">]</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">orderHead</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">head</span><span class="o">]</span> <span class="k">=</span> <span class="n">hc</span><span class="o">.</span><span class="n">orderHead</span>
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">orderTail</span><span class="k">:</span> <span class="kt">Order</span><span class="o">[</span><span class="kt">tail</span><span class="o">]</span> <span class="k">=</span> <span class="n">revLex</span><span class="o">(</span><span class="n">hc</span><span class="o">.</span><span class="n">hlistOrderTail</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="nc">Order</span><span class="o">.</span><span class="n">make</span><span class="o">[</span><span class="kt">HCons</span><span class="o">[</span><span class="kt">head</span>, <span class="kt">tail</span><span class="o">]]</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="o">(</span><span class="nc">HCons</span><span class="o">(</span><span class="n">h1</span><span class="o">,</span><span class="n">t1</span><span class="o">),</span> <span class="nc">HCons</span><span class="o">(</span><span class="n">h2</span><span class="o">,</span><span class="n">t2</span><span class="o">))</span> <span class="k">=&gt;</span>
</span></span><span class="line"><span class="cl">          <span class="n">orderTail</span><span class="o">.</span><span class="n">lesserThan</span><span class="o">(</span><span class="n">t1</span><span class="o">,</span><span class="n">t2</span><span class="o">)</span> <span class="o">||</span> <span class="o">(</span><span class="n">orderTail</span><span class="o">.</span><span class="n">areEqual</span><span class="o">(</span><span class="n">t1</span><span class="o">,</span><span class="n">t2</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">orderHead</span><span class="o">.</span><span class="n">lesserThan</span><span class="o">(</span><span class="n">h1</span><span class="o">,</span><span class="n">h2</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">      <span class="o">}</span>
</span></span><span class="line"><span class="cl">  <span class="o">}</span></span></span></code></pre></div>
  </details>
</li>
</ul>
<p>Cette approche a de nombreux avantages. Alors que l&rsquo;approche initiale devait effectuer
une recherche d&rsquo;implicites pour chaque relation d&rsquo;ordre, l&rsquo;approche par <em>GADT</em> n&rsquo;a besoin
de faire cette recherche qu&rsquo;une seule fois!
Sachant que la résolution d&rsquo;implicites est une opération gourmande, la réduire signifie des
temps de compilation plus courts.
Lire le code des fonctions <code>lex</code> et <code>revLex</code> est également plus simple que comprendre
comment la résolution d&rsquo;implicites fonctionne pour les traits <code>Lex</code> et <code>RevLex</code>.
De plus, ce ne sont que des fonctions, vous pouvez y utiliser tout ce que vous pouvez
programmer afin de construire les instances de <code>Order[A]</code>.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Pas si trivial, n&rsquo;est-ce pas? 😉 En fait, une grande part de la complexité
à laquelle vous venez de faire face vient du triste fait que les techniques
de raisonnements sur les types et valeurs ne sont presque jamais enseignées dans
les cours de programmation.
Ce que vous trouvez simple maintenant (API Web, Streaming, Bases De Données, etc)
terrifierait probablement la/le jeune programmeuse·eur que vous étiez à votre
premier &ldquo;Hello World!&rdquo;.
Vous n&rsquo;avez probablement pas appris tout ce que vous savez en programmation en
trois heures, donc n&rsquo;attendez pas des techniques de raisonnement sur des programmes
d&rsquo;êtres magiquement plus simples.</p>
<p>Cet atelier avait pour but de vous inspirer, d&rsquo;ouvrir votre esprit à ce nouvel univers
de possibilités. Si vous trouvez ces cas d&rsquo;utilisation intéressants, alors prenez le temps
de comprendre les techniques.</p>
<p>Amusez vous bien et prenez bien soin de vous ❤️</p>

  <footer class="footline">
    
  </footer>
</article>
        </div>
      </main>
    </div>
    <script src="../../js/clipboard/clipboard.min.js?1750073986" defer></script>
    <script src="../../js/perfect-scrollbar/perfect-scrollbar.min.js?1750073986" defer></script>
    <script>
      window.MathJax = Object.assign( window.MathJax || {}, {
        tex: {
          inlineMath:  [['\\(', '\\)'], ['$',  '$']],  
          displayMath: [['\\[', '\\]'], ['$$', '$$']], 
        },
        options: {
          enableMenu: false 
        }
      }, JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="../../js/mathjax/tex-mml-chtml.js?1750073986"></script>
    <script src="../../js/theme.min.js?1750073986" defer></script>
  </body>
</html>
