[
{
	"uri": "https://chrilves.github.io/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " @chrilves\u0026rsquo; Archives Slides Here are the slides of the talks/workshops i gave:\n The Prime Game The Slimetail Game Not Given Yet: Converting JSON to XML: The overengineered way Elm Meetup: Introduction to Monads via Random Generators PSUG Talk - Recursion Scheems Introduction PSUG \u0026amp;\u0026amp; ScalaIO 2018 - Workshop on ScalaJS PSUG \u0026amp;\u0026amp; ScalaIO 2017 - Talk on F-Algebras  "
},
{
	"uri": "https://chrilves.github.io/posts/gadts_by_use_cases/",
	"title": "GADTs By Use Cases",
	"tags": [],
	"description": "",
	"content": " Welcome. This session will introduce you to a very powerful tool in programming. Whereas most introduction start by presenting its theoretical foundations in a very formal way, we chose to present it via short examples and practical use cases.\nThis workshop is made of three parts. The last one presents three of the most valuable use cases. They are the real big powerful use cases. But do not go there unprepared! This is the last part for a reason: they rely massively on lessons you will learn in the previous parts. Start First Contact, it will show you, via the simplest examples, the core ideas. Its goal is to open your mind to ways of using types and data you may have never imagined possible. Then go to Easy Useful Use Cases: Relations on Types, for the first real-life challenge. Then you are ready for More Advanced Use Cases.\nBe sure to read README, it contains precious tips to ease your journey.\nAcknowledgements We would like to thank Laure Juglaret for having reviewed this presentation many times, for her precious remarks and corrections.\nREADME In this presentation we will assume that:\n null does not exists! runtime-reflection does not exist! (i.e. isInstanceOf, getClass, etc)  This presentation considers that these features do not exists at all.\nUsing these features will never lead to a valid answer.\nThis presentation expects you to have access to something where you can easily write, compile and run Scala code. The best way to do so is opening a R.E.P.L. session. If you have Scala installed on your system, you can easily start one from the command-line by executing scala:\nsystem-command-line# scala Welcome to Scala 2.13.1 (OpenJDK 64-Bit Server VM, Java 1.8.0_222). Type in expressions for evaluation. Or try :help. scala\u0026gt; If you don\u0026rsquo;t have Scala installed, you can use the online-REPL https://scastie.scala-lang.org/ .\nStretching This section is a brief reminder of some definitions and properties about values and types.\nValues and Types? Values are actual piece of data your program manipulates like the integer 5, the boolean true, the string \u0026quot;Hello World!\u0026quot;, the function (x: Double) =\u0026gt; x / 7.5, the list List(1,2,3), etc. We often like to classify values into groups. These groups are called types. For example:\n Int is the group of integer values, i.e. values like 1, -7, 19, etc. Boolean is the group containing exactly the values true and false (no more, no less!). String is the group whose values are \u0026quot;Hello World!\u0026quot;, \u0026quot;\u0026quot;, \u0026quot;I ❤️ GADTs\u0026quot;, etc. Double =\u0026gt; Double is the group whose values are functions taking any Double as argument and returning some Double.  To indicate that the value v belongs to the type (i.e. group of values) T, we write v : T. In Scala, testing if a value v belongs to a type T is very simple: just type v : T in the REPL:\nscala\u0026gt; 5 : Int res7: Int = 5 If Scala accepts it, then v belongs to T. If Scala complains, it most probably does not :\nscala\u0026gt; 5 : String ^ error: type mismatch; found : Int(5) required: String How many types? Let\u0026rsquo;s now create some types and some of their values (when possible!).\nclass OneType  Question 1: How many types does the line class OneType defines?\n Solution (click to expand)\nAs the name suggests, class OneType defines only one type which is named OneType. \n  Let\u0026rsquo;s now consider:\nclass OneTypeForEvery[A]  Question 2: How many types does the line class OneTypeForEvery[A] defines?\n Solution (click to expand)\nAs the name suggests, every concrete type A give rise to a distinct type OneTypeForEvery[A].\nFor example, a list of integers is neither a list of booleans, nor a list of strings, nor a list of functions, nor \u0026hellip; It means the types List[Int], List[Boolean], List[Int =\u0026gt; Int], etc are all distinct types.\nThe line class OneTypeForEvery[A] defines a distinct type for every concrete type A. There is an infnity of concrete types A, so an infinity of distinct types OneTypeForEvery[A]. \n Question 3: Give a value that belongs to both OneTypeForEvery[Int] and OneTypeForEvery[Boolean].\nRemember that null does not exist!\n Solution (click to expand) This is actually impossible. Every concrete type A give rise a distinct type OneTypeForEvery[A] that have no values in common with others types OneTypeForEvery[B] for B ≠ A. \n  How many values? Considering the following type:\nfinal abstract class NoValueForThisType  Question 1: Give a value belonging to the type NoValueForThisType? How many values belong to NoValueForThisType?\n Hint (click to expand)\n What is a final class? How does it differ from a normal non-final class? What is an abstract class? How does it differ from a concrete class?    Solution (click to expand)\nThe class NoValueForThisType is declared abstract. It is then forbidden to create a direct instance of this class:\nscala\u0026gt; new NoValueForThisType ^ error: class NoValueForThisType is abstract; cannot be instantiated The only way to create an instance of an abstract class is creating a concrete sub-class. But the keyword final forbids creating such sub-classes:\nscala\u0026gt; class ConcreteSubClass extends NoValueForThisType ^ error: illegal inheritance from final class NoValueForThisType There is no way to create an instance of NoValueForThisType. \n  Let\u0026rsquo;s take another example:\nsealed trait ExactlyOneValue case object TheOnlyValue extends ExactlyOneValue  Question 2: Give a value belonging to the type ExactlyOneValue?\n Solution (click to expand)\nBy definition, TheOnlyValue is a value of type ExactlyOneValue. \n Question 3: How many values belong to ExactlyOneValue?\n Solution (click to expand)\nJust like above, ExactlyOneValue, being a trait, is abstract. Being sealed, extending it outside of its defining file is forbidden. So TheOnlyValue is the only value of type ExactlyOneValue. \n  First Contact This part presents the core ideas. There are actually only two ideas! What you will find here are stripped down examples to illustrate each of these ideas.\nUse Case: Evidence of some property Let\u0026rsquo;s define a simple sealed trait:\nsealed trait ATrait[A] case object AValue extends ATrait[Char]  Question 1: Give a value of type ATrait[Char].\n Solution (click to expand)\nBy definition, AValue is a value of type ATrait[Char]. \n Question 2: Give a value of type ATrait[Double].\n Solution (click to expand)\nThere is no way to have an instance of type ATrait[Double]. There is actually no way to have an instance of type ATrait[B] for B ≠ Char because the only possible value is AValue which is of type ATrait[Char]. \n Question 3: What can you conclude about a type A if you have a value ev of type ATrait[A] (i.e. ev: ATrait[A])?\n Solution (click to expand)\nThe only possible value is AValue, so ev == AValue. Furthermore AValue is of type ATrait[Char] so A = Char.\n\n Question 4: In the REPL, enter the following code:\ndef f[A](x: A, ev: ATrait[A]): Char = x Question 5: Now try pattern matching on ev: ATrait[A]\ndef f[A](x: A, ev: ATrait[A]): Char = ev match { case AValue =\u0026gt; x } Is the pattern-matching exhaustive?\n Solution (click to expand)\nThe pattern-matching is exhaustive because the only possible actual value for ev is AValue. Furthermore AValue is of type ATrait[Char] which means ev : ATrait[Char] because ev == AValue. So A = Char and x : Char. \n Question 6: Call f with x = 'w' : Char.\n Solution (click to expand)\nscala\u0026gt; f[Char](\u0026#39;w\u0026#39;, AValue) res0: Char = w \n Question 7: Call f with x = 5.2 : Double.\n Solution (click to expand)\nThis is impossible because it would require to give a value ev : ATrait[Double] which does not exist!\nscala\u0026gt; f[Double](5, AValue) ^ error: type mismatch; found : AValue.type required: ATrait[Double] \n   Remark for people fluent in Scala (click to expand) \nUsing all the nice features of Scala, the production-ready version of the code above is:\nsealed trait IsChar[A] object IsChar { implicit case object Evidence extends IsChar[Char] def apply[A](implicit evidence: IsChar[A]): IsChar[A] = evidence } def f[A: IsChar](x: A): Char = IsChar[A] match { case IsChar.Evidence =\u0026gt; x } \nUse Case: The only thing I know is it exists What would you do if you wanted your codebase to log messages, but you want to be sure your codebase do not rely on any implementation details of the logger so that you can change its implementation without risking breaking the codebase?\nTake the following logger type UnknownLogger:\nsealed trait UnknownLogger final case class LogWith[X](logs : X, appendMessage: (X, String) =\u0026gt; X) extends UnknownLogger The first logger we will create stores the logs in a String:\nval loggerStr : UnknownLogger = LogWith[String](\u0026#34;\u0026#34;, (logs: String, message: String) =\u0026gt; logs ++ message) The second logger stores them in a List[String]:\nval loggerList : UnknownLogger = LogWith[List[String]](Nil, (logs: List[String], message: String) =\u0026gt; message :: logs) The third logger directly print the messages to the standard output:\nval loggerStdout : UnknownLogger = LogWith[Unit]((), (logs: Unit, message: String) =\u0026gt; println(message)) Note that these three loggers all have the same type (i.e. UnknownLogger) but they store the logs using different types X (String, List[String] and Unit).\n Question 1: Let v be a value of type UnknownLogger. Clearly v has to be an instance of the class LogWith[X] for some type X. What can you say about the type X? Can you figure out which type X actually is?\nRemember we refuse to use runtime-reflection! (i.e. isInstanceOf, getClass, etc)\n Solution (click to expand)\nWe know almost nothing about X. The only thing we know is there exists at least one value (v.logs) of type X. Appart from that, X can be any type.\nNot knowing which type is actually X is very useful to guarantee that the code that will use v : UnknownLogger will not rely on the nature of X. If the code knew X was String for example, it could perform some operations we want to forbid like reversing the list, taking only the nth first characters, etc. By hiding the real type X, we force our codebase to not depend on what X is but to use the provided v.appendMessage. So changing the real implementation of the logger won\u0026rsquo;t break any code.\n\n Question 2: Write the function def log(message: String, v: UnknownLogger): UnknownLogger that uses v.appendMessage to append message to v.logs and returns a new UnknownLogger containing the new logs.\nRemember that in Scala, the following pattern (i.e. ac : AClass[t]) is allowed in match/case expressions:\nfinal case class AClass[A](value : A) def f[A](v: AClass[A]): A = v match { case ac : AClass[t] =\u0026gt; // The variable `t` is a type variable  // The type `t` is equal to `A`  val r : t = ac.value r } Its main benefit is introducing the type variable t. Type variables work like normal pattern variables except that they represent types instead of values. Having t enable us to help the compiler by giving explicit types (like just above, saying r is of type t).\n Solution (click to expand)\ndef log(message: String, v: UnknownLogger): UnknownLogger = v match { case vx : LogWith[x] =\u0026gt; LogWith[x](vx.appendMessage(vx.logs, message), vx.appendMessage) } \n Question 3: Execute log(\u0026quot;Hello World\u0026quot;, loggerStr) and log(\u0026quot;Hello World\u0026quot;, loggerList) and log(\u0026quot;Hello World\u0026quot;, loggerStdout)\n Solution (click to expand)\nscala\u0026gt; log(\u0026#34;Hello World\u0026#34;, loggerStr) res0: UnknownLogger = LogWith(Hello World,$$Lambda$988/1455466014@421ead7e) scala\u0026gt; log(\u0026#34;Hello World\u0026#34;, loggerList) res1: UnknownLogger = LogWith(List(Hello World),$$Lambda$989/1705282731@655621fd) scala\u0026gt; log(\u0026#34;Hello World\u0026#34;, loggerStdout) Hello World res2: UnknownLogger = LogWith((),$$Lambda$990/1835105031@340c57e0) \n   Remark for people fluent in Scala (click to expand) \nOnce again, using all the nice features of Scala, the production-ready version of the code above is:\nsealed trait UnknownLogger { type LogsType val logs : LogsType def appendMessage(presentLogs: LogsType, message: String): LogsType } object UnknownLogger { final case class LogWith[X](logs : X, appendMessage_ : (X, String) =\u0026gt; X) extends UnknownLogger { type LogsType = X def appendMessage(presentLogs: LogsType, message: String): LogsType = appendMessage_(presentLogs, message) } def apply[X](logs: X, appendMessage: (X, String) =\u0026gt; X): UnknownLogger = LogWith[X](logs, appendMessage) } \nIntermediary Conclusion GADTs are actually only this: simple sealed trait with some case object (possibly none) and some final case class (possible none too!). In the following parts we will explore some major use cases of GADTs\nEasy Useful Use Cases: Relations on Types One easy but very useful benefit of GADTs is expressing relations about types such that:\n Is type A equal to type B? Is type A a sub-type of B?  Note that, by definition, a type A is a sub-type of itself (i.e. A \u0026lt;: A), very much like an integer x is also lesser-than-or-equal to itself x ≤ x.\nUse Case: Witnessing Type Equality sealed trait EqT[A,B] final case class Evidence[X]() extends EqT[X,X]  Question 1: Give a value of type EqT[Int, Int]\n Solution (click to expand)\nscala\u0026gt; Evidence[Int]() : EqT[Int, Int] res0: EqT[Int,Int] = Evidence() \n Question 2: Give a value of type EqT[String, Int]\n Solution (click to expand)\nThe class Evidence is the only concrete sub-class of trait EqT and we cannot create another one because EqT is sealed. So any value v : EqT[A,B] has to be an instance of Evidence[X] for some type X, which is of type EqT[X,X]. Thus there is no way to get a value of type EqT[String, Int].\n\n Question 3: Given two (unknown) types A and B. What can you conclude if I give you a value of type EqT[A,B]?\n Solution (click to expand)\nIf I give you a value v : EqT[A,B], then you know that v is an instance of Evidence[X] for some type X because the class Evidence is the only concrete sub-class of the sealed trait EqT. Actually Evidence[X] is a sub-type of EqT[X,X]. Thus v : EqT[X,X]. Types EqT[A,B] and EqT[X,X] have no value in common if A ≠ X or B ≠ X, so A = X and B = X. Thus A = B.\n\n   Remark for people fluent in Scala (click to expand) \nIn production, it is convenient to define the following equivalent code:\nsealed trait EqT[A,B] object EqT { final case class Evidence[X]() extends EqT[X,X] implicit def evidence[X] : EqT[X,X] = Evidence[X]() def apply[A,B](implicit ev: EqT[A,B]): ev.type = ev } \nSwitching between equal types If A and B are actually the same type, then List[A] is also the same type as List[B], Option[A] is also the same type as Option[B], etc. More generally, for any F[_], F[A] is also the same type as F[B].\n Question 4: Write the function def coerce[F[_],A,B](eqT: EqT[A,B])(fa: F[A]): F[B].\n Solution (click to expand)\ndef coerce[F[_],A,B](eqT: EqT[A,B])(fa: F[A]): F[B] = eqT match { case _ : Evidence[x] =\u0026gt; fa } \n  The Scala standard library already defines a class, named =:=[A,B] (yes, its name is really =:=), representing type equality. You\u0026rsquo;re strongly encouraged to have a quick look at its documentation (click here). Thankfully, Scala enables to write A =:= B instead of =:=[A,B].\nGiven two types A and B, having an instance (i.e. object) of A =:= B means that A and B are actually the same type, just like with EqT[A,B]. Remember that A =:= B is just syntactic sugar for =:=[A,B].\nInstances of A =:= B can be created by the function (\u0026lt;:\u0026lt;).refl[X]: X =:= X (click for docs). The \u0026ldquo;symbol\u0026rdquo; \u0026lt;:\u0026lt; is indeed a valid name for an object.\n Question 5: Using the function coerce above, write the function def toScalaEq[A,B](eqT: EqT[A,B]): A =:= B.\n Hint (click to expand)\ndef toScalaEq[A,B](eqT: EqT[A,B]): A =:= B = { /* Find a definition for: - the type constructor `F` - the value `fa : F[A]` */ type F[X] = ??? val fa : F[A] = ??? /* Such that this call: */ coerce[F,A,B](eqT)(fa) // is of type `F[B]` } \n Solution (click to expand)\ndef toScalaEq[A,B](eqT: EqT[A,B]): A =:= B = { type F[X] = A =:= X val fa: F[A] = (\u0026lt;:\u0026lt;).refl[A] coerce[F,A,B](eqT)(fa) } \n Question 6: Using the method substituteCo[F[_]](ff: F[A]): F[B] of objects of class A =:= B, whose documentation is here, write the function def fromScalaEq[A,B](scala: A =:= B): EqT[A,B].\n Hint (click to expand)\ndef fromScalaEq[A,B](scala: A =:= B): EqT[A,B] = { /* Find a definition for: - the type constructor `F` - the value `fa : F[A]` */ type F[X] = ??? val fa : F[A] = ??? /* Such that this call: */ scala.substituteCo[F](fa) // is of type `F[B]` } \n Solution (click to expand)\ndef fromScalaEq[A,B](scala: A =:= B): EqT[A,B] = { type F[X] = EqT[A,X] val fa: F[A] = Evidence[A]() scala.substituteCo[F](fa) } \n  Use Case: Witnessing Sub Typing In this section, we want to create types SubTypeOf[A,B] whose values prove that the type A is a sub-type of B (i.e. A \u0026lt;: B). A similar but different class already exists in the Scala library. It is named \u0026lt;:\u0026lt;[A,B], which is often written A \u0026lt;:\u0026lt; B. Its documentation is here. Because this section is about implementing a variant of this class, please do not use \u0026lt;:\u0026lt;[A,B] to implement SubTypeOf.\n Question 1: Using only upper bounds (i.e. A \u0026lt;: B) or lower bounds (i.e. A \u0026gt;: B) and no variance annotation (i.e. [+A] and [-A]), create the trait SubTypeOf[A,B] (and all that is necessary) such that:\n There exists a value of type SubType[A,B] if and only if A is a sub-type of B (i.e. A \u0026lt;: B).\n Remember that, by definition, a type A is a sub-type of itself (i.e. A \u0026lt;: A).\nRemember that you should not use the class \u0026lt;:\u0026lt;[A,B].\n Solution (click to expand)\nsealed trait SubTypeOf[A,B] final case class SubTypeEvidence[A \u0026lt;: B, B]() extends SubTypeOf[A,B]  Remark for people fluent in Scala (click to expand) \nIn production, it is convenient to define the following equivalent code:\nsealed trait SubTypeOf[A,B] object SubTypeOf { final case class Evidence[A \u0026lt;: B, B]() extends SubTypeOf[A,B] implicit def evidence[A \u0026lt;: B, B]: SubTypeOf[A,B] = Evidence[A,B]() def apply[A,B](implicit ev: SubTypeOf[A,B]): ev.type = ev } \n\n  Use Case: Avoiding annoying scalac error messages about bounds not respected In this example, we want to model the diet of some animals. We start by defining the Food type and some of its subtypes:\ntrait Food class Vegetable extends Food class Fruit extends Food and then the class representing animals eating food of type A (i.e. Vegetable, Fruit, etc):\nclass AnimalEating[A \u0026lt;: Food] val elephant : AnimalEating[Vegetable] = new AnimalEating[Vegetable] Let\u0026rsquo;s define a function like there are so many in Functional Programming and apply it to elephant:\ndef dummy[F[_],A](fa: F[A]): String = \u0026#34;Ok!\u0026#34;scala\u0026gt; dummy[List, Int](List(1,2,3)) res0: String = Ok! scala\u0026gt; dummy[Option, Boolean](Some(true)) res1: String = Ok! scala\u0026gt; dummy[AnimalEating, Vegetable](elephant) ^ error: kinds of the type arguments (AnimalEating,Vegetable) do not conform to the expected kinds of the type parameters (type F,type A). AnimalEating\u0026#39;s type parameters do not match type F\u0026#39;s expected parameters: type A\u0026#39;s bounds \u0026lt;: Food are stricter than type _\u0026#39;s declared bounds \u0026gt;: Nothing \u0026lt;: Any  Question 1: Why does scalac complains?\n Solution (click to expand)\nThe function dummy requires its argument F to accept any type as argument so that we can write F[A] for any type A. On the contrary, AnimalEating requires its argument to be a sub-type of Food. Thus AnimalEating can not be used as dummy\u0026rsquo;s argument F. \n  The problem is that, when we defined class AnimalEating[A \u0026lt;: Food], we gave the restriction that A \u0026lt;: Food. So Scala, like Java, forbids us to give AnimalEating anything but a sub-type of Food (including Food itself):\nscala\u0026gt; type T1 = AnimalEating[Int] ^ error: type arguments [Int] do not conform to class AnimalEating\u0026#39;s type parameter bounds [A \u0026lt;: Food] scala\u0026gt; type T2 = AnimalEating[Food] defined type alias T2 We face a dilemma: to use the function dummy, that we really want to use because it\u0026rsquo;s a very nice function, we need to remove the constraint A \u0026lt;: Food from the definition of class AnimalEating[A \u0026lt;: Food]. But we still want to say that animals eat food, not integers, boolean or strings!\n Question 2: How can you adapt the definition of AnimalEating so that:\n We can call dummy on elephant! We want:\nscala\u0026gt; dummy[AnimalEating, Vegetable](elephant) res0: String = Ok! If A is not a sub-type of Food (including Food itself), then it is impossible to create an instance of AnimalEating[A].\n The class AnimalEating must remain an open class (i.e. not sealed)! It should be possible for anyone, anywhen, to create freely sub-classes of AnimalEating. Obviously those sub-classes must satisfy the constraints above.\n   Hint (click to expand)\nIn Scala, Nothing is a type having no value. Can you create a value of type (Nothing, Int)? Why?\n\n Solution (click to expand)\nIf, to create an instance of AnimalEating[A], we force every creation method to take an extra paramerer of type SubTypeOf[A, Food], then it will only be possible to create an instance of AnimalEating[A] when A is a sub-type of Food:\nclass AnimalEating[A](ev : SubTypeOf[A, Food]) val elephant : AnimalEating[Vegetable] = new AnimalEating[Vegetable](SubTypeEvidence[Vegetable, Food]) To create a value of type AnimalEating[A], we need to call AnimalEating\u0026rsquo;s constructor. And to call this constructor, we need to provide ev : SubTypeOf[A, Food].\nNow we can apply the dummy function on elephant:\nscala\u0026gt; dummy[AnimalEating, Vegetable](elephant) res0: String = Ok! In practice, using implicits, we let the compiler fill the parameter ev : SubTypeOf[A, Food] itself.\nNote that you can now express the type AnimalEating[Int] but you won\u0026rsquo;t be able to create a value of this type.\n\n  Use Case: Give the right data to the right chart This use case is about enforcing at compile-time that only values of the right type can be given to a function. In this example, we consider the design of a chart library. For simplicity\u0026rsquo;s sake, we will assume that our library only supports two kinds of charts: Pie charts and XY charts. This is written in Scala via the enumeration:\nsealed trait ChartType case object PieChart extends ChartType case object XYChart extends ChartType Obviously Pie and XY charts rely on different kinds of data. Once again for simplicity\u0026rsquo;s sake, we will assume that our two kinds of data are:\nclass PieData class XYData A pie chart (PieChart) plots only PieData, whereas an XY chart (XYChart) plots only XYData. Here is our drawing function draw:\ndef draw[A](chartType: ChartType)(data: A): Unit = chartType match { case PieChart =\u0026gt; val pieData = data.asInstanceOf[PieData] // Do some stuff to draw pieData  () case XYChart =\u0026gt; val xyData = data.asInstanceOf[XYData] // Do some stuff to draw xyData  () } It assumes that the user will only call draw on the right data. When chartType is PieChart, the function assumes, via data.asInstanceOf[PieData] that data is actually of type PieData. And when chartType is XYChart, it assumes that data is actually of type XYData.\nThe problem is these assumptions rely on the users and/or developers to always make sure they are doing things right. But nothing stops someone to call draw on a PieChart with XYData (or the opposite), crashing the system miserably at runtime!\nscala\u0026gt; draw(PieChart)(new XYData) java.lang.ClassCastException: XYData cannot be cast to PieData at .draw(\u0026lt;pastie\u0026gt;:11) ... 28 elided As developers we know mistakes do happen! We want a way to prevent theses annoying bugs to happen in production! We want to enforce at compile-time that only these two scenarii are possible:\n When draw is called with chartType == PieChart: the argument data can only be of type PieData When draw is called with chartType == XYChart: the argument data can only be of type XYData.  Remember that these two constraints have to be enforced at compile-time!\n Question 1: Adapt the definition of ChartType, PieChart, XYChart and draw such that:\n Any scenario other than the two above will make the compilation fail on a type error.\n ChartType must still be a sealed trait. It is now allowed to have type parameters (i.e. generics).\n PieChart and XYChar must still be two case object and they should still extends ChartType.\n ChartType, PieChart and XYChar declarations must have no body at all (i.e. there should be no brackets { ... } in their declaration).\n   Hint (click to expand)\nThe code looks like this:\nsealed trait ChartType[/*PUT SOME GENERICS HERE*/] case object PieChart extends ChartType[/*There is something to write here*/] case object XYChart extends ChartType[/*There is something to write here too*/] def draw[A](chartType: ChartType[/*Write something here*/])(data: A): Unit = chartType match { case PieChart =\u0026gt; val pieData : PieData = data () case XYChart =\u0026gt; val xyData: XYData = data () } \n Solution (click to expand)\nsealed trait ChartType[A] case object PieChart extends ChartType[PieData] case object XYChart extends ChartType[XYData] def draw[A](chartType: ChartType[A])(data: A): Unit = chartType match { case PieChart =\u0026gt; val pieData : PieData = data () case XYChart =\u0026gt; val xyData: XYData = data () } \n  You can now sleep well knowing that your production will not crash because of some bad inputs here 😉\nMore Advanced Use Cases Now that you have seen what GADTs are about and how to use them in real-life, you are ready for the big use cases below. There are three of them. Each one illustrates one different way to use the power of GADTs. The first one is about expressing effects, which is widely used in every popular IO monads or algebraic effects. Do not worry if you do not know what they are, the section will clarifies it. The second one is about enforcing properties. This point is illustrated by a real-life use-case of enabling functional programming techniques but only on certain types (in the example, types supported by our fictional database). The third one is about simplifying the creation of implicits.\nUse Case: Effects! What we call an effect is sometimes just an interface declaring some functions with no implementation. For example we can define the trait below. Note that none of its function has an implementation.\ntrait ExampleEffectSig { def echo[A](value: A): A def randomInt : Int def ignore[A](value: A): Unit } Implementations of these interfaces are given elsewhere and there can be many of them! This is useful to switch between implementations easily:\nobject ExampleEffectImpl extends ExampleEffectSig { def echo[A](value: A): A = value def randomInt : Int = scala.util.Random.nextInt() def ignore[A](value: A): Unit = () } Another equivalent way to define ExampleEffectSig is via a sealed trait with some final case class (possibly none!) and/or somecase object (possibly none too!):\nsealed trait ExampleEffect[A] final case class Echo[A](value: A) extends ExampleEffect[A] final case object RandomInt extends ExampleEffect[Int] final case class Ignore[A](value: A) extends ExampleEffect[Unit] Once again this is a declaration with no implementation! Once again implementations can be written elsewhere and there can also be many of them:\ndef runExampleEffect[A](effect: ExampleEffect[A]): A = effect match { case Echo(value) =\u0026gt; value case RandomInt =\u0026gt; scala.util.Random.nextInt() case Ignore(_) =\u0026gt; () } Let\u0026rsquo;s consider a more realistic effect and one possible implementation:\ntrait EffectSig { def currentTimeMillis: Long def printLn(msg: String): Unit def mesure[X,A](fun: X =\u0026gt; A, arg: X): A } object EffectImpl extends EffectSig { def currentTimeMillis: Long = System.currentTimeMillis() def printLn(msg: String): Unit = println(msg) def mesure[X,A](fun: X =\u0026gt; A, arg: X): A = { val t0 = System.currentTimeMillis() val r = fun(arg) val t1 = System.currentTimeMillis() println(s\u0026#34;Took ${t1 - t0}milli-seconds\u0026#34;) r } }  Question 1: Just like ExampleEffect is the equivalent of ExampleEffectSig using a sealed trait with some final case class and case object, write the equivalent of EffectSig in the same way. Call this trait Effect.\n Solution (click to expand)\nsealed trait Effect[A] final case object CurrentTimeMillis extends Effect[Long] final case class PrintLn(msg: String) extends Effect[Unit] final case class Mesure[X,A](fun: X =\u0026gt; A, arg: X) extends Effect[A] \n Question 2: Write the function def run[A](effect: Effect[A]): A that mimics the implementation of EffectImpl just like runExampleEffect mimics ExampleEffectImpl.\n Solution (click to expand)\ndef run[A](effect: Effect[A]): A = effect match { case CurrentTimeMillis =\u0026gt; System.currentTimeMillis() case PrintLn(msg) =\u0026gt; println(msg) case Mesure(fun, arg) =\u0026gt; val t0 = System.currentTimeMillis() val r = fun(arg) val t1 = System.currentTimeMillis() println(s\u0026#34;Took ${t1 - t0}milli-seconds\u0026#34;) r } \n  The type Effect[A] declare interesting effects (CurrentTimeMillis, PrintLn and Mesure) but to be really useful, we need to be able to chain effects! To do so, we want to have these two functions:\n def pure[A](value: A): Effect[A] def flatMap[X,A](fx: Effect[X], f: X =\u0026gt; Effect[A]): Effect[A]  Once again we do not care yet about the implementation. Presently all we want is declaring these two operations just like we declared CurrentTimeMillis, PrintLn and Mesure.\n Question 3: Add two final case classes, Pure and FlatMap, to Effect[A] declaring these operations.\n Solution (click to expand)\nsealed trait Effect[A] final case object CurrentTimeMillis extends Effect[Long] final case class PrintLn(msg: String) extends Effect[Unit] final case class Mesure[X,A](fun: X =\u0026gt; A, arg: X) extends Effect[A] final case class Pure[A](value: A) extends Effect[A] final case class FlatMap[X,A](fx: Effect[X], f: X =\u0026gt; Effect[A]) extends Effect[A] \n Question 4: Adapt the function run to handle these two new cases.\n Solution (click to expand)\ndef run[A](effect: Effect[A]): A = effect match { case CurrentTimeMillis =\u0026gt; System.currentTimeMillis() case PrintLn(msg) =\u0026gt; println(msg) case Mesure(fun, arg) =\u0026gt; val t0 = System.currentTimeMillis() val r = fun(arg) val t1 = System.currentTimeMillis() println(s\u0026#34;Took ${t1 - t0}milli-seconds\u0026#34;) r case Pure(a) =\u0026gt; a case FlatMap(fx, f) =\u0026gt; val x = run(fx) val fa : Effect[A] = f(x) run(fa) } \n Question 5: Add the two following methods to trait Effect[A] to get:\nsealed trait Effect[A] { final def flatMap[B](f: A =\u0026gt; Effect[B]): Effect[B] = FlatMap(this, f) final def map[B](f: A =\u0026gt; B): Effect[B] = flatMap[B]((a:A) =\u0026gt; Pure(f(a))) } And run the follwing code to see if it works:\nval effect1: Effect[Unit] = for { t0 \u0026lt;- CurrentTimeMillis _ \u0026lt;- PrintLn(s\u0026#34;The current time is $t0\u0026#34;) } yield () run(effect1)  Solution (click to expand)\nsealed trait Effect[A] { final def flatMap[B](f: A =\u0026gt; Effect[B]): Effect[B] = FlatMap(this, f) final def map[B](f: A =\u0026gt; B): Effect[B] = flatMap[B]((a:A) =\u0026gt; Pure(f(a))) } final case object CurrentTimeMillis extends Effect[Long] final case class PrintLn(msg: String) extends Effect[Unit] final case class Mesure[X,A](fun: X =\u0026gt; A, arg: X) extends Effect[A] final case class Pure[A](value: A) extends Effect[A] final case class FlatMap[X,A](fx: Effect[X], f: X =\u0026gt; Effect[A]) extends Effect[A] def run[A](effect: Effect[A]): A = effect match { case CurrentTimeMillis =\u0026gt; System.currentTimeMillis() case PrintLn(msg) =\u0026gt; println(msg) case Mesure(fun, arg) =\u0026gt; val t0 = System.currentTimeMillis() val r = fun(arg) val t1 = System.currentTimeMillis() println(s\u0026#34;Took ${t1 - t0}milli-seconds\u0026#34;) r case Pure(a) =\u0026gt; a case FlatMap(fx, f) =\u0026gt; val x = run(fx) val fa : Effect[A] = f(x) run(fa) } val effect1: Effect[Unit] = for { t0 \u0026lt;- CurrentTimeMillis _ \u0026lt;- PrintLn(s\u0026#34;The current time is $t0\u0026#34;) } yield () When we run run(effect1):\nscala\u0026gt; run(effect1) The current time is 1569773175010 \n  Congratulations! You just wrote your first IO monad! There is a lot of scientific words to name the sealed trait Effect[A]: you can call it an algebraic effect, a free monad, an IO, etc. But in the end, it is just a plain simple sealed trait where we just declared some final case class and case object to represent the functions we wanted to have without providing their implementation (CurrentTimeMillis, PrintLn, Mesure, Pure and FlatMap). You can call them virtual methods if you like. What really matters is that we isolated the declaration of the functions from their implementation. Remember that a trait is just a interface after all.\nUse Case: Ensuring types are supported by the Database Databases are great. We can store tables, documents, key/values pairs, graphs, etc. But for any database, there is unfortunately only a limited set of supported types. Take a database you like, I am sure I can find some types it does not support.\nIn this section we consider the use case of data structures and code that do not work for (values of) any type but only for some! This problem is not limited to databases but concerns any API that only supports a limited set of types (the vast majority of APIs). How to enforce this constraint? How to adapt the patterns we like to work under this constraint? This is all this section is about.\nWe consider a fictional database that only supports the following types:\n String Double (A,B) where A and B are also types supported by the database.  It means that the values stores by the database (in tables, key/value pairs, etc) must follow the rules above. It can store \u0026quot;Hello World\u0026quot; because it is a String which is a supported type by rule 1. Likewise, it can store 5.2 because it is a Double, but it can not store 5 because it is an Int. It can store (\u0026quot;Hello World\u0026quot;, 5.2) thanks to rule 3 and also ((\u0026quot;Hello World\u0026quot;, 5.2) , 8.9) once again by rule 3.\n Question 1: Define the type DBType[A] such that:\n There exists a value of type DBType[A] if and only if A is a type supported by the database.\n  Solution (click to expand)\nThe simple version is:\nsealed trait DBType[A] final case object DBString extends DBType[String] final case object DBDouble extends DBType[Double] final case class DBPair[A,B](first: DBType[A], second: DBType[B]) extends DBType[(A,B)]  Remark for people fluent in Scala (click to expand) \nUsing all the nice features of Scala, the production-ready version of the code above is:\nsealed trait DBType[A] object DBType { final case object DBString extends DBType[String] final case object DBDouble extends DBType[Double] final case class DBPair[A,B](first: DBType[A], second: DBType[B]) extends DBType[(A,B)] implicit val dbString : DBType[String] = DBString implicit val dbDouble : DBType[Double] = DBDouble implicit def dbPair[A,B](implicit first: DBType[A], second: DBType[B]): DBType[(A,B)] = DBPair(first, second) def apply[A](implicit ev: DBType[A]): ev.type = ev } \n\n  Using DBType, we can pair a value of type A with a value of type DBType[A] which provides an evidence that the type A is supported by the database:\nfinal case class DBValue[A](value: A)(implicit val dbType: DBType[A]) Note that the parameter dbType does not need to be implicit! All that matters is that to create a value of type DBValue[A], we need to provide a value of type DBType[A] which forces A to be a supported type.\nA functor is, approximately, a type constructor F[_] like List, Option, DBValue, \u0026hellip; for which you can write an instance of the trait\ntrait Functor[F[_]] { def map[A,B](fa: F[A])(f: A =\u0026gt; B): F[B] } where map(fa)(f) applies the function f to any value of type A contained in fa. For example:\nimplicit object OptionFunctor extends Functor[Option] { def map[A,B](fa: Option[A])(f: A =\u0026gt; B): Option[B] = fa match { case Some(a) =\u0026gt; Some(f(a)) case None =\u0026gt; None } }  Question 2: Write an instance of Functor[DBValue].\n Solution (click to expand)\nWe actually can not! If we try to compile the following code:\nobject DBValueFunctor extends Functor[DBValue] { def map[A,B](fa: DBValue[A])(f: A =\u0026gt; B): DBValue[B] = DBValue[B](f(fa.value)) } Scala complains: could not find implicit value for parameter dbType: DBType[B]. Indeed, booleans are not a supported type by the database: they are neither strings, nor doubles, not pairs. But if we could write a Functor instance for DBValue (i.e. if we could write a map function for DBValue), then we could write:\nval dbValueString : DBValue[String] = DBValue(\u0026#34;A\u0026#34;)(DBString) val dbValueBoolean : DBValue[Boolean] = dbValueString.map(_ =\u0026gt; true) val dbTypeBoolean : DBType[Boolean] = dbValueBoolean.dbType We would get a value (dbTypeBoolean) of type DBType[Boolean] which would mean that the type Boolean is supported by the database. But it is not! And by definition:\n There exists a value of type DBType[A] if and only if A is a type supported by the database.\n So it is impossible to have a value of type DBType[Boolean] and thus it is impossible to write a function map for DBValue. So there is no way to write a Functor instance for DBValue.\n\n  A Generalized Functor is very much like a regular Functor but the map function do not apply to any type A and B but is restricted to the only types A and B satisfying some condition:\ntrait GenFunctor[P[_],F[_]] { def map[A,B](fa: F[A])(f: A =\u0026gt; B)(implicit evA: P[A], evB: P[B]): F[B] } For example Set (more precisely TreeSet) is not a functor! Indeed there is no way to write a function map that works for any type B (because B need to have an ordering). But if we restrict map to only types B having an ordering, then we can write it.\nimport scala.collection.immutable._ object TreeSetFunctor extends GenFunctor[Ordering, TreeSet] { def map[A,B](fa: TreeSet[A])(f: A =\u0026gt; B)(implicit evA: Ordering[A], evB: Ordering[B]): TreeSet[B] = TreeSet.empty[B](evB) ++ fa.toSeq.map(f) }  Question 3: Write an instance of GenFunctor[DBType, DBValue]r\n Solution (click to expand)\nobject DBValueGenFunctor extends GenFunctor[DBType, DBValue] { def map[A,B](fa: DBValue[A])(f: A =\u0026gt; B)(implicit evA: DBType[A], evB: DBType[B]): DBValue[B] = DBValue[B](f(fa.value))(evB) } \n  What we have done to Functor can be done for many data-structures and patterns. We can often limit the types on which a data-structure or a type-class can operate by adding an extra parameter like ev : DBType[A] to constructors and methods.\nUse Case: Simplifying Implicits This use case is one the most interesting but unfortunately, not one of the easiest. It illustrates how it is possible to use GADTs to simplify the creation of implicit values. In this example we consider lists of values whose items can be of different types. Theses lists are called heterogeneous lists. They are usually defined in Scala almost like normal lists:\nfinal case class HNil() // The empty list final case class HCons[Head,Tail](head: Head, tail: Tail) // The `head :: tail` operation  val empty : HNil = HNil() val oneTrueToto : HCons[Int, HCons[Boolean, HCons[String, HNil]]] = HCons(1, HCons(true, HCons(\u0026#34;toto\u0026#34;, HNil()))) val falseTrueFive: HCons[Boolean, HCons[Boolean, HCons[Int, HNil]]] = HCons(false, HCons(true, HCons(5, HNil()))) As you can see, there is nothing special about it. We want to define orderings on heterogeneous lists. An ordering is a way to compare two values (of the same type!): they can be equal or one may be lesser than the other. In Scala we can define the trait Order:\ntrait Order[A] { // true if and only if a1 \u0026lt; a2  def lesserThan(a1: A, a2: A): Boolean // a1 and a2 are equal if and only if none of them is lesser than the other.  final def areEqual(a1: A, a2: A): Boolean = !lesserThan(a1, a2) \u0026amp;\u0026amp; !lesserThan(a2, a1) // a1 \u0026gt; a2 if and only if a2 \u0026lt; a1  final def greaterThan(a1: A, a2: A): Boolean = lesserThan(a2, a1) final def lesserThanOrEqual(a1: A, a2: A): Boolean = !lesserThan(a2, a1) final def greaterThanOrEqual(a1: A, a2: A): Boolean = !lesserThan(a1, a2) } object Order { def apply[A](implicit ev: Order[A]): ev.type = ev def make[A](lg_ : (A,A) =\u0026gt; Boolean): Order[A] = new Order[A] { def lesserThan(a1: A, a2: A): Boolean = lg_(a1,a2) } } implicit val orderInt = Order.make[Int](_ \u0026lt; _) implicit val orderString = Order.make[String](_ \u0026lt; _) Remember that we will only compare lists of the same type:\n Lists of type HNil will only be compared to lists of type HNil. Lists of type HCons[H,T] will only be compared to lists of type HCons[H,T].  Comparing lists of type HNil is trivial because there is only one value of type HNil (the empty list HNil()) but there are many ways of comparing lists of type HCons[H,T]. Here are two possible orderings (there exists many more!):\n The lexicographic ordering (i.e. dictionary order: from left to right)\n HCons(h1,t1) \u0026lt; HCons(h2,t2) if and only if h1 \u0026lt; h2 or (h1 == h2 and t1 \u0026lt; t2 by lexicographic ordering).\n sealed trait Lex[A] { val order : Order[A] } object Lex { def apply[A](implicit ev: Lex[A]): ev.type = ev implicit val lexHNil: Lex[HNil] = new Lex[HNil] { val order = Order.make[HNil]((_,_) =\u0026gt; false) } implicit def lexHCons[Head,Tail](implicit orderHead: Order[Head], lexTail: Lex[Tail] ): Lex[HCons[Head, Tail]] = new Lex[HCons[Head, Tail]] { val orderTail: Order[Tail] = lexTail.order val order = Order.make[HCons[Head, Tail]] { case (HCons(h1,t1), HCons(h2,t2)) =\u0026gt; orderHead.lesserThan(h1,h2) || (orderHead.areEqual(h1,h2) \u0026amp;\u0026amp; orderTail.lesserThan(t1,t2)) } } } The reverse-lexicographic ordering which is the reverse version of the lexicographic ordering (i.e. from right to left)\n HCons(h1,t1) \u0026lt; HCons(h2,t2) if and only if t1 \u0026lt; t2 by reverse-lexicographic ordering or (t1 == t2 and h1 \u0026lt; h2).\n sealed trait RevLex[A] { val order : Order[A] } object RevLex { def apply[A](implicit ev: RevLex[A]): ev.type = ev implicit val revLexHNil: RevLex[HNil] = new RevLex[HNil] { val order = Order.make[HNil]((_,_) =\u0026gt; false) } implicit def revLexHCons[Head,Tail](implicit orderHead: Order[Head], revLexTail: RevLex[Tail] ): RevLex[HCons[Head, Tail]] = new RevLex[HCons[Head, Tail]] { val orderTail: Order[Tail] = revLexTail.order val order = Order.make[HCons[Head, Tail]] { case (HCons(h1,t1), HCons(h2,t2)) =\u0026gt; orderTail.lesserThan(t1,t2) || (orderTail.areEqual(t1,t2) \u0026amp;\u0026amp; orderHead.lesserThan(h1,h2)) } } }  As said above, it is possible to define more orderings:\n Question 1: The Alternate ordering is defined by:\n HCons(h1,t1) \u0026lt; HCons(h2,t2) if and only if h1 \u0026lt; h2 or (h1 == h2 and t1 \u0026gt; t2 by alternate ordering).\n Just like what was done for Lex and RevLex, implement the Alternate ordering.\n Solution (click to expand)\nsealed trait Alternate[A] { val order : Order[A] } object Alternate { def apply[A](implicit ev: Alternate[A]): ev.type = ev implicit val alternateHNil: Alternate[HNil] = new Alternate[HNil] { val order = Order.make[HNil]((_,_) =\u0026gt; false) } implicit def alternateHCons[Head,Tail](implicit orderHead: Order[Head], alternateTail: Alternate[Tail] ): Alternate[HCons[Head, Tail]] = new Alternate[HCons[Head, Tail]] { val orderTail: Order[Tail] = alternateTail.order val order = Order.make[HCons[Head, Tail]] { case (HCons(h1,t1), HCons(h2,t2)) =\u0026gt; orderHead.lesserThan(h1,h2) || (orderHead.areEqual(h1,h2) \u0026amp;\u0026amp; orderTail.greaterThan(t1,t2)) } } } \n  There are lots of ways to define a valid ordering on heterogeneous lists! Defining type-classes like Lex, RevLex and Alternate for every ordering we want to implement is clunky and messy. We can do much better than that \u0026hellip; with a GADT 😉\nsealed trait HListOrder[A] object HListOrder { final case object HNilOrder extends HListOrder[HNil] final case class HConsOrder[Head,Tail]( orderHead: Order[Head], hlistOrderTail: HListOrder[Tail] ) extends HListOrder[HCons[Head,Tail]] // Implicit definitions  implicit val hnilOrder : HListOrder[HNil] = HNilOrder implicit def hconsOrder[Head,Tail](implicit orderHead: Order[Head], hlistOrderTail: HListOrder[Tail] ): HListOrder[HCons[Head,Tail]] = HConsOrder(orderHead, hlistOrderTail) def apply[A](implicit ev: HListOrder[A]): ev.type = ev } Note that these implicit definitions are boilerplate. Their only purpose is passing arguments to their corresponding constructor (i.e. final case class or case object): hnilOrder to HNilOrder (O arguments) and hconsOrder to HConsOrder (2 arguments).\n Question 2: Write the function def lex[A](implicit v : HListOrder[A]): Order[A] that compute the lexicographic ordering from a value of type HListOrder[A].\n Solution (click to expand)\ndef lex[A](implicit v : HListOrder[A]): Order[A] = v match { case HListOrder.HNilOrder =\u0026gt; Order.make[HNil]((_,_) =\u0026gt; false) case hc : HListOrder.HConsOrder[head,tail] =\u0026gt; val orderHead: Order[head] = hc.orderHead val orderTail: Order[tail] = lex(hc.hlistOrderTail) Order.make[HCons[head, tail]] { case (HCons(h1,t1), HCons(h2,t2)) =\u0026gt; orderHead.lesserThan(h1,h2) || (orderHead.areEqual(h1,h2) \u0026amp;\u0026amp; orderTail.lesserThan(t1,t2)) } } \n Question 3: Write the function def revLex[A](implicit v : HListOrder[A]): Order[A] that compute the reverse-lexicographic ordering from a value of type HListOrder[A].\n Solution (click to expand)\ndef revLex[A](implicit v : HListOrder[A]): Order[A] = v match { case HListOrder.HNilOrder =\u0026gt; Order.make[HNil]((_,_) =\u0026gt; false) case hc : HListOrder.HConsOrder[head,tail] =\u0026gt; val orderHead: Order[head] = hc.orderHead val orderTail: Order[tail] = revLex(hc.hlistOrderTail) Order.make[HCons[head, tail]] { case (HCons(h1,t1), HCons(h2,t2)) =\u0026gt; orderTail.lesserThan(t1,t2) || (orderTail.areEqual(t1,t2) \u0026amp;\u0026amp; orderHead.lesserThan(h1,h2)) } } \n  This approach has several benefits. Whereas the initial approach had to find one implicit by ordering, the GADT approach only have to find one! Considering implicit resolution is a costly operation, reducing it means faster compilation times. Reading the code of functions lex and revLex is easier than understanding how implicit resolution works for traits Lex and RevLex. Furthermore, they are just functions, you can use all you can code in building the instance Order[A].\nConclusion Not so trivial, isn\u0026rsquo;t it? 😉 Actually a fair amount of the complexity you may have experienced comes to the fact that reasoning about values and types is almost never taught in programming courses. What you consider simple now (web apis, streaming, databases, etc) would probably terrifies your younger self when you were introduced for the first time to \u0026ldquo;Hello World!\u0026rdquo;. You probably did not learn all you know in programming in three hours so do not expect reasoning about programs to be magically easier.\nThis workshop aimed at inspiring you, opening your mind to this all new set of possibilities. If you found the use case interesting, then take the time to understand the techniques.\nHave fun and take care ❤️\n"
},
{
	"uri": "https://chrilves.github.io/posts/auto_batch/",
	"title": "10 Tips for Fast Stack-safe Functional code: the Automatic-Batching experience",
	"tags": [],
	"description": "ScalaIO 2019 Talk - GATD - GADTs - Generalized Algebraic Data Types - ADT - Algebraic Data Types - Functional Programming - Interface - Free Monad",
	"content": " Tip 1: Tip 2: Tip 3: Tip 4: Tip 5: Tip 6: Tip 7: Tip 8: Tip 9: Tip 10: "
},
{
	"uri": "https://chrilves.github.io/posts/prime/",
	"title": "Proving Primality with GADTs",
	"tags": [],
	"description": "",
	"content": "  The Scala source code is at github.com/chrilves/gadt.scala. The Haxe source code is at github.com/chrilves/Gadts.hx. The Web Application is here.  Today we will explore the Curry–Howard correspondence. Our mission is writing, in Scala\u0026rsquo;s type system, the property on natural number of being prime. Wikipedia defines it by:\n A natural number (1, 2, 3, 4, 5, 6, etc.) is called a prime number (or a prime) if it is greater than 1 and cannot be written as a product of two natural numbers that are both smaller than it.\n An equivalent way to put it is:\n A natural number is prime if it is greater than 1 and cannot be divided by any natural number greater than 1 but smaller than it.\n These definitions are equivalent as, by definition, any natural number n is divisible by k if and only if it can be written n = k × p for some natural number p.\nWriting a program whose execution checks whether a number is prime is easy. But we are not interested in executing programs, only compiling them! We want the compiler to verify that a number is indeed prime. At that point, you may wonder how it is even possible to use the compiler to \u0026ldquo;prove\u0026rdquo; something about numbers. That\u0026rsquo;s exactly the point of the Curry–Howard correspondence\nThe Challenge You can write any positive integer in the input bow below:  \n Please write 3 in the input box above. A button shall appear letting you download Prime3.scala. Run it via\nscala Prime3.scala The file should compile and run flawlessly outputting ForAllCons(NotDivRec(NotDivBasic(ListIsPositive(),LTTrivial()),AddPlus1(AddZero())),ForAllNil()). Look into Prime3.scala, you should see a value prime3: Prime[_3] defined. The main method simply outputs this value.\n Now, write 4 in the input box. Download and run Prime4.scala via\nscala Prime4.scala The file should compile but execution should failed with the exception scala.NotImplementedError: an implementation is missing. Look into Prime4.scala, the value prime4: Prime[_4] is defined by ???.\n Read Prime4.scala carefully, starting from the beginning, and try to write a valid definition for val prime4: Prime[_4]. Remember to follow very scrupulously the rules stated in the first comment of Prime4.scala.\n DO NOT ALTER, IN ANY WAY, THE DEFINITION OF ANY TYPE IN THE FILE DO NOT ADD SUB CLASSES/OBJECTS TO TYPES IN THE FILE DO NOT USE NULL IN ANY WAY ONLY USE THE GIVEN CASE OBJECTS AND CASE CLASSES IN THE FILE THE GOAL IS TO PRODUCE A val prime4: Prime[_4], NOT A def prime4: Prime[_4], NOT A lazy val prime4: Prime[_4]! YOUR CODE SHOULD TYPE-CHECK AND RUN PRINTING THE VALUE prime4   Try to find valid values of type Prime[_N] when is not a prime number.\nWhat the hell is going on ??? To encode properties over natural number, we need to start by encoding natural numbers. To do so, we associate to any natural number a type:\n to 0 we associate the type String to 1 we associate the type List[String] to 2 we associate the type List[List[String]] to 3 we associate the type List[List[List[String]]] and so on:\ntype _0 = String type _1 = List[_0] // List[String] type _2 = List[_1] // List[List[String]] type _3 = List[_2] // List[List[List[String]]] type _4 = List[_3] // List[List[List[List[String]]]] type _5 = List[_4] // List[List[List[List[List[String]]]]]  The next step is to define the type Prime[N] such that:\n There exists a valid of type Prime[N] if and only if N is (the type associated to) a prime number.\n Proving that a Natural Number is Prime Let n be a natural number and N its associated type (for example n=3 and N = _3). Then:\n n is prime if and only if for all natural number m such that 2 ≤ m \u0026lt; n, then m does not divide n.\n The type ForAll[X, N] encodes this exact property. There exists a value of type ForAll[X,N] if and only if both:\n X ≤ N For all M such that X ≤ M \u0026lt; N, M do not divide N  Actually the type Prime[N] is an alias for ForAll[_2, N]. We need to encode two more properties:\n For I and J two natural numbers, the property that I is less than or equal to J (I ≤ J). It is encoded as the type LessThan[I, J]. For I and J two natural numbers, the property that I does not divide J. It is encoded as the type NotDiv[I, J].  Read the file PrimeN.scala carefully, each step is described and explained in much details.\nConclusion Why asking you to build a value that not exists? Because the main point is not knowing whether there exists a value of type Prime[_4] but understanding why such a value (following all the rules!) cannot exists!\nIt is widely known and accepted in programming culture that every type has values. After all, types exists only to qualify values, right? And instantiating a type T is as simple as calling new! There is one huge problem with this claim: it is completely wrong!. The idea that a types can have no value, often called empty type or uninhabited type, is the cornerstone of a lot of techniques including logic, maths, programming with rich types, formal systems like Coq, etc.\nThis example is indeed both complicated and complex. It is neither a regular usage of GADTs nor something meant for production! It\u0026rsquo;s perfectly ok being confused about it or not understanding what is going on. As I said, it is an complicated and complex example!! But when you manage to understand it, consider you master the subject.\n"
},
{
	"uri": "https://chrilves.github.io/posts/recursion_schemes_intro/",
	"title": "Recursion Schemes: the high-school introduction",
	"tags": [],
	"description": "Presentation of recursion schemes from simple examples without the complex vocabulary in the way.",
	"content": " I gave a talk on Thursday the 28th of march 2019 at the 96th Paris Scala User Group session on about this. The slides are here.\nRecursion schemes are said to be a tough subject. Articles and presentations often flood the audience with lots of names such as Algebra, CoAlgebra, catamorphisms, anamorhpisms, hylomorphism, etc. Is knowing all these concepts required to understand recursion schemes? I have good news for you: it isn\u0026rsquo;t! All you need, to see what recursion schemes are and why there are useful, can be presented with just a single basic function, often taught as an introduction to programming: factorial. I\u0026rsquo;m glad to welcome you to to the high-school introduction to recursion scheme 😉.\nLearning Recursion Schemes Before diving into the subject, let\u0026rsquo;s take a moment to contextualize. Recursion-schemes, like most of advanced functional programming techniques, is almost never taught in programming courses or books. It means there is a strong chance the subject, and the concepts it relies upon, is totally new to you. I want you to remember you haven\u0026rsquo;t learnt programming in one day, and you probably did not start learning programming by implementing a distributed steaming application over a spark cluster from scratch. Like most of us, you probably started by coding some sort of Hello, World!. Let\u0026rsquo;s face it, real business application are a lot more complex than this. Do you imagine what a first introduction to programming would be, if instead of asking people to write a simple Hello, World!, we would ask them to write a real state-of-the-art large-scale business application that meets all the requirements we expect in production nowadays? Learning takes time! Start with toy examples that are indeed far from real-word cases but enables you to grow your understanding, one step at a time.\nThe examples below are indeed toy examples. When i develop with recursion scheme, like any specialist in any field, i use specialist techniques and vocabulary (you know, the usual vocabulary from category and type theory). But if you\u0026rsquo;re reading this, it probably means you\u0026rsquo;re not a recursion-scheme specialist yet. Using complex words flatters our ego, which is very enjoyable, but developing a deep understanding of these notions is far better! So let\u0026rsquo;s put our ego aside for a moment and accept to start with the basics.\nIn Recursion Schemes, there is Recursion First of all, let me present you the famous factorial function. It is defined on non-negative numbers n as the product of all numbers between 1 and n included:\n$$fact(n) = 1 \\times 2 \\times 3 \\times \\cdots \\times n$$\nTo ease the presentation we will take Int as the type of non-negative integers. Obviously in production code negative values should be handled appropriately but for simplicity\u0026rsquo;s sake, we will define fact in Scala and in Haskell as\ndef fact(n: Int): Int = if (n == 0) 1 else { val r = fact(n-1) n * r }fact :: Int -\u0026gt; Int fact 0 = 1 fact n = let r = fact (n - 1) in n * r Factorial is written here as a recursive function. As you probably know, it can also be written as an iterative one (using a for or while loop) but the subject of this article is Recursion Schemes, not Iterative Schemes, so let\u0026rsquo;s use recursion. This function computes fact(2) as follows:\n fact(2) = 2 * fact(1) so it needs to compute fact(1) fact(1) = 1 * fact(0) so it needs to compute fact(0) fact(0) = 1 now that the result of fact(0) is known, it can replace the call of fact(0) by its result which gives fact(1) = 1 * fact(0) = 1 * 1 = 1 now that the result of fact(1) is known, it can replace the call of fact(1) by its result which gives fact(2) = 2 * fact(1) = 2 * 1 = 2.  Look at how fact(n) is calling it-self: if n = 0 then it doesn\u0026rsquo;t call itself, otherwise it calls itself on n - 1. Let\u0026rsquo;s split this definition in two parts: the first one contains all the code relevant to how fact is calling itself but only it, the second one is made of the rest. There is no clear rule for what is relevant and what is not. Different splits may work, they will just give rise to different schemes, which is not a problem at all. You just need to find one that fits your needs.\nFor fact, the key element to note is it is not calling itself when n = 0 but otherwise calls itself with n - 1. The constant returned in the n = 0 case and the operation done in the other one have no impact on how fact recurses. So i choose to split it by taking all code not relevant to recursion out of its body:\n/* Part irrelevant to recursion: * The real definitions of these variables * have no impact on how fact is calling itself */ val baseCase: Int = 1 def recCase(n: Int, r: Int): Int = n * r /* Recursion-only part: * The only implementation details it contains * are about how fact it calling itself */ def fact(n: Int): Int = if (n == 0) baseCase else { val r = fact(n-1) recCase(n, r) }{- Part irrelevant to recursion: The real definitions of these variables Have no impact on how fact is calling itself -} baseCase :: Int baseCase = 1 recCase :: Int -\u0026gt; Int -\u0026gt; Int recCase n r = n * r {- Recursion-only part: The only implementation details it contains are about how fact it calling itself -} fact :: Int -\u0026gt; Int fact 0 = baseCase fact n = let r = fact (n-1) in recCase n r Let me present you another function, also defined on non-negative numbers n, but that computes this time the sum of all numbers between 1 and n included:\n$$sum(n) = 1 + 2 + 3 + \\cdots + n$$\ndef sum(n: Int): Int = if (n == 0) 0 else { val r = sum(n-1) n + r }sum :: Int -\u0026gt; Int sum 0 = 0 sum n = let r = sum (n - 1) in n + r We can apply the same technique to sum: splitting the definition into two parts, one containing all but only recursion-relevant code, and the other the rest. It gives:\n/* Part irrelevant to recursion: * The real definitions of these variables * have no impact on how sum is recurs */ val baseCase: Int = 0 def recCase(n: Int, r: Int): Int = n + r /* Recursion-only part: * The only implementation details it contains * are about how fact it recurs */ def sum(n: Int): Int = if (n == 0) baseCase else { val r = sum(n-1) recCase(n, r) }{- Part irrelevant to recursion: The real definitions of these variables Have no impact on how fact is calling itself -} baseCase :: Int baseCase = 0 recCase :: Int -\u0026gt; Int -\u0026gt; Int recCase n r = n + r {- Recursion-only part: The only implementation details it contains are about how fact it calling itself -} sum :: Int -\u0026gt; Int sum 0 = baseCase sum n = let r = sum (n-1) in recCase n r Do you see how similar the recursion-relevant parts of sum and fact are? They are actually identical! It means fact and sum have the same recursion structure. The recursion-irrelevant part differ: the constant baseCase which is 1 in fact but 0 in sum and operation recCase which is n * r in fact but n + r in sum. Note that if we replace, in each case, occurrences of baseRec and recCase by their definition, we get back the original functions. Look at the common recursive-relevant part:\ndef commonRecursiveRelevantPart(n: Int): Int = if (n == 0) baseCase else { val r = commonRecursiveRelevantPart(n-1) recCase(n, r) }commonRecursiveRelevantPart :: Int -\u0026gt; Int commonRecursiveRelevantPart 0 = baseCase commonRecursiveRelevantPart n = let r = commonRecursiveRelevantPart (n-1) in recCase n r Obviously, for this code to be correct, baseCase and recCase have to be defined. Let\u0026rsquo;s fix this by taking them as arguments:\ndef scheme(baseCase: Int, recCase: (Int, Int) =\u0026gt; Int): Int =\u0026gt; Int = { def commonRecursiveRelevantPart(n: Int): Int = if (n == 0) baseCase else { val r = commonRecursiveRelevantPart(n-1) recCase(n, r) } commonRecursiveRelevantPart }scheme :: Int -\u0026gt; (Int -\u0026gt; Int -\u0026gt; Int) -\u0026gt; Int -\u0026gt; Int scheme baseCase recCase = commonRecursiveRelevantPart where commonRecursiveRelevantPart :: Int -\u0026gt; Int commonRecursiveRelevantPart 0 = baseCase commonRecursiveRelevantPart n = let r = commonRecursiveRelevantPart (n-1) in recCase n r It is then trivial to define both fact and sum by feeding scheme with corresponding definitions for baseCase and recCase:\ndef fact: Int =\u0026gt; Int = scheme(1, (n: Int, r:Int) =\u0026gt; n * r) def sum : Int =\u0026gt; Int = scheme(0, (n: Int, r:Int) =\u0026gt; n + r)fact :: Int -\u0026gt; Int fact = scheme 1 (*) sum :: Int -\u0026gt; Int sum = scheme 0 (+) We can now give a first answer to how recursion schemes can be useful. They enable to to write less code which is both easier and safer. But there is more! Recursive calls, like any function calls, consume the stack. If there are too many recursive calls (i.e. when n is to big), there is a risk of stack overflow. Some languages like Scala are smart enough to avoid, in some cases, this problem by transforming tail-recursive functions into iterative loops. Unfortunately not all recursive functions are tail-recursive. Writing recursive functions as iterative loops is not the solution either since it is intricate and error-prone. Fortunately it is enough to only write the recursion scheme once:\ndef scheme(baseCase: Int, recCase: (Int, Int) =\u0026gt; Int)(n: Int): Int = { var res = baseCase var i: Int = 1 while (i \u0026lt;= n) { res = recCase(i, res) i += 1 } res }scheme :: Int -\u0026gt; (Int -\u0026gt; Int -\u0026gt; Int) -\u0026gt; Int -\u0026gt; Int scheme baseCase recCase n = aux baseCase 1 where aux res i = if i \u0026lt;= n then aux (recCase i res) (i + 1) else res Note that the scheme is usually simpler to write as it only focuses on recursion, not business logic. Furthermore one scheme may fit many functions thus reducing the complexity and bugs in writing business functions. Remember that fact and sum are purposely trivial. They are just toy example to introduce the subject. In practice you will use much more complex recursive functions. Once you\u0026rsquo;ve understood this example, you\u0026rsquo;ll be able to scale this technique to any recursive one, however complex it is.\nScaling up! To be sure we have a good understanding of the techniqe, let\u0026rsquo;s apply it to the fibonacci function we all love. It is defined on non-negative integers by\n$$fib(0) = 1$$ $$fib(1) = 1$$ $$fib(n+2) = fib(n+1) + fib(n)$$\ndef fib(n: Int): Int = n match { case 0 =\u0026gt; 1 case 1 =\u0026gt; 1 case n =\u0026gt; val r1 = fib(n-1) val r2 = fib(n-2) r1 + r2 }fib :: Int -\u0026gt; Int fib 0 = 1 fib 1 = 1 fib n = r1 + r2 where r1 = fib (n - 1) r2 = fib (n - 2) The function fib does not call itself when n is 0 or 1 but calls itself twice, on n-1 and n-2 otherwise. So we can, like fact and sum, split fib into two pieces: one containing only recursion-relevant code and the other one the rest. Once again the split is done by taking recursion-irrelevant code out of the function\u0026rsquo;s body. Remember they are many ways to split it up. This one is just one of many sensible way of doing so:\n/* Part irrelevant to recursion: * The real definitions of these variables * have no impact on how fact is calling itself */ val baseCase0: Int = 1 val baseCase1: Int = 1 def recCase(r1: Int, r2: Int): Int = r1 + r2 /* Recursion-only part: * The only implementation details it contains * are about how fib it calling itself */ def fib(n: Int): Int = n match { case 0 =\u0026gt; baseCase0 case 1 =\u0026gt; baseCase1 case n =\u0026gt; val r1 = fib(n-1) val r2 = fib(n-2) recCase(r1, r2) }{- Part irrelevant to recursion: The real definitions of these variables Have no impact on how fact is calling itself -} baseCase0 :: Int baseCase0 = 1 baseCase1 :: Int baseCase1 = 1 recCase :: Int -\u0026gt; Int -\u0026gt; Int recCase n r = n + r {- Recursion-only part: The only implementation details it contains are about how fact it calling itself -} fib :: Int -\u0026gt; Int fib 0 = baseCase0 fib 1 = baseCase1 fib n = recCase r1 r2 where r1 = fib (n - 1) r2 = fib (n - 2) Which leads to the recursion scheme:\ndef scheme(baseCase0: Int, baseCase1: Int, recCase: (Int, Int) =\u0026gt; Int)(n: Int): Int = n match { case 0 =\u0026gt; baseCase0 case 1 =\u0026gt; baseCase1 case n =\u0026gt; val r1 = fib(n-1) val r2 = fib(n-2) recCase(r1, r2) }scheme :: Int -\u0026gt; Int -\u0026gt; (Int -\u0026gt; Int -\u0026gt; Int) -\u0026gt; Int -\u0026gt; Int scheme baseCase0 baseCase1 recCase = aux where aux 0 = baseCase0 aux 1 = baseCase1 aux n = recCase r1 r2 where r1 = aux (n - 1) r2 = aux (n - 2) It is then trivial to define fib by giving appropriate definition to scheme arguments: baseCase0, baseCase1 and recCase.\ndef fib: Int =\u0026gt; Int = scheme(1, 1, (r1: Int, r2: Int) =\u0026gt; r1 + r2)fib :: Int -\u0026gt; Int fib = scheme 1 1 (+) Once again this implementation is not optimal as each call of fib can make to 2 recursive calls which leads to an exponential time complexity. While computing fib(5) is fast, computing fib(1000) may take much longer. As you already probably guessed, writing the recursion scheme as an iterative loop, which sadly makes it more intricate, solves the problem:\ndef scheme(baseCase0: Int, baseCase1: Int, recCase: (Int, Int) =\u0026gt; Int)(n: Int): Int = if (n == 0) baseCase0 else { var b0 = baseCase0 var b1 = baseCase1 var i = 2 while (i \u0026lt;= n) { val b2 = recCase(b0, b1) b0 = b1 b1 = b2 i += 1 } b1 }scheme :: Int -\u0026gt; Int -\u0026gt; (Int -\u0026gt; Int -\u0026gt; Int) -\u0026gt; Int -\u0026gt; Int scheme baseCase0 baseCase1 recCase 0 = baseCase0 scheme baseCase0 baseCase1 recCase n = aux baseCase0 baseCase1 2 where aux b0 b1 i = if i \u0026lt;= n then aux b1 (recCase b0 b1) (i + 1) else b1 By now you should get a good grasp on what recursion schemes are. But we have only seen a tiny fraction of how useful they are. It\u0026rsquo;s about time to consider the real power of fact, sum and fib\u0026rsquo;s schemes.\nTime to take off! Previously we defined fact and sum\u0026rsquo;s schemes as\ndef scheme(baseCase: Int, recCase: (Int, Int) =\u0026gt; Int)(n: Int): Int = { var res = baseCase var i: Int = 1 while (i \u0026lt;= n) { res = recCase(i, res) i += 1 } res }scheme :: Int -\u0026gt; (Int -\u0026gt; Int -\u0026gt; Int) -\u0026gt; Int -\u0026gt; Int scheme baseCase recCase n = aux baseCase 1 where aux res i = if i \u0026lt;= n then aux (recCase i res) (i + 1) else res I have a small exercise for you: find where this code relies on baseCase to be an Int? It\u0026rsquo;s important, take the time to figure it out. The answer is simple: it does not! baseCase can actually be any of type A! We don\u0026rsquo;t even have to modify the code (only the type signature):\ndef scheme[A](baseCase: A, recCase: (Int, A) =\u0026gt; A)(n: Int): A = { var res = baseCase var i: Int = 1 while (i \u0026lt;= n) { res = recCase(i, res) i += 1 } res }scheme :: a -\u0026gt; (Int -\u0026gt; a -\u0026gt; a) -\u0026gt; Int -\u0026gt; a scheme baseCase recCase n = aux baseCase 1 where aux res i = if i \u0026lt;= n then aux (recCase i res) (i + 1) else res Not only can we still define fact (and sum) like above but it makes trivial defining the functions like list which returns the list of integers between n and 1:\ndef list: Int =\u0026gt; List[Int] = scheme[List[Int]](Nil, (n: Int, r: List[Int]) =\u0026gt; n :: r)list :: Int -\u0026gt; [Int] list = scheme [] (:) Unsurprisingly fib\u0026rsquo;s recursion scheme can also be generalized without changing a single line of code (only type signature):\ndef scheme[A](baseCase0: A, baseCase1: A, recCase: (A, A) =\u0026gt; A)(n: Int): A = if (n == 0) baseCase0 else { var b0 = baseCase0 var b1 = baseCase1 var i = 2 while (i \u0026lt;= n) { val b2 = recCase(b0, b1) b0 = b1 b1 = b2 i += 1 } b1 }scheme :: a -\u0026gt; a -\u0026gt; (a -\u0026gt; a -\u0026gt; a) -\u0026gt; Int -\u0026gt; a scheme baseCase0 baseCase1 recCase 0 = baseCase0 scheme baseCase0 baseCase1 recCase n = aux baseCase0 baseCase1 2 where aux b0 b1 i = if i \u0026lt;= n then aux b1 (recCase b0 b1) (i + 1) else b1 While fact\u0026rsquo;s scheme is related to lists, fib\u0026rsquo;s one is related to trees:\nsealed abstract class Tree[+A] final case class Leaf[+A](value: A) extends Tree[A] final case class Node[A](left: Tree[A], right: Tree[A]) extends Tree[A] def tree: Int =\u0026gt; Tree[Boolean] = scheme( Leaf(false), Leaf(true), (r1: Tree[Boolean], r2: Tree[Boolean]) =\u0026gt; Node(r1,r2) )data Tree a = Leaf a | Node (Tree a) (Tree a) tree :: Int -\u0026gt; Tree Bool tree = scheme (Leaf False) (Leaf True) Node I have few real exercises for you this time:\n find in your production code several spots where this scheme could be useful. write schemes, as general as possible, for at least 5 recursive functions in our production code.  Obviously I won\u0026rsquo;t check you did the exercises but you should really do them. Reading is not sufficient to develop your understanding of the technique, you need to experiment! Try things, play with these notions until it clicks. Learning recursion schemes is like going on expeditions: preparation time may seem the easier part but if you did not prepare well enough, you\u0026rsquo;ll get lost.\nYeah! Buzzwords! As we have seen, fact\u0026rsquo;s scheme takes 2 arguments:\ndef scheme[A](baseCase: A, recCase: (Int, A) =\u0026gt; A): Int =\u0026gt; Ascheme :: a -\u0026gt; (Int -\u0026gt; a -\u0026gt; a) -\u0026gt; Int -\u0026gt; a While this definition is perfectly ok, we can regroup these argument in any structure that can hold both values like a pair, an interface or a trait:\ntrait FactorialSchemeArguments[A] { val baseCase: A def recCase(n: Int, r: A): A } def scheme[A](arguments: FactorialSchemeArguments[A]): Int =\u0026gt; Aclass FactorialSchemeArguments a where baseCase :: a recCase :: Int -\u0026gt; a -\u0026gt; a scheme :: FactorialSchemeArguments a =\u0026gt; Int -\u0026gt; a Note that scheme is still the same: it still takes the same two arguments. But even if the code didn\u0026rsquo;t change, this transformation makes us see scheme from a different perspective. It shows scheme as a functions transforming an integer to an A provided that we give some structure to A: a constant baseCase and an operation recCase. Let\u0026rsquo;s give this structure and the scheme names: i decide to call the structure a AkolovioaAlgebra (don\u0026rsquo;t look for it in literature, i just coined the term) and the scheme an akolovioaMorphism:\ntrait AkolovioaAlgebra[A] { val initial: A def action(n: Int, r: A): A } def akolovioaMorphism[A: AkolovioaAlgebra]: Int =\u0026gt; Aclass AkolovioaAlgebra a where initial :: a action :: Int -\u0026gt; a -\u0026gt; a akolovioaMorphism :: AkolovioaAlgebra a =\u0026gt; Int -\u0026gt; a This looks smart, doesn\u0026rsquo;t it? 😉 It is actually very close to a very common structure in programming! Will you find which one? Obviously the same can be done for fibonacci\u0026rsquo;s scheme. As an exercise, apply this technique to fibonacci\u0026rsquo;s scheme and give them pretty names.\nWhere to go from here? As you know this is not the end of the story: the subject is closely related to pervasive notions such as (co)algebras, inductive types, categories, initial-objects, fixed-points, algebraic data types, etc. Whichever next subject you choose to dive into, the approach this article follows, i.e. experimenting on toy examples, really helps developing a solid understanding. I want you to realize each definition you read in books, articles, talks, etc is the result of people experimenting. The common trap in this field is looking at definitions as sacred pieces of unquestionable truth no mortal can see through. It is actually the exact opposite! Science is by essence experimentation. This is by investigating and trying things you end up figuring out how things work. But, like in science, for your investigation to be productive your tests need to be done in a controlled environment with as few variables as possible so that it is easy for you to see what\u0026rsquo;s going on. That\u0026rsquo;s why toy examples are so important: they contain the essence of what makes things work without all the noise real examples have.\nTake care and spread recursion schemes around 😉\n"
},
{
	"uri": "https://chrilves.github.io/posts/gadts_intro/",
	"title": "Demystifying GADTs",
	"tags": [],
	"description": "Introduction to catamorphisms on Algebraic Data Types",
	"content": " Generalized Algebraic Data Types (GADT) is certainly one of the most feared concept in programming nowadays. Very few mainstream languages support GADTs. The only ones i know which does are Haskell, Scala, OCaml and Haxe. The idea is actually very simple but often presented in complicated ways. In fact, if you\u0026rsquo;re familiar to both basic Object-Oriented-with-Generics and basic functional programming, then you most probably are already familiar with GADTs without even knowing you are. But if GADTs are so simple, why so many people feel terrified by them? Well GADTs rely on two fundamental ideas, one of them is known by every Object-Oriented-with-Generics programmer while the other is known by every functional programmer. The problem is most people make the huge mistake of opposing them even though they are complementary. So before diving into GADTs, let me remind you of these elementary notions from Object-Oriented and functional programming.\nObject-Oriented Programming 101 Let\u0026rsquo;s start by some plain old Java (the examples works in probably all Object-Oriented language which supports generics). We want to define an abstract class for sequences:\npublic abstract class Sequence\u0026lt;A\u0026gt; { abstract public int length(); abstract public A getNthElement(int nth); } In Java it would be better to define Sequence\u0026lt;A\u0026gt; as an interface but i want this example to be as simple as possible. Would you be surprised if told you a String is a sequence of characters ? ;) As i said, GADTs rely on very basic programming knowledge.\npublic class MyString extends Sequence\u0026lt;Character\u0026gt; { private String str; public MyString(String s) { this.str = s; } public int length() { return this.str.length(); } public Character getNthElement(int nth) { return this.str.charAt(nth); } } Likewise, bytes are sequences of 8 bits (we represent a bit by a Boolean):\npublic final class MyByte extends Sequence\u0026lt;Boolean\u0026gt; { private byte bte; public MyByte(byte x) { this.bte = x; } public int length() { return 8; } public Boolean getNthElement(int nth) { if (nth \u0026gt;= 0 \u0026amp;\u0026amp; nth \u0026lt;= 7) return ((bte \u0026gt;\u0026gt;\u0026gt; nth \u0026amp; 1) == 1); else throw new java.lang.IndexOutOfBoundsException(\u0026#34;\u0026#34;); } } Have you noticed how MyByte and MyString declares themselves being respectively a sequence of booleans (Sequence\u0026lt;Boolean\u0026gt;) and a sequence of characters (Sequence\u0026lt;Character\u0026gt;) but not sequences of A (Sequence\u0026lt;A\u0026gt;) for any type A? Let\u0026rsquo;s try to make it work for any type A:\npublic final class MyByte\u0026lt;A\u0026gt; extends Sequence\u0026lt;A\u0026gt; { private byte bte; public MyByte(byte x) { this.bte = x; } public int length() { ??? } public A getNthElement(int nth) { ??? } } How would you write the methods length and getNthElement? Do you really imagine what would be a MyByte\u0026lt;Graphics2D\u0026gt;? It just doesn\u0026rsquo;t make any sense at all. You could argue that a string is also a sequence of byte and a byte a sequence of one byte. Indeed this relation is not unique, but it does not change the fact that it works for only a small selection of type A and not every one! We can go even deeper in Object-Oriented Programming:\npublic final class MyArray\u0026lt;A extends Number\u0026gt; extends Sequence\u0026lt;Number\u0026gt; { private A[] array; public MyArray(A[] a) { this.array = a; } public int length() { return this.array.length; } public Number getNthElement(int nth) { return this.array[nth]; } } Note how the generics A, which is required to be a sub-class of Number, is present as argument of MyArray but not in extends Sequence\u0026lt;Number\u0026gt;. Now what do you think about this code? Do you think it can be wrong?\npublic static \u0026lt;A\u0026gt; void guess(Sequence\u0026lt;A\u0026gt; x) { if (x instanceof MyByte) { System.out.println(\u0026#34;I guess A is actually Boolean, let\u0026#39;s check!\u0026#34;); System.out.println(((Sequence\u0026lt;Boolean\u0026gt;)x).getNthElement(0).getClass().getName()); } else if (x instanceof MyString) { System.out.println(\u0026#34;I guess A is actually Character\u0026#34;); System.out.println(((Sequence\u0026lt;Character\u0026gt;)x).getNthElement(0).getClass().getName()); } else if (x instanceof MyArray\u0026lt;?\u0026gt;) { System.out.println(\u0026#34;I guess A is a sub-class of Number but i can not guess which one\u0026#34;); System.out.println(((Sequence\u0026lt;?\u0026gt;) x).getNthElement(0).getClass().getName()); } else System.out.println(\u0026#34;I don\u0026#39;t know what A is\u0026#34;); }  If x is an instance of MyByte, which is a sub-class of Sequence\u0026lt;Boolean\u0026gt;, then by trivial inheritance x is also an instance of Sequence\u0026lt;Boolean\u0026gt;. In this case A is forced to be Boolean. If x is an instance of MyString, which is a sub-class of Sequence\u0026lt;Character\u0026gt;, then again by trivial inheritance x is also an instance of Sequence\u0026lt;Character\u0026gt; . In this case A has to be Character. If x is an instance of MyArray\u0026lt;A\u0026gt; for some type A, which is a sub-class of Sequence\u0026lt;Number\u0026gt;, then once again by trivial inheritance x is an instance of Sequence\u0026lt;Number\u0026gt;. In this case we know A is a sub-class of Number but we don\u0026rsquo;t know which one.  This is the essence of Generalized Algebraic Data Types. It you understand the code above, then you understand how GADTs work. As you see this is very basic Oriented-Object with Generics. You can find lots of examples of this kind in almost every Java/C#/etc project (search for the instanceof keyword).\nFunctional Programming 101 Functional languages often support a feature called Algebraic Data Types (ADT) which is essentially enumerations on steroids. Like enumerations this is a disjoint union of a fixed number of cases but unlike enumerations, where each case is a constant, ADTs cases can have parameters. As an example, the type of lists whose elements are of type a, written List a in Haskell, is defined:\ndata List a = Nil | Cons a (List a) It means any value of type List a belong to exactly one of the following cases:\n either the value is the constant Nil which represents the empty list. or the value is Cons hd tl which represent the list whose first element is hd (of type a) and whose tail is tl (of type List a).  The list [1,2,3,4] is encoded by Cons 1 (Cons 2 (Cons 3 (Cons 4 Nil))). Where ADTs really shine is pattern-matching which is a very powerful and flexible switch (as i said above, ADTs are enumerations on steroids). ADTs being made of a fixed number of distinct cases, pattern-matching enable to inspect values and perform computations based on a case by case analysis of the form of the value. Here is how to implement the merge sort algorithm on this type:\nsplit :: List a -\u0026gt; (List a, List a) split l = case l of Cons x (Cons y tl) -\u0026gt; (case split tl of (l1, l2) -\u0026gt; (Cons x l1, Cons y l2) ) Cons _ Nil -\u0026gt; (l , Nil) Nil -\u0026gt; (Nil, Nil) merge :: (a -\u0026gt; a -\u0026gt; Bool) -\u0026gt; List a -\u0026gt; List a -\u0026gt; List a merge isLessThan l1 l2 = case (l1, l2) of (_ , Nil ) -\u0026gt; l1 (Nil , _ ) -\u0026gt; l2 (Cons hd1 tl1, Cons hd2 _ ) | hd1 `isLessThan` hd2 -\u0026gt; Cons hd1 (merge isLessThan tl1 l2) (_ , Cons hd2 tl2) -\u0026gt; Cons hd2 (merge isLessThan l1 tl2) sort :: (a -\u0026gt; a -\u0026gt; Bool) -\u0026gt; List a -\u0026gt; List a sort isLessThan l = case l of Nil -\u0026gt; Nil Cons _ Nil -\u0026gt; l _ -\u0026gt; case split l of (l1, l2) -\u0026gt; merge isLessThan (sort isLessThan l1) (sort isLessThan l2) I know there are smarter ways to write it in Haskell but this article is not about it. The code above could be translated trivially in OCaml by replacing case ... of by match ... with, in Scala by ... match { ... }, etc. This style is valid is probably all languages supporting pattern-matching so it fits our goal.\nThe case l of expressions are pattern-matching. They are a sequence of pattern | condition -\u0026gt; code. The code being executed is the right-hand side of the first case for which the value l is of the form of its pattern and satisfy the condition. l is then said to match this case. For example, the case Cons x (Cons y tl) -\u0026gt; (case split tl of (l1, l2) -\u0026gt; (Cons x l1, Cons y l2)) states that if l is of the form Cons x (Cons y tl), which means that there are three values x, y and tl such that l == Cons x (Cons y tl), then the code executed is (case split tl of (l1, l2) -\u0026gt; (Cons x l1, Cons y l2)). One very important condition is that pattern-matching must be exhaustive! It means that the sequence of cases must cover all possible value of l.\nIf your understand the previous section, the type List a and how pattern-matching works in the example above, then i am very glad to inform you that you already understand GADTs! Well done :)\nSumming up! In this section i assume previous sections are ok for you. If you do not understand previous examples, don\u0026rsquo;t go further but go back to the basics of generics and pattern-matching. Likewise, if you find what follows complicated, go back to the basics generics and pattern-matching. There is no shame in doing so! Difficulties in understanding advanced notion is often the reflect of a lack of understanding in the ones they rely upon. As i said, there is no shame in it, if you think programming paradigms are \u0026ldquo;simple\u0026rdquo; then write a compiler ;)\nIt\u0026rsquo;s about time to sum up everything. First, note that List a is not one single type. Each type a actually gives rise to a distinct type List a. For example List Int, List String, List (List Bool), etc are all distinct types. Indeed the list Cons 1 Nil is neither a list of strings nor of booleans! For each type a, the type List a have two constructors: the constant Nil and the function Cons :: a -\u0026gt; List a -\u0026gt; List a which builds a List a from a value of type a and other List a.\nThere is another equivalent way to define List a in Haskell which makes the nature of the constructor more apparent:\ndata List a where Nil :: List a Cons :: a -\u0026gt; List a -\u0026gt; List a Indeed, for each type a, Nil is constant of type List a while Cons is a function of type a -\u0026gt; List a -\u0026gt; List a. Note that it is actually very close to the way to define it in Scala:\nsealed abstract class List[A] final case class Nil[A]() extends List[A] final case class Cons[A](head: A, tail: List[A]) extends List[A] Do you remember the example of the first section Sequence\u0026lt;A\u0026gt;? There was three sub-classes of Sequence\u0026lt;A: MyString which is actually a sub-class of Sequence\u0026lt;Character\u0026gt;, MyByte which is a sub-class of Sequence\u0026lt;Boolean\u0026gt; and MyArray\u0026lt;A extends Number\u0026gt; which is a sub-class of Sequence\u0026lt;Number\u0026gt;. What is the type of their constructors? Some admissible type for them is (in Scala notation):\ndef MyString : String =\u0026gt; Sequence[Character] def MyByte : Byte =\u0026gt; Sequence[Boolean] def MyArray[A \u0026lt;: Number] : Array[A] =\u0026gt; Sequence[Number] From this, this is trivial to write:\nsealed abstract class Sequence[A] final case class MyString(str: String) extends Sequence[Character] final case class MyByte(bte: Byte) extends Sequence[Boolean] final case class MyArray[A \u0026lt;: Number](array: Array[A]) extends Sequence[Number] or in Haskell:\ndata Number where MkNum :: forall a. Num a =\u0026gt; Number data Sequence a where MyString :: String -\u0026gt; Sequence Char MyByte :: Word8 -\u0026gt; Sequence Bool MyArray :: forall a. Num a =\u0026gt; List a -\u0026gt; Sequence Number Sequence is a GADT. What makes it different from List above? For any type a, values of type List a are build using the two constructors Nil and Cons. Note that it does not depend on what a is. Values of type List Int are build using the exact same constructors than List Bool, List String, List (List Char), etc. Sequence have three constructors MyString, MyByte and MyArray. But values of type Sequence[Character] can only be built by the constructor MyString while values of type Sequence[Boolean] can only be built by the constructor MyByte and values of type Sequence[Number] can only be built by the constructor MyArray. What about values of type Sequence[Unit] or Sequence[String], etc? There is simply no constructor to build values of these types, so there is no values of these types!\nWe can rewrite the methods on Sequence and the guess function to use patten-matching:\ndef length[A](x: Sequence[A]): Int = x match { case MyByte(_) =\u0026gt; 8 case MyString(str) =\u0026gt; str.length case MyArray(arr) =\u0026gt; arr.size } def getNthElement[A](x: Sequence[A], nth: Int): A = x match { case MyByte(bte) =\u0026gt; // So A is actually Boolean  if (nth \u0026gt;= 0 \u0026amp;\u0026amp; nth \u0026lt;= 7) (bte \u0026gt;\u0026gt;\u0026gt; nth \u0026amp; 1) == 1 else throw new java.lang.IndexOutOfBoundsException(\u0026#34;\u0026#34;) case MyString(str) =\u0026gt; // So A is actually Character  str.charAt(nth) case MyArray(array) =\u0026gt; // So A is actually a sub-class of Number  array(nth) } def guess[A](x : Sequence[A]): Unit = x match { case MyByte(bte) =\u0026gt; println(\u0026#34;I guess A is actually Boolean, let\u0026#39;s check!\u0026#34;) println(getNthElement(x, 0).getClass.getName) case MyString(str) =\u0026gt; println(\u0026#34;I guess A is actually Character\u0026#34;) println(getNthElement(x, 0).getClass.getName) case MyArray(array) =\u0026gt; println(\u0026#34;I guess A is a sub-class of Number but i can not guess which one\u0026#34;) println(getNthElement(x, 0).getClass.getName) } As you can see getNthElement must returns a value of type A but the case MyByte returns a Boolean. It means Scala is aware that in this case A is actually Boolean. Likewise in the case MyString, Scala knowns that the only possible concrete type for A is Character so it accepts we return one. Scala is (most of the time) able to guess, depending on the case, what are the constraints on A. This is all the magic behind GADTs: specialized constructors like in object-oriented-with-generics programming and closed types (i.e. with a fixed number of cases) on which we can pattern-match like in usual functional programming.\nHow are GADTs useful? First of all, there are handy when you have a specialized constructor like in every day life object-oriented programming. It makes sense for a byte (resp. string) to be sequence of booleans (resp. characters) but not a sequence of anything. A prolific use of this is writing implicits in Scala as GADTs. This way we can pattern-match on the structure of the implicits to derive instances (see this gist for more details). They are also very useful to encode properties on types. As i said above, not all types Sequence[A] have (non-null) values! There is no (non-null) value of type Sequence[Unit] or Sequence[String] etc but there are values of type Sequence[Boolean], Sequence[Character] and Sequence[Number]. So if i give you a value of type Sequence[A], then you know A is either Boolean, Character or Number. If you don\u0026rsquo;t believe me, try to call the function guess on a type A which is neither Boolean nor Character nor Number (without using null)! Let me give you some useful examples.\nThe first one is restricting a generic type like in the code below. The GADT IsIntOrString forces A to be either String or Int in the function and the case class.\nsealed abstract class IsIntOrString[A] implicit final case object IsInt extends IsIntOrString[Int] implicit final case object IsString extends IsIntOrString[String] def canOnlyBeCalledOnIntOrString[A](a: A)(implicit ev: IsIntOrString[A]): A = ev match { case IsInt =\u0026gt; // A is Int  a + 7 case IsString =\u0026gt; // A is String  a.reverse } final case class AStringOrAnIntButNothingElse[A](value: A)(implicit val proof : IsIntOrString[A]) Another handy use is encoding effects:\ntrait UserId trait User sealed abstract class BusinessEffect[A] final case class GetUser(userId: UserId) extends BusinessEffect[User] final case class SetUser(user: User) extends BusinessEffect[UserId] final case class DelUser(userId: UserId) extends BusinessEffect[Unit] Have you ever heard that Set is not a functor? With the usual definition of a functor, indeed Set is not one.\ntrait Functor[F[_]] { def map[A,B](fa: F[A])(f: A =\u0026gt; B): F[B] } The reason is you can only have a Set[A] for types A such that you can compare values. As an example let A be Int =\u0026gt; Int. The two following functions are arguably equal:\nval doubleByMult: Int =\u0026gt; Int = (x: Int) =\u0026gt; 2 * x val doubleByPlus: Int =\u0026gt; Int = (x: Int) =\u0026gt; x + x scala\u0026gt; Set(doubleByMult).contains(doubleByPlus) res0: Boolean = false This is just impossible, in the general case, to know if two functions compute the same thing. I didn\u0026rsquo;t just say we don\u0026rsquo;t know how to do it. It is actually proven that this is impossible (like no one can, and no one could for ever!). Have a look at this List of undecidable problems for more information on the subject. Using extensional equality (the one where f == g if and only f(x) == g(x) for all x), there is just no implementation of Set[Int =\u0026gt; Int]. But if Set was a functor, it would be trivial using map to get a Set[Int =\u0026gt; Int]:\nSet[Boolean](true, false).map { case true =\u0026gt; doubleByMult case false =\u0026gt; doubleByPlus }: Set[Int =\u0026gt; Int] The conclusion is that Set is not a functor \u0026hellip; in the usual (i.e. Scal) category. But it is in for some categories. The problem with Functor is map can be applied on any A and B which is impossible for Set. But if we restrict A and B such that they have interesting properties (like having an Ordering), then it works. In the code below, the GADT predicate is used to restrict on which A and B map can be applied on:\ntrait GenFunctor[predicate[_],F[_]] { def map[A,B](fa: F[A])(f: A =\u0026gt; B)(implicit proofA: predicate[A], proofB: predicate[B]): F[B] } Then Set is becomes a functor with Ordering as predicate:\nobject SetInstance extends GenFunctor[Ordering, Set] { def map[A,B](fa: Set[A])(f: A =\u0026gt; B)(implicit orderingA: Ordering[A], orderingB: Ordering[B]): Set[B] = { val set = TreeSet.newBuilder(orderingB) for (a \u0026lt;- fa) set += f(a) set.result } } Surprisingly even String can be a functor (with A and B being both Char)!!!\nsealed abstract class IsItChar[A] implicit final case object YesItIsChar extends IsItChar[Char] type StringK[A] = String object StringInstance extends GenFunctor[IsItChar, StringK] { def map[A,B](fa: String)(f: A =\u0026gt; B)(implicit proofA: IsItChar[A], proofB: IsItChar[B]): String = (proofA, proofB) match { case (YesItIsChar, YesItIsChar) =\u0026gt; // A and B are both Char!  fa.toList.map(f).mkString } } GADTs are an example of Bushnell\u0026rsquo;s law. As you can see, they are easy to learn but can be used in very tricky situations which makes them hard to master. They are clearly very helpful in many situations but it seems they are still unfortunately very little used. Haskell supports them very well! Scala\u0026rsquo;s support is actually very good but not as good as Haskell\u0026rsquo;s. Scala 3 will probably support them as well as Haskell since Dotty\u0026rsquo;s support is excellent. The only two other mainstream languages i know supporting them are OCaml and Haxe. Even if those two have a very good support, their lack of Higer-Kinded types forbids the most interesting uses.\nAs you probably know, it is possible to define a fold functor for every Algebraic Data Type. It is also possible to define fold functions for every GADT. As an exercise, try to define fold functions for the following GADTs:\n This GADT encode the equality between two types A and B:\nsealed abstract class Eq[A,B] final case class Refl[A]() extends Eq[A,A] This GADT represent an unknown type for which we have an instance of a type-class:\nsealed abstract class Ex[TypeClass[_]] final case class MakeEx[TypeClass[_],A](value:A, instance: TypeClass[A]) extends Ex[TypeClass]  You\u0026rsquo;ll find how to define such fold functions here. Have fun and spread the love of GADTs everywhere :)\n"
},
{
	"uri": "https://chrilves.github.io/posts/",
	"title": "Posts",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://chrilves.github.io/types/5-rectypes/",
	"title": "Episode 5 - Recursive Data Types",
	"tags": [],
	"description": "",
	"content": " We have seen many types but we still don\u0026rsquo;t know how to represent numbers, lists, trees, free monads, or any type with an infinite number of values. One again we will start by simple examples. Like always, do no skim through them but take the time to develop a deep understanding. If you feel uncomfortable with complex examples, it means you missed something important in the simple ones.\nA simple example We will take as example an encoding of non-negative integers, also called natural numbers, i.e. numbers 0, 1, 2, 3 and so on. There are actually many encodings possible, but we will take a simple encoding known as Peano numbers. Did you ever wonder how natural numbers are built? There can actually be built starting from 0 then adding 1 to 0 to make 1, then adding 1 to 1 to make 2, then adding 1 to 2 to make 3, then adding 1 to 3 to make 4, and so on. Our encoding will mimic this construction. We need two constructors: one of represent 0 and the other to represent the operation of adding 1 to the previous number to make a new one.\nLet\u0026rsquo;s call Nat the type of natural numbers. The first constructor, representing 0 should be a constant of type Nat while the second one, representing the operation of adding 1 should be a function of type Nat =\u0026gt; Nat. Remember that constructors need to be injective, but we are lucky, this operation is actually injective. Let call the first constructor Zero:Nat and the second one Succ:Nat =\u0026gt; Nat (for successor). This is easy to translate into Scala and Haskell:\nsealed abstract class Nat { def fold[A](zero: A, succ: A =\u0026gt; A): A = this match { case Zero =\u0026gt; zero case Succ(p) =\u0026gt; val a = p.fold(zero, succ) succ(a) } } final case object Zero extends Nat final case class Succ(n: Nat) extends Natdata Nat where Zero :: Nat Succ :: Nat -\u0026gt; Nat Note that all the constructors we have seen in the previous episodes took as argument already defined types, but the first argument of Succ is of type Nat, the very same type we are defining. This is the reason why Nat is called a recursive data type: some of its constructors take as arguments values of type Nat itself. As usual:\n constructors are injective different constructors produces different value every value of type Nat is either a Zero or a Succ(n) for some n:Nat  The problem is, unlike enumerations, products and coproducts where these properties are enough to define their respective type (up to equivalence) without ambiguity. With recursive data types there can be several non-equivalent types for which these three properties hold. For example, the type {0, 1, 2, ...} of natural numbers and {O, 1, 2, ..., ∞} in which we added one special number called infinity such that Succ(∞) = ∞ both have the three properties above. So wee need to add a new constraint, which is that: among all the types for which these properties hold, Nat is taken as the smallest one.\nRecursive types have amazing properties. For example the types Nat and Option[Nat] are equivalent! Indeed nat2opt and opt2nat are inverse bijections:\ndef opt2nat: Option[Nat] =\u0026gt; Nat = { case Some(n) =\u0026gt; Succ(n) case None =\u0026gt; Zero } def nat2opt: Nat =\u0026gt; Option[Nat] = { case Succ(n) =\u0026gt; Some(n) case Zero =\u0026gt; None }opt2nat :: Maybe Nat -\u0026gt; Nat opt2nat (Just n) = Succ n opt2nat Nothing = Zero nat2opt :: Nat -\u0026gt; Maybe Nat nat2opt (Succ n) = Just n nat2opt Zero = Nothing It means that Nat ≅ Option[Nat]. Note that Option[T] ≅ Either[Unit, T] ≅ 1 + T in Type Theory notation, so Nat is actually one of the solution of the type equation T ≅ 1 + T. Such an equation means we are looking for types T such that T and Option[T] are equivalent. Regarding Option as a function from types to type, where the type Option[T] is the one obtained by applying the argument T to the function Option, Nat is one of the fixed-point of this function. More precisely, Nat is the least fixed-point of Option.\n Let μ: (Type -\u0026gt; Type) -\u0026gt; Type be the operator taking a type function F as argument (written F[_] in Scala and f :: * -\u0026gt; * in haskell) and returning the least fixed-point of F, which is defined as the smallest type T (up to equivalence) which is solution of the equation T ≅ F[T]. To simplify the notations, we may also write μT.F[T] instead of μ(F).\n As an example Nat = μ(Option) which we also write Nat = μT.Either[Unit, T] and also Nat = μT.(1 + T).\nAnother solution to the equation, which is, this time the greatest fixed-point of Option is the type NatInf, representing {0, 1, 2, ..., ∞}, defined as below. It is the biggest type which is solution (up to equivalence) of the equation T ≅ 1 + T. The two inverse functions opt2natInf and natInf2opt proves the equivalence:\ntrait NatInf { def unfold: Option[NatInf] } val zero: NatInf = new NatInf { def unfold: Option[NatInf] = None } def succ(n: NatInf): NatInf = new NatInf { def unfold: Option[NatInf] = Some(n) } val ∞ : NatInf = new NatInf { def unfold: Option[NatInf] = Some(∞) } def opt2natInf: Option[NatInf] =\u0026gt; NatInf = { case Some(n) =\u0026gt; succ(n) case None =\u0026gt; zero } def natInf2opt: NatInf =\u0026gt; Option[NatInf] = (n: NatInf) =\u0026gt; n.unfoldnewtype NatInf = NatInf { unfold :: Maybe NatInf } zero :: NatInf zero = NatInf Nothing succ :: NatInf -\u0026gt; NatInf succ n = NatInf (Just n) inf :: NatInf inf = NatInf (Just inf) opt2natInf :: Maybe NatInf -\u0026gt; NatInf opt2natInf (Just n) = succ n opt2natInf Nothing = zero natInf2opt :: NatInf -\u0026gt; Maybe NatInf natInf2opt = unfold Equivalence of inductive and functional definitions Nat can be equivalently defined as a data type NatInd as well as a function type NatFun. Inverse bijections ind2fun and fun2ind prove NatInf and NarInd are equivalent:\nsealed abstract class NatInd final case object ZeroInd extends NatInd final case class SuccInd(n: NatInd) extends NatInd trait NatFun { def fold[A](zero: A, succ: A =\u0026gt; A): A } val zeroFun : NatFun = new NatFun { def fold[A](zero: A, succ: A =\u0026gt; A): A = zero } def succFun(n: NatFun) : NatFun = new NatFun { def fold[A](zero: A, succ: A =\u0026gt; A): A = { val a = n.fold[A](zero, succ) succ(a) } } def ind2fun: NatInd =\u0026gt; NatFun = (i: NatInd) =\u0026gt; i match { case ZeroInd =\u0026gt; zeroFun case SuccInd(p) =\u0026gt; val n = ind2fun(p) succFun(n) } def fun2ind: NatFun =\u0026gt; NatInd = (n: NatFun) =\u0026gt; n.fold[NatInd](ZeroInd, SuccInd(_))data NatInd where ZeroInd :: NatInd SuccInd :: NatInd -\u0026gt; NatInd type NatFun = forall a. a -\u0026gt; (a -\u0026gt; a) -\u0026gt; a zeroFun :: NatFun zeroFun z _ = z succFun :: NatFun -\u0026gt; NatFun succFun n z s = s (n z s) ind2fun :: NatInd -\u0026gt; NatFun ind2fun ZeroInd = zeroFun ind2fun (SuccInd n) = succFun (ind2fun n) fun2ind :: NatFun -\u0026gt; NatInd fun2ind n = n ZeroInd SuccInd Lists Similarly, given a type A, we want to define the the type of lists whose elements are of type A, written List[A]. Let l:List[A] be a list whose elements are of type A. There are two cases: either the list is empty or it is not. Let\u0026rsquo;s call the the empty list Nil. If the list is not empty, let head be its first element and tail the rest of the list (i.e. the same list as l but without the first element head). Then tail is also a list of type List[A] and l can be obtained by prepending head to tail. We will write this prepending operation Cons :: (A, List[A]) =\u0026gt; List[A] such that l = Cons(head, tail).\nOnce again we see we have two constructors: Nil of type List[A] and Cons of type (A, List[A]) =\u0026gt; List[A]. Besides, these constructors satisfy the usual thee properties:\n constructors are injective different constructors produces different value every value of type List[A] is either a Nil or a Cons(head, tail) for some head:A and some tail:List[A]  Furthermore List[A] is the smallest type satisfying these properties. It can easily be defined in Scala as\nsealed abstract class List[+A] { def fold[R](nil: R, cons: (A,R) =\u0026gt; R): R = this match { case Nil =\u0026gt; nil case Cons(head,tail) =\u0026gt; val r = tail.fold[R](nil, cons) cons(head, r) } } final case object Nil extends List[Nothing] final case class Cons[+A](head: A, tail: List[A]) extends List[A] Like any recursive data type, List[A] is the smallest solution of a type equation. This time the equation is T ≅ 1 + (A, T) which in a more Scalaish syntax is T ≅ Option[(A, T)]. Equivalently, List[A] is also the least fixed-point of the type-function:\ntype F[T] = Option[(A, T)] Which means List[A] = μT.(1 + A × T). The biggest type which is solution (up to equivalence) of the equation, which is the greatest fixed-point of F is the type of streams whose elements are of type A, written Stream[A]:\ntrait Steam[A] { def unfold: Option[(A, Stream[A])] }newtype Stream a = Stream { runStream :: forall c. (Maybe (a, Stream a) -\u0026gt; c) -\u0026gt; c } Exercise: write the bijections proving Stream[A] ≅ Option[(A, Stream[A])]\nEquivalence of inductive and functional definitions List[A] can equivalently be defined as the data type ListInd[A] as well as the type function ListFun[A]. The two inverse functions ind2fun and fun2ind prove ListInd[A] and ListFun[A] are equivalent:\nsealed abstract class ListInd[+A] final case object NilInd extends ListInd[Nothing] final case class ConsInd[+A](head: A, tail: ListInd[A]) extends ListInd[A] trait ListFun[+A] { def fold[R](nil: R, cons: (A,R) =\u0026gt; R): R } def nilFun[A]: ListFun[A] = new ListFun[A] { def fold[R](nil: R, cons: (A,R) =\u0026gt; R): R = nil } def consFun[A](head: A, tail: ListFun[A]): ListFun[A] = new ListFun[A] { def fold[R](nil: R, cons: (A,R) =\u0026gt; R): R = { val r = tail.fold[R](nil, cons) cons(head, r) } } def ind2fun[A]: ListInd[A] =\u0026gt; ListFun[A] = (i: ListInd[A]) =\u0026gt; i match { case NilInd =\u0026gt; nilFun[A] case ConsInd(head, tail) =\u0026gt; val tailFun = ind2fun(tail) consFun(head, tailFun) } def fun2ind[A]: ListFun[A] =\u0026gt; ListInd[A] = (f: ListFun[A]) =\u0026gt; f.fold[ListInd[A]](NilInd, ConsInd(_,_))data ListInd a where NilInd :: ListInd a ConsInd :: a -\u0026gt; ListInd a -\u0026gt; ListInd a type ListFun a = forall r. r -\u0026gt; (a -\u0026gt; r -\u0026gt; r) -\u0026gt; r nilFun :: ListFun a nilFun nil _ = nil consFun :: a -\u0026gt; ListFun a -\u0026gt; ListFun a consFun head tail nil cons = cons head (tail nil cons) ind2fun :: ListInd a -\u0026gt; ListFun a ind2fun NilInd = nilFun ind2fun (ConsInd head tail) = consFun head (ind2fun tail) fun2ind :: ListFun a -\u0026gt; ListInd a fun2ind f = f NilInd ConsInd Algebraic Data Types Algebraic Data Types are types that can be expressed using only False, Unit, products, coproducts and the least fixed-point operator μ. For example, binary trees whose elements are of type A, defined in Scala by\nsealed abstract class Tree[+A] { def fold[R](empty: R, leaf: A =\u0026gt; R, node: (R, R) =\u0026gt; R): R = this match { case Empty =\u0026gt; empty case Leaf(a) =\u0026gt; leaf(a) case Node(l, r) =\u0026gt; val al = l.fold[R](empty, leaf, node) val ar = r.fold[R](empty, leaf, node) node(al, ar) } } final case object Empty extends Tree[Nothing] final case class Leaf[+A](value: A) extends Tree[A] final case class Node[+A](left: Tree[A], right: Tree[A]) extends Tree[A] can be expressed as the type Tree[A] = μT.(1 + A + (T × T)), which is the smallest type (up to equivalence) solution of the equation T ≅ Either3[Unit, A, (T, T)].\nExercise: write the bijection proving the equivalence.\n"
},
{
	"uri": "https://chrilves.github.io/types/4-coproducts/",
	"title": "Episode 4 - CoProducts",
	"tags": [],
	"description": "",
	"content": " CoProducts, often called sum types, discriminated unions or disjoint unions, are a convenient way to express an alternative between different types. The coproduct of n types (with n being 0, 1, 2, etc) A_1, A_2, \u0026hellip;, A_n is precisely the type whose values are (i, a_i) where i is a number, called the tag, between 1 and n both included (1 ≤ i ≤ n) and a_i is a value of type A_i (the actual type then depends on the value of i). Is is often written Either[A_1, ..., A_n] in programming and A_1 + ... + A_n in Type Theory.\nLet\u0026rsquo;s take, as an example, n = 4, A_1 = Char, A_2 = Boolean, A_3 = Char and A_4 = Double. The following values are all valid and distinct values of type Either4[Char, Boolean, Char, Double]: (1, 'C'), (2, true), (3, 'D'), (4, 3.2), (3, 'C'). Note that (1, 'C') and (3, 'C') are different values because the tag is different.\nInstead of writing the tag explicitly, programming languages often let us write n constructors: Inj_i: A_i =\u0026gt; Either_n[A_1, ..., A_n] such that $$\\forall i\\in{1,\\dots,n},\\quad \\texttt{Inj}_i : \\texttt{A}_i \\rightarrow \\texttt{Either}_n[\\texttt{A}_1,\\dots,\\texttt{A}_n]$$ $$\\forall i\\in{1,\\dots,n},\\quad \\forall a_i:\\texttt{A}_i,\\quad \\texttt{Inj}_i(a_i) = (i, a_i)$$\nNote that:\n As usual constructors are injective functions $$\\forall i\\in{1,\\dots,n},\\quad \\forall a_i,a\u0026rsquo;_i:\\texttt{A}_i,\\quad \\texttt{Inj}_i(a_i) = \\texttt{Inj}_i(a\u0026rsquo;_i) \\Leftrightarrow a_i = a\u0026rsquo;_i$$ The only way to get a value of type Either_n[A_1, ... , A_n] is by using one of the constructors $$\\forall v:\\texttt{Either}_n[\\texttt{A}_1,\\dots,\\texttt{A}_n],\\quad \\exists! i\\in{1,\\dots,n},\\quad \\texttt{Inj}_i(a_i) = v$$ Two different constructors produce different values (hense the disjoint and discriminated unions) $$\\forall i,j\\in{1,\\dots,n},\\quad \\forall a_i:\\texttt{A}_i,\\quad \\forall a_j:\\texttt{A}_j,\\quad \\texttt{Inj}_i(a_i) = \\texttt{Inj}_j(a_j) \\Leftrightarrow i = j \\textbf{ and } a_i = a_j$$  For example with n = 2, the coproduct of two types A and B is defined as\nsealed abstract class Either2[A,B] { def fold[R](inj1: A =\u0026gt; R, inj2: B =\u0026gt; R): R = this match { case Inj1(a) =\u0026gt; inj1(a) case Inj2(b) =\u0026gt; inj2(b) } } final case class Inj1[A,B](value: A) extends Either2[A,B] final case class Inj2[A,B](value: B) extends Either2[A,B] Saying the pattern matching above is exhaustive is exactly equivalent to say a value of type Either2[A,B] has to be either Inj1(a) for some a:A or Inj2(b) for some b:B. Requiring that Inj1 and Inj2 produce different values is also mandatory as Eirher2[Error, Result] is often used to model computation that may fail. A failed computation would produce a Inj1(e) with e being the error that occurred while a successful computation would produce a Inj2(r) with r the result of the computation. We want to be able to discriminate these two cases, even when the types Error and Result are the same as it is usually the case when the computation need to compute a string or fail with an error message. Likewise, the injectivity of the constructors is mandatory to be able to the result produced r or the error that occurred e.\nEquivalence of inductive and functional forms Once again any *coproductù can be equivalently expressed as a data type Either_n_Ind[A_1, ..., A_n] and as a function type Either_n_Fun[A_1, ..., A_n] with inverse functions ind2fun and fun2ind converting back and forth types Either_n_Ind[A_1, ..., A_n] and Either_n_Fun[A_1, ..., A_n]. For example with n = 2:\nsealed abstract class Either2Ind[A,B] final case class Inj1_Ind[A,B](value: A) extends Either2Ind[A,B] final case class Inj2_Ind[A,B](value: B) extends Either2Ind[A,B] trait Either2Fun[A,B] { def fold[R](inj1: A =\u0026gt; R, inj2: B =\u0026gt; R): R } def inj1_fun[A,B]: A =\u0026gt; Either2Fun[A,B] = (a: A) =\u0026gt; new Either2Fun[A,B] { def fold[R](inj1: A =\u0026gt; R, inj2: B =\u0026gt; R): R = inj1(a) } def inj2_fun[A,B]: B =\u0026gt; Either2Fun[A,B] = (b: B) =\u0026gt; new Either2Fun[A,B] { def fold[R](inj1: A =\u0026gt; R, inj2: B =\u0026gt; R): R = inj2(b) } def ind2fun[A,B]: Either2Ind[A,B] =\u0026gt; Either2Fun[A,B] = (i: Either2Ind[A,B]) =\u0026gt; i match { case Inj1_Ind(a) =\u0026gt; inj1_fun(a) case Inj2_Ind(b) =\u0026gt; inj2_fun(b) } def fun2ind[A,B]: Either2Fun[A,B] =\u0026gt; Either2Ind[A,B] = (f: Either2Fun[A,B]) =\u0026gt; f.fold[Either2Ind[A,B]](Inj1_Ind[A,B] _, Inj2_Ind[A,B] _)data Either2Ind a b where Inj1_Ind :: a -\u0026gt; Either2Ind a b Inj2_Ind :: b -\u0026gt; Either2Ind a b type Either2Fun a b = forall c. (a -\u0026gt; c) -\u0026gt; (b -\u0026gt; c) -\u0026gt; c inj1_fun :: a -\u0026gt; Either2Fun a b inj1_fun a f _ = f a inj2_fun :: b -\u0026gt; Either2Fun a b inj2_fun b _ g = g b ind2fun :: Either2Ind a b -\u0026gt; Either2Fun a b ind2fun (Inj1_Ind a) = inj1_fun a ind2fun (Inj2_Ind a) = inj2_fun a fun2ind :: Either2Fun a b -\u0026gt; Either2Ind a b fun2ind f = f Inj1_Ind Inj2_Ind Generalization to a product of any number of types The definition of Either2 above can be adapted to Either_n[A_1, ..., A_n] for any value of n (i.e. 0, 1, 2, 3, 4, \u0026hellip;). With n = 0, which means a coproduct of zero types, there is no constructor, which means it is impossible to build a value of this type. Thus Either_0 is equivalent to False (i.e. Either_0 ≅ False). With n = 1, Either_n[A] ≅ A.\nFurther more for any types A, B and C we have the following properties\n Either2[A,B] is equivalent to Either2[B,A] Either2[Either2[A,B], C] and Either2[A, Either2[B,C]] and Either3[A,B,C] are all equivalent Eithr2[False,A] and Either2[A,False] and A are all equivalent Either_1[A] is equivalent to A (C, Either2[A,B]) is equivalent to Either2[(C,A), (C,B)]  Exercise: write conversion functions from and tofor each of these equivalence, such that from and to are inverse functions.\nRemember that in Type Theory, False is written 0, Unit is written 1, the product (A_1, ..., A_n) is written A_1 × ... A_n and the coproduct Either_n[A_1, ..., A_n] is written A_1 + ... + A_n. If we express the above properties using Type Theory notation, we get\n A + B ≅ B + A (A + B) + C ≅ A + (B + C) ≅ A + B + C 0 + A ≅ A + 0 ≅ A C × (A + B) ≅ (C × A) + (C × B) 1 × A ≅ A 0 × A ≅ A × 0 ≅ 0  Is arithmetic familiar to you? If so such equations should be familiar too. But these times there are not between numbers but between equivalent types. If you ever wonder why Algebraic Data Types are called this way, this should give you some hints.\nNext Episode: Recursive Data Types In the next episode, we will see Recursive Data Types.\n"
},
{
	"uri": "https://chrilves.github.io/types/3-products/",
	"title": "Episode 3 - Products",
	"tags": [],
	"description": "",
	"content": " Products, often called tuples, records or case classes, are a convenient way to bundle values of different types into a single value. The product of n types (with n being 0, 1, 2, etc) A_1, A_2, \u0026hellip;, A_n is precisely the type whose values are formed with exactly one value of each type A_i for 1 ≤ i ≤ n. It is written (A_1, A_2, ..., A_n) in many languages, Product_n[A_1, A_2, ..., A_n] in Scala and A_1 × ... × A_n in Type Theory. As an example, the product of two types A and B would be defined as\nfinal case class Product2[A, B](a: A, b: B) { def fold[R](f: (A, B) =\u0026gt; R): R = f(a,b) }data Product2 a b = Constructor a b Although in practice this is the preferred way to define the product of two types A and B, we will in this presentation prefer the equivalent definition below:\nsealed abstract class Product2[A,B] { def fold[C](f: (A, B) =\u0026gt; C): C = this match { case Constructor(a,b) =\u0026gt; f(a,b) } } final case class Constructor[A,B](a: A, b: B) extends Product2[A,B]data Product2 a b where Constructor :: a -\u0026gt; b -\u0026gt; Product2 a b This equivalent definition makes clear the distinction between the type Product2[A,B] and the constructor Constructor[A,B]. the constructor is a function taking as argument one value of type A, another value of type B and returning a value of type Product2[A,B]. Its type in Haskell is A -\u0026gt; B -\u0026gt; Product2 A B and in Scala (A, B) =\u0026gt; Product2[A,B]. Note than in Scala functions of type (A, B) =\u0026gt; C are functions of two arguments (precisely Function2[A,B,C]) and not of one argument (A,B) (which would be Function1[(A,B), C]):\nscala\u0026gt; Constructor[Int, String] _ : ( (Int, String) =\u0026gt; Product2[Int, String] ) res0: (Int, String) =\u0026gt; Product2[Int,String] = $$Lambda$1620/2032136633@55be2608Prelude\u0026gt; :t Constructor Constructor :: a -\u0026gt; b -\u0026gt; Product2 a b Besides, by definition constructors are injective functions, which means that for any values a1:A, a2:A, b1:B and b2:B, Constructor[A,B](a1,b1) == Constructor[A,B](a2,b2) if and only if a1 == a2 and b1 == b2 $$\\forall a1,\\ a2:\\texttt{A},\\ b1,\\ b2:\\texttt{B},\\quad \\texttt{Constructor[A,B]}(a1,b1) = \\texttt{Constructor[A,B]}(a2,b2) \\Longleftrightarrow a1 = a2 \\textbf{ and } b1 = b2$$\nBesides, Constructor[A,B] being the only constructor of Product2[A,B] then for any value v of type Product2[A,B], there is a unique value a of type A and a unique value b of type B such that v = Constructor[A,B](a,b) $$\\forall v:\\texttt{Product2[A,B]}\\ \\exists!\\ (a:\\texttt{A} \\textrm{ and } b:\\texttt{B}),\\quad v = \\texttt{Constructor[A,B]}(a,b)$$\nEquivalence of inductive and functional forms Once again any product can be equivalently expressed as a data type Product_n_Ind[A_1, ..., A_n] and as a function type Product_n_Fun[A_1, ..., A_n] with inverse functions ind2fun and fun2ind converting back and forth types Product_n_Ind[A_1, ..., A_n] and Product_n_Fun[A_1, ..., A_n]. For example with n = 2:\nsealed abstract class Product2Ind[A,B] final case class ConstructorInd[A,B](a: A, b: B) extends Product2Ind[A,B] trait Product2Fun[A,B] { def fold[C](f: (A, B) =\u0026gt; C): C } def constructorFun[A,B](a: A, b: B): Product2Fun[A,B] = new Product2Fun[A,B] { def fold[C](f: (A, B) =\u0026gt; C): C = f(a, b) } def ind2fun[A,B]: Product2Ind[A,B] =\u0026gt; Product2Fun[A,B] = (i: Product2Ind[A,B]) =\u0026gt; i match { case ConstructorInd(a,b) =\u0026gt; constructorFun(a,b) } def fun2ind[A,B]: Product2Fun[A,B] =\u0026gt; Product2Ind[A,B] = (f: Product2Fun[A,B]) =\u0026gt; f.fold[Product2Ind[A,B]](ConstructorInd[A,B] _)data Product2Ind a b where ConstructorInd :: a -\u0026gt; b -\u0026gt; Product2Ind a b type Product2Fun a b = forall c. (a -\u0026gt; b -\u0026gt; c) -\u0026gt; c constructorFun :: a -\u0026gt; b -\u0026gt; Product2Fun a b constructorFun a b f = f a b ind2fun :: Product2Ind a b -\u0026gt; Product2Fun a b ind2fun (ConstructorInd a b) = constructorFun a b fun2ind :: Product2Fun a b -\u0026gt; Product2Ind a b fun2ind f = f ConstructorInd Generalization to a product of any number of types The definition of Product2 above can be adapted to Product_n[A_1, ..., A_n] for any value of n (i.e. 0, 1, 2, 3, 4, \u0026hellip;). With n = 0, which means a product of zero types, the constructor takes zero argument, which means it is a constant. Thus Product_0 is equivalent to Unit (i.e. Product_0 ≅ Unit). This is the reason why Unit is sometimes written (). With n = 1, Product_n[A] ≅ A.\nFurther more for any types A, B and C we have the following properties\n (A , B) is equivalent to (B , A) ((A, B), C) and (A, (B, C)) and (A, B, C) are all equivalent (Unit, A) and (A, Unit) and A are all equivalent (A) is equivalent to A (False, A) and (A, False) and False are all equivalent  Exercise: write conversion functions from and tofor each of these equivalence, such that from and to are inverse functions.\nNext Episode: CoProducts In the next episode, we will a convenient way to express alternatives: CoProducts.\n"
},
{
	"uri": "https://chrilves.github.io/types/2-enums/",
	"title": "Episode 2 - Enumerations",
	"tags": [],
	"description": "",
	"content": " Now that we know what types are and why there are useful, it is about time to meet some remarkable ones. But before we start, there is some important things to state. As a developer i know how tempting it is to search ready-to-paste answers. But the subject of these post series is nothing like a ready-to-paste answers cookbook. On the contrary, this is a presentation of deep, difficult but rewarding concepts. Do not see them as patterns to follow blindly, like it is unfortunately too often the case in our field. Instead, take the time to develop a deep understanding of what is really going on.\nAs such, the example i give may look simple. They are indeed much simpler than in real-life applications. They are not meant to be applicable as-is but to shed light on the core ideas. If you understand the principles they rely on, you\u0026rsquo;ll be able to apply these powerful concepts in your day to day code. Do not skim through this but take the time to develop your understanding.\nIn this whole series is we will assume null (in Scala), undefined (in Haskell) and side-effects do not exist. null, undefined and side-effects are absurd in every possible way. They make interesting properties collapse and should be avoided at all costs! We will consider all functions from A to B to be mathematical functions:\n they always return a valid value of type B of any input input value of type A on the same argument (or an equal argument), they always return the same result (or an equal result) the only effect of executing them is obtaining a result, no side-effect allowed If b:B = f(a:A) we can always replace b by f(a) and vice-versa, anywhere in the program, without altering its behavior (apart from computation time and memory consumption)  Formally it means we will consider all functions referentially transparent and total. That being said, let the journey begin with a very useful concept.\nMany equivalent ways to express it There is often many ways to express the same idea. How would you represent a piece of text? The types List[Char] and String are two different ways to do so. These types are indeed not equal: they are not encoded the same way and have distinct performance properties. But despite their differences, they can be considered equivalent. There is indeed a one-to-one correspondence between them: we can define two functions list2string: List[Char] =\u0026gt; String and string2list: String =\u0026gt; List[Char]:\ndef list2string: List[Char] =\u0026gt; String = (l:List[Char]) =\u0026gt; l.foldLeft(\u0026#34;\u0026#34;) { case (str,char) =\u0026gt; s\u0026#34;$str$char\u0026#34; } def string2list: String =\u0026gt; List[Char] = (str: String) =\u0026gt; str.toList such that list2string and string2list are the inverse of each other $$\\forall s:\\texttt{String},\\quad \\texttt{string2list}(\\texttt{list2string}(s)) = s$$ $$\\forall l:\\texttt{List[Char]},\\quad \\texttt{list2string}(\\texttt{string2list}(l)) = l$$\nwhich also means\n for any list there is a unique string $$\\forall l:\\texttt{List[Char]}\\ \\exists! s:\\texttt{String} ,\\quad \\texttt{string2list}(s) = l$$\n for any string there is a unique list $$\\forall s:\\texttt{String}\\ \\exists! l:\\texttt{List[Char]},\\quad \\texttt{string2list}(\\texttt{list2string}(s)) = s$$\n list2string and string2list are injective $$\\forall l1, l2:\\texttt{List[Char]},\\ \\texttt{list2string}(l1) = \\texttt{list2string}(l2) \\implies l1 = l2$$ $$\\forall s1, s2:\\texttt{String},\\ \\texttt{string2list}(s1) = \\texttt{string2list}(s2) \\implies s1 = s2$$\n  Basically it means we can always convert from one type to the other without loss of generality.\n For any function f: A =\u0026gt; B (i.e. from A to B), f is called a bjection if and only if there exists a function g: B =\u0026gt; A (i.e. from B to A) such that f and g are inverse of each other: $$\\forall a:\\texttt{A},\\quad \\texttt{g}(\\texttt{f}(a)) = a$$ $$\\forall b:\\texttt{B},\\quad \\texttt{f}(\\texttt{g}(b)) = b$$ Two types A and B are called equivalent, which is written A ≅ B, if and only if there exists a bijection f: A =\u0026gt; B.\n This notion is fundamental as it tells us that similarity between types is how closely they behave, not how closely they look. Two types of apparent very different form may actually be equivalent while two whose form may seem close may be fundamentally at odds. Focus on properties, not on looks.\nThe empty type The first type i want to present has many names. Scala names it Nothing, Elm calls it Never, Coq uses the name it usually has in Proof Theory which is False while Type Theory refers to it as 0. This is an uninhabited type which means there is no value of this type. You may look at it as the empty set (hence the name 0):\nfinal abstract class False { def fold[A]: A } This class being final we cannot define sub-classes, but being also abstract we cannot instantiate it either! And even if we could, how would we write a function fold which meets the specification that it provides a value of type A for any A? Remember, null does not exists.\nHow a type without values can be useful? By representing impossible cases in the type-system. Let v be a value of type Either[False, Int]. v has to be Right(i) for some integer i because otherwise it would be Left(f) for some value f of type False which is impossible! It means the following pattern-matching is exhaustive.\ndef extractRight[A](v: Either[False,A]): A = v match { case Right(a) =\u0026gt; a } Unfortunately Scala protests it\u0026rsquo;s not, demanding we cover the case v = Left(f: False) by returning a value of type A. We know, assuming null does not exists, there can not be such a value f:False. How to make Scala happy? Fortunately, every hypothetical value of type False comes with a handy fold function able to return anything. It corresponds in logic to the principle of explosion stating that from a contradicton (having a value of an empty type for example), you can conclude anything:\ndef extractRight[A](v: Either[False,A]): A = v match { case Right(a) =\u0026gt; a case Left(f) =\u0026gt; f.fold[A] } Note that extractRight and Right:A =\u0026gt; Either[False, A] being inverse functions it means Either[False, A] is equivalent to A. This one is of the main properties of False: Either[False, A], Either[A, False] and A are all equivalent (i.e. Either[False, A] ≅ A ≅ Either[A, False]).\nYou could argue using Either[False, A] is pointless as it is equivalent to A which is true, but bare in mind it is just a toy example. A more realistic one would involve complex types such as bifunctors like IO[E,A]. The ability to express impossible cases let us write IO computations that never fails IO[False, A] and IO computation that never returns IO[E,False] with the same code and API instead of relying on code/API duplication which is a waste of time, effort and complexity.\nThe idea being False can be expressed in many equivalent ways. The three types False, FalseInd and FalseFun are equivalent (`False ≅ FalseInd ≅ FalseFun):\nfinal abstract class FalseInd trait FalseFun { def fold[A]: A } This is even clearer in Haskell as shown below where ind2fun and fun2ind are inverse functions.\n{-# LANGUAGE RankNTypes, EmptyCase #-} module Iso where data FalseInd type FalseFun = forall a. a ind2fun :: FalseInd -\u0026gt; FalseFun ind2fun x = case x of { } fun2ind :: FalseFun -\u0026gt; FalseInd fun2ind x = x In Scala like in Haskell FalseInd express the idea of a data type with no constructor (i.e. to way to build a value) while FalseFun is the type of a function with no argument (i.e. a constant) returning values of type A for any A, but such a function does not exists. It may seem weird having functions between empty types but it actually makes a lot of sense: there is indeed a one-to-one correspondence between these two types as both have no values at all.\nThe singleton type Often called unit, () or 1, it is the type with only one value.\nsealed abstract class Unit { def fold[A](x: A): A = this match { case Unique =\u0026gt; x } } final case object Unique extends Unit Note that the type Unit admits one and exactly one value which is UniqueInd. UniqueInd is called a constructor of the data type Unit as it one way (the only one actually) to build a value of type Unit. Unit is useful everywhere you have to fill a value and/or a type but you actually don\u0026rsquo;t care which. For example, let v = println(\u0026quot;Hello World\u0026quot;):IO[Unit] be the value printing a message to the screen. We don\u0026rsquo;t care what the execution v returns, we are only interested into what is printed, but it still needs to return something for the program to continue.\nOnce again Unit can be equivalently expressed as both the data type UnitInd and the function type UnitFun. Indeed ind2fun and fun2ind are inverse functions showing Unit ≅ UnitInd ≅ UnitFun.\nsealed abstract class UnitInd final case object UniqueInd extends UnitInd trait UnitFun { def fold[A](x: A): A } val uniqueFun: UnitFun = new UnitFun { def fold[A](x: A): A = x } def ind2fun: UnitInd =\u0026gt; UnitFun = (i: UnitInd) =\u0026gt; i match { case UniqueInd =\u0026gt; uniqueFun } def fun2ind: UnitFun =\u0026gt; UnitInd = (f: UnitFun) =\u0026gt; f.fold[UnitInd](UniqueInd)data UnitInd where UniqueInd :: UnitInd type UnitFun = forall a. a -\u0026gt; a uniqueFun :: UnitFun uniqueFun x = x ind2fun :: UnitInd -\u0026gt; UnitFun ind2fun UniqueInd = uniqueFun fun2ind :: UnitFun -\u0026gt; UnitInd fun2ind u = u UniqueInd The type UnitFun may surprise you. How is it possible that a function type like it has only one possible value? Try to write a referentially transparent and total instance of UnitFun. You will see there is only one way to do so.\nOne of the main properties of Unit is that (Unit, A), (A, Unit) and A are equivalent (i.e. (Unit, A) ≅ A ≅ (A, Unit)). Exercise: write the inverse functions between these types.\nThe two values type: Booleans Here comes one of the most well known type: the one with exactly two values often called Boolean in programming and 2 in Type Theory. Its values are generally named true and false:\nsealed abstract class Boolean { def fold[A](tt: A, ff: A): A = this match { case True =\u0026gt; tt case False =\u0026gt; ff } } final case object True extends Boolean final case object False extends Boolean I\u0026rsquo;m sure you\u0026rsquo;re already familiar with booleans, but did you recognize the fold function? It is generally named if-then-else:\ndef ifThenElse[A](b: Boolean)(tt: A, ff: A): A = b.fold[A](tt, ff) True and False are called the constructors of Boolean because they are the only way to build values of type Boolean. Once again this idea of a type with two values is equivalently expressed both as the data type BoolInd and as the function type BoolFun . Functions ind2fun and fun2ind are indeed inverse of each other.\nsealed abstract class BoolInd final case object TrueInd extends BoolInd final case object FalseInd extends BoolInd trait BoolFun { def fold[A](tt: A, ff: A): A } val trueFun: BoolFun = new BoolFun { def fold[A](tt: A, ff: A): A = tt } val falseFun: BoolFun = new BoolFun { def fold[A](tt: A, ff: A): A = ff } def ind2fun: BoolInd =\u0026gt; BoolFun = (i: BoolInd) =\u0026gt; i match { case TrueInd =\u0026gt; trueFun case FalseInd =\u0026gt; falseFun } def fun2ind: BoolFun =\u0026gt; BoolInd = (f: BoolFun) =\u0026gt; f.fold[BoolInd](TrueInd, FalseInd)data BoolInd where TrueInd :: BoolInd FalseInd :: BoolInd type BoolFun = forall a. a -\u0026gt; a -\u0026gt; a trueFun :: BoolFun trueFun tt _ = tt falseFun :: BoolFun falseFun _ ff = ff ind2fun :: BoolInd -\u0026gt; BoolFun ind2fun TrueInd = trueFun ind2fun FalseInd = falseFun fun2ind :: BoolFun -\u0026gt; BoolInd fun2ind u = u TrueInd FalseInd Once again the type BoolFun may surprise you. Once again try to write a referentially transparent and total instance of BoolFun. You will see there are only two ways to do so.\nI could continue forever presenting types with 3, 4, \u0026hellip; values but by now you must see the same pattern repeating and repeating again.\nNext Episode: Products In the next episode, we will a convenient way to combine types: Products.\n"
},
{
	"uri": "https://chrilves.github.io/types/1-why/",
	"title": "Episode 1 - Why Types?",
	"tags": [],
	"description": "",
	"content": " Why using types? When are they useful? Why we should care about types? What are types? These are the questions this series of posts give some answers to. Let\u0026rsquo;s start by realizing a fundamental fact: types are everywhere! Business models are all about types: users, shipments, orders, etc. Placing a user in the cart or shipping a client just makes no sense. Types are specification, discriminating what makes sense from what makes not.\nA real life example They can be simple like the well known strings, integers, booleans, lists, chars and floating-point numbers. But these six are far from covering the whole picture. Take as an example, a business application about finding the best deal amount a list of prices expressed in various currencies. To do so it would need currency conversion rates. Which data structure would you use to store these rates? One euro (EUR) worths when i write these lines 1.13 dollars (USD) which i could represent as the triple (\u0026quot;EUR\u0026quot;, 1.13 ,\u0026quot;USD\u0026quot;). To store many rates, using a list is straightforward:\nscala\u0026gt; val rates = List( (\u0026#34;EUR\u0026#34;, 1.13, \u0026#34;USD\u0026#34;), (\u0026#34;GBP\u0026#34;, 142.79, \u0026#34;JPY\u0026#34;) ) rates: List[(String, Double, String)] = List((EUR,1.13,USD), (GBP,142.79,JPY)) Are you sure the type (String, Double, String) is a faithful representation for rates? Among all the possible values of this type is (\u0026quot;EUR\u0026quot;, -3.0, \u0026quot;USD\u0026quot;) meaning when you give one euro, you have to pay three dollars more to get nothing. This is silly, currency trading don\u0026rsquo;t work that way. Another problematic value is (\u0026quot;EUR\u0026quot;, 0, \u0026quot;USD\u0026quot;). What is the point in exchanging one euro for nothing? Using Double to encode rates is wrong as not all floating point number makes a valid rate, only those strictly positive! A faithful representation of rates is the type r:Double{r \u0026gt; 0} which is the types of value r:Double such that r \u0026gt; 0. Such types are called refinement types and used heavily in F*.\nWe\u0026rsquo;re not done yet! Are you sure String is faithful representation of currencies? The empty string \u0026quot;\u0026quot; is not a currency, neither are \u0026quot;⛱\u0026quot;, \u0026quot;⛏\u0026quot;, etc but they are all valid strings. Assuming currencies:Set[String] is the set of all valid currency names, the type of currencies would be cur:String{currencies.contains(cur)} if it was expressible in Scala. But it is in F*:\nopen FStar.Set val currencies: set string let currencies = Set.as_set [\u0026#34;EUR\u0026#34;; \u0026#34;USD\u0026#34;; \u0026#34;JPY\u0026#34;] type currency = cur:string{Set.mem cur currencies} For the rest of this section, we will assume Scala has refinement types so that we can write:\ntype Rate = r:Double{r \u0026gt; 0} val currencies: Set[String] = Set(\u0026#34;EUR\u0026#34;, \u0026#34;USD\u0026#34;, \u0026#34;JPY\u0026#34;) type Currency = cur:String{currencies.contains(cur)} We\u0026rsquo;re still not done yet as the type (Currency, Rate, Currency) still does not faithfully encode a conversion rate: (\u0026quot;EUR\u0026quot;, 2.0, \u0026quot;EUR\u0026quot;) is a value of this type but one euro can not worth two euros, this would not make sense! We could define the type Rate such that the only possible value is 1.0 when there is the same currency on both sides, but for simplicity\u0026rsquo;s sake and without loss of generality, we will just forbid converting into the same currency. Once again, in a version of Scala with refinement and dependent types, conversion rates would be:\nfinal case class ConvRate( from: Currency, rate: Rate, to:Currency{from != to} ) We\u0026rsquo;re almost there! Now every value of ConvRate makes sense from a business perspective: currencies from and to are valid distinct currencies and rate is a strictly positive exchange rate. Does the type List[ConvRate] faithfully represents a valid set of conversion rates? Values like List(ConvRate(\u0026quot;EUR\u0026quot;, 2.0, \u0026quot;USD\u0026quot;), ConvRate(\u0026quot;EUR\u0026quot;, 1.13, \u0026quot;USB\u0026quot;)), where there are several distinct rates for the same conversion, do not make sense. Likewise, there is a relation between a conversion rate and its opposite direction. If one euros worth 1.13 dollars, then one dollar worths 0.88 euros. Values like List(ConvRate(\u0026quot;EUR\u0026quot;, 1.13, \u0026quot;USD\u0026quot;), ConvRate(\u0026quot;USD\u0026quot;, 2.0, \u0026quot;EUR\u0026quot;)) do not respect this rule, so are invalid business values. To be sure values do respect these business rules we can use the data structure Map and only allow one side of the conversion (from \u0026lt; to) in the type ConversionRates:\nval currencies: Set[String] = Set(\u0026#34;EUR\u0026#34;, \u0026#34;USD\u0026#34;, \u0026#34;JPY\u0026#34;) final case class Conversion( from: String{currencies.contains(from)}, to: String{currencies.contains(to) \u0026amp;\u0026amp; from \u0026lt; to } ) type ConversionRates = Map[Conversion, rate:Double{rate \u0026gt; 0}] The type ConversionRates is certainly more complex than List[(String, Double, String)] but we gained several major benefits:\n every piece of code taking ConversionRates values as input is sure they respect business rules. every piece of code outputting ConversionRates values is guaranteed to respect business rules. division by zero is impossible!  no need to check! no risk of exceptions! no need to write tests! no need to test the tests!   Conclusion You may think you are such an excellent developer than all of this is useless because you would never define a negative rate or an empty string currency. But how could you be sure that the previous developers on the project were as perfect as you? Have you written the thousands of tests required to reach the same level of confidence types provide? Will you be happy refactoring those thousands of test every time the specification change? Are you sure you know perfectly every one of the millions ones of the project? Even the one you never had to work with?\nIf we were as good as we think we are, there would not be null pointer exceptions, segfaults, exploits, undefined-is-not-a-function, java.util.NoSuchElementException: None.get and all the other so common bugs and vulnerabilities we see far too often! Software are complex beasts, made usually by many people, some who leave, some who join. Relying of people being perfect (perfect knowledge, perfect understanding, perfect execution) is not realistic.\nYou can see type systems as powerful linters whose job is to check your code. Types get more and more complex as business rules do from simple properties to heavy mathematical theorems.\nTypes are specification, so in an ideal world a program well-typed would be, by definition, a program without bugs. If you still find bugs in your application, it either means you need to tighten your types to fit the specification or your language\u0026rsquo;s type-system is not expressive enough to encode the specification.\nNext Episode In the next episode, we will see enumerations like you probably have never seen them before.\n"
},
{
	"uri": "https://chrilves.github.io/types/",
	"title": "Introduction to Types",
	"tags": [],
	"description": "",
	"content": "Why using types? When are they useful? Why we should care about types? What are types? These are the questions [this series of posts]/types/ give some answers to.\n"
},
{
	"uri": "https://chrilves.github.io/posts/folds/",
	"title": "Let&#39;s meet the charming fold family",
	"tags": [],
	"description": "Introduction to catamorphisms on Algebraic Data Types",
	"content": " Today we will meet an amazing family: the fold functions!\nThe well known foldRight Lists is one of the first data structure every developer/computer scientist meet in her/his journey into programming:\nsealed abstract class List[+A] final case object Nil extends List[Nothing] final case class Cons[+A](head: A, tail: List[A]) extends List[A] It means means values of type List[A] can be of (only) two forms:\n either Nil or Cons(head, tail) for some values head of type A and tail of type List[A]  For example we can define the following lists:\nval empty : List[Int] = Nil val l1 : List[Int] = Cons(61, Nil) val l2 : List[Int] = Cons(34, Cons(61, Nil)) val l3 : List[String] = Cons(\u0026#34;a\u0026#34;, Cons(\u0026#34;b\u0026#34;, Cons(\u0026#34;c\u0026#34;, Nil))) In addition, Nil and Cons can be seen as constants and functions returning List[A]:\ndef nil[A]: List[A] = Nil def cons[A](head: A, tail: List[A]): Lis[A] = Cons(head, tail) The fold function, often called foldRight, answers the question:\n What would have happened if, instead of having used Nil and Cons in the construction of a list l:List[A], we would have used another constant z:T and another function f:(A, T) =\u0026gt; T for some type T?\n Let\u0026rsquo;s illustrate this using the previous examples:\nval empty : Int = 0 // z = 0 val v1 : Int = max(61, 0) // z = 0, f = max val v2 : Int = mult(34, mult(61, 1)) // z = 1, f = mult val v3 : String = concat(\u0026#34;a\u0026#34;, concat(\u0026#34;b\u0026#34;, concat(\u0026#34;c\u0026#34;, \u0026#34;\u0026#34;))) -- z = \u0026#34;\u0026#34;, f = concat The definition of foldRight illustrates well the transformation process. It deconstructs the list l:List[A] and replace Nil by z and Cons by f:\ndef foldList[A,T](z: T, f: (A,T) =\u0026gt; T): List[A] =\u0026gt; T = { def transform(l: List[A]): T = l match { case Nil =\u0026gt; z case Cons(head, tail) =\u0026gt; val transformedTail = transform(tail) f(head, transformedTail) } transform _ } The simple cases: Enum Types fold functions can be defined for a wide range of data structures. As a first example, let\u0026rsquo;s take this type:\nsealed abstract class SingletonType final case object SingleValue extends SingletonType The type SingletonType admits one and only one value: SingleValue. Folding over SingletonType means, replacing SingleValue by a constant z:T for some type T :\ndef foldSingletonType[T](z:T): SingletonType =\u0026gt; T = { def transform(v: SingletonType): T = v match { case SingleValue =\u0026gt; z } transform _ } While SingletonType has only one value, the type Boolean have exactly two values True and False:\nsealed abstract class Boolean final case object True extends Boolean final case object False extends Boolean So folding over Booleans mean, given a type T and two constants tt:T and ff:T, replacing True by tt and False by ff:\ndef foldBoolean[T](tt:T, ff:T): Boolean =\u0026gt; T = { def transform(v: Boolean): T = v match { case True =\u0026gt; tt case False =\u0026gt; ff } transform _ } And so on for every enum type.\nBeyond enums You may start the see general process. If values of type C are build using constructors (Nil and Cons[A] for List[A], SingleValue for SingletonType, True and False for Boolean), then folding is all about transforming values of type C into another type T by replacing each constructor of C by a constant or function on T of the same shape. Let\u0026rsquo;s consider the type Either[A,B]:\nsealed abstract class Either[A,B] final case class Left[A,B](value: A) extends Either[A,B] final case class Right[A,B](value: B) extends Either[A,B] To transform values of type Either[A,B] into T we need two functions on T:\n Left being of type A =\u0026gt; Either[A,B] we need a function f: A =\u0026gt; T. Right being of type B =\u0026gt; Either[A,B] we need a function g: B =\u0026gt; T.  Then we can operate the transformation:\ndef foldEither[A,B,T](f: A =\u0026gt; T, g: B =\u0026gt; T): Either[A,B] =\u0026gt; T = { def transform(v: Either[A,B]): T = v match { case Left(a) =\u0026gt; f(a) case Right(b) =\u0026gt; g(b) } transform _ } Recursive Types Folding over recursive types obey the previous rules. Recursion is handled by transforming sub-terms first. Let\u0026rsquo;s consider the type of binary trees:\nsealed abstract class Tree[+A] final case object Empty extends Tree[Nothing] final case class Node[+A](value:A, left: Tree[A], right: Tree[A]) extends Tree[A] To transform values of type Tree[A] into T we need:\n Empty being a constant of type Tree[A], we need a constant z:T. Node being a function of type (A, Tree[A], Tree[A]) =\u0026gt; Tree[A] we need a function f: (A, T, T) =\u0026gt; T. Note how all occurrences of Tree[A] have been replaced by T in the type.  Then we can operate the transformation:\ndef foldTree[A,T](z: T, f: (A, T, T) =\u0026gt; T): Tree[A] =\u0026gt; T = { def transform(v: Tree[A]): T = v match { case Empty =\u0026gt; z case Node(a,l,r) =\u0026gt; val g: T = transform(l) // Transforming sub-term l  val d: T = transform(r) // Transforming sub-term r  f(a,g,d) } transform _ } Generalized Algebraic Data Types (GADT) Instead of giving a formal definition of what Generalized Algebraic Data Types i will show you some examples.\nType Equalities Consider the type:\nsealed abstract class EmptyOrSingleton[A] final case object SingleValueIfAisInt extends EmptyOrSingleton[Int] This type looks very similar to SingletonType but, while SingleValue was always a value of SingletonType, SingleValueIfAisInt is only a value of EmptyOrSingleton[Int], i.e. when A is Int. So what happens to EmptyOrSingleton[A] when A is not Int? Then there is no constructor for EmptyOrSingleton[A] so no value for SingletonIfInt[A] (excluding null which we will pretend no to exist).\nGADTs are very useful to encode predicates over types. Imagine you have a value v:EmptyOrSingleton[A] for some type A (remember we pretend null does not exist). What could you say about A? The only way to get a value of type EmptyOrSingleton[A] is through SingleValueIfAisInt. Thus v is SingleValueIfAisInt which is of type EmptyOrSingleton[Int] so is v. We can conclude that A is actually Int. Not convinced? Let A be String, can you build a value of type EmptyOrSingleton[String] without using null? Try it.\nTo find how to fold EmptyOrSingleton[A] into T, let\u0026rsquo;s apply the technique we used in the previous sections. EmptyOrSingleton[A] has only one constructor, SingleValueIfAisInt, so we need a constant z:T. But SingleValueIfAisInt is not of type EmptyOrSingleton[A] but EmptyOrSingleton[Int]. The argument A matters so let T depend on A: we want to transform values of type EmptyOrSingleton[A] into T[A].\n SingleValueIfAisInt being of type EmptyOrSingleton[Int] we need a constant z:T[Int]  Then we can operate the transformation:\ndef foldEmptyOrSingleton[A, T[_]](z: T[Int]): EmptyOrSingleton[A] =\u0026gt; T[A] = { def transform(v: EmptyOrSingleton[A]): T[A] = v match { case SingleValueIfAisInt =\u0026gt; z // Because we know A = Int  } transform _ } foldEmptyOrSingleton means that, for some T[_], if you have a value z:T[Int] then you can transform any value EmptyOrSingleton[A] into T[A]. For example, let\u0026rsquo;s take\ntype T[X] = X =:= Int val z:T[Int] = implicitly[Int =:= Int] Then foldEmptyOrSingleton[A,T](z) gives us, for any value v:EmptyOrSingleton[A] a proof that A =:= Int. Another important use case is asserting type equality:\nsealed abstract class Eq[A,B] final case class Refl[X]() extends Eq[X,X] Any non-null value v:Eq[A,B] must be a Refl[X]() : Eq[X,X] for some X, then Eq[A,B] = Eq[X,X] proving that A = X = B. To transform a value of type Eq[A,B] into T[A,B] we need:\n Refl[X]() is essentially a constant of type Eq[X,X] for all type X (note: Scala write this type [X]Eq[X,X]). We need a constant z:T[X,X] for all type X (so the type [X]T[X,X]). Scala does not support transparent higher-ranked types, we need to emulate them with a trait:\ntrait ElimRefl[T[_,_]] { def apply[X]: T[X,X] }  Then we could have hoped to be able to operate the transformation like previous section. But given a value v:Eq[A,B], convincing Scala that A = B is a bit tough. Instead we can write the fold as a method:\nsealed abstract class Eq[A,B] { def fold[T[_,_]](z: ElimRefl[T]): T[A,B] } final case class Refl[X]() extends Eq[X,X] { def fold[T[_,_]](z: ElimRefl[T]): T[X,X] = z[X] } def foldEq[A, B, T[_,_]](z: ElimRefl[T]): Eq[A,B] =\u0026gt; T[A,B] = (v:Eq[A,B]) =\u0026gt; v.fold[T](z) Ingenious definition of T[_,_] leads to interesting results:\ntrait C[X] type T1[A,B] = C[A] =:= C[B] val z1: ElimRefl[T1] = new ElimRefl[T1] { def apply[X]: T1[X,X] = implicitly[C[X] =:= C[X]] } def transform[A,B]: Eq[A,B] =\u0026gt; C[A] =:= C[B] = foldEq[A,B,T1](z1) Existential Quantification GADTs not only provide useful type equalities, they also offer existential quantification!\nsealed abstract class Ex[F[_]] { type hidden val value: hidden val evidence: F[hidden] } final case class MakeEx[F[_],A](value: A, evidence: F[A]) extends Ex[F] { type hidden = A } Any value v:Ex[F] has to be an instance of MakeEx[F,A] for some type A. Which means we have a value, v.value, of type A and an instance of the type-class F for A (for example an instance of Monoid[A] with F[X] = Monoid[X]).\nTo transform values of type Ex[F] into T we need:\n MakeEx[F[_],?] being of type [A](A, F[A]) =\u0026gt; Ex[F] meaning: For_all_type A, (A, F[A]) =\u0026gt; Ex[F], we need a function f of type [A](A, F[A]) =\u0026gt; T. Scala still does not support transparent higher ranked types, we need to emulate them with another trait:\ntrait ElimMakeEx[F[_],T] { def apply[A](value: A, evidence: F[A]): T }  Then we can operate the transformation:\ndef foldEx[F[_], T](f: ElimMakeEx[F, T]): Ex[F] =\u0026gt; T = { def transform(v: Ex[F]): T = v match { case w@MakeEx(value, evidence) =\u0026gt; f[w.hidden](value, evidence) } transform _ } Duality In this post we have deduced the fold functions from the definition of each type. It is possible to do the opposite: each constructor can be derived from the fold function of its type. For example:\ntrait List[+A] { def fold[T](z:T, f: (A,T) =\u0026gt; T): T } def nil[A]: List[A] = new List[A] { def fold[T](z:T, f: (A,T) =\u0026gt; T): T = z } def cons[A](head:A, tail: List[A]): List[A] = new List[A] { def fold[T](z:T, f: (A,T) =\u0026gt; T): T = f(head, tail.fold(z,f)) } def equality[A](l1: List[A], l2:List[A]): Boolean = ??? // Difficult but worthy exercice Conclusion I hope i convinced you folds are immensely useful. First, they let us write simply complex transform functions. But this not the most interesting property. It is sometimes easier to define a type by its fold function. Java, for example, does not have support for neither sealed classes nor pattern-matching. How could we define the List type so that Nil and Cons are the two only cases? The fold function forces any instance of List to fit into the desired shape (if some rules are obeyed like no null and no runtime-reflection). It can also happen that type-inference is not smart enough, fold function provide an alternative way which is often easier for the Scala type-checker.\n"
},
{
	"uri": "https://chrilves.github.io/posts/slimetrail/",
	"title": "How to make game in the browser thanks to ScalaJS",
	"tags": [],
	"description": "ScalaIO.2018 Workshop",
	"content": " A few month ago, the Paris Scala User Group kindly invited me present a workshop introducing [Scala.js(https://www.scala-js.org/). Even better, i had the chance to present it at ScalaIO 2018. The workshop materials are here.\nI will present how to develop a web application in Scala.js. This talk is for Scala developers having a penchant for web development but rebuffed by JavaScript. It goes from ScalaJS basics to the implementation of a naive virtual DOM written in Scala. It presents:\n how to setup Sbt for cross compilation what is the DOM and how to manipulate it events and their propagation the Model/View/Update architecture (a.k.a the ELM architecture)  The final result can be experimented with at slimetrail. The english material for the ScalaIO workshop are not yet available but the ones for the PSUG workshop, in french are here.\nThe Application  "
},
{
	"uri": "https://chrilves.github.io/posts/json2xml/",
	"title": "JSON to XML: the probably a tiny bit over engineered way",
	"tags": [],
	"description": "Conversion from/to JSON and XML using advanced concepts",
	"content": " The complete code of the article. You need Cats and Play-Json in order to run it.\nThe Slides are here\nIt happens regularly in software development that we have to connect systems speaking different languages. JSON is nowadays ubiquitous in service communication, especially in web development but XML still has its fair amount of bastions. Imagine you need to pass information provided by a JSON API through an XML layer, you need a converter.\nThe easy way This translation is actually pretty trivial, it takes essentially 6 lines of simple pattern-matching code in Scala:\nimport play.api.libs.json._ import scala.xml._ def json2xml(json: JsValue, rootLabel: String): Elem = { // XML node creation helper  def mkElem(jsType: String, children: Node*): Elem = Elem(null, rootLabel, new UnprefixedAttribute(\u0026#34;type\u0026#34;, jsType, scala.xml.Null), TopScope, true, children: _* ) // The real translation  json match { case JsNull =\u0026gt; mkElem(\u0026#34;null\u0026#34;) case JsString(s) =\u0026gt; mkElem(\u0026#34;string\u0026#34;, PCData(s)) case JsNumber(n) =\u0026gt; mkElem(\u0026#34;number\u0026#34;, Text(n.toString)) case JsBoolean(b) =\u0026gt; mkElem(\u0026#34;boolean\u0026#34;, Text(b.toString)) case JsArray(l) =\u0026gt; mkElem(\u0026#34;array\u0026#34;, l.map(json2xml(_, s\u0026#34;${rootLabel}Item\u0026#34;)):_*) case JsObject(m) =\u0026gt; mkElem(\u0026#34;object\u0026#34;, m.toList.map { case (k,v) =\u0026gt; json2xml(v, k) }: _*) } } The trickiest part of this example is figuring out how to build XML nodes in Scala. It translates the following JSON:\n[ { \u0026#34;title\u0026#34;: \u0026#34;2001 : A Space Odyssey\u0026#34;, \u0026#34;release\u0026#34;: { \u0026#34;day\u0026#34;: 27, \u0026#34;month\u0026#34;: 9, \u0026#34;year\u0026#34;: 1968 }, \u0026#34;genres\u0026#34; : [ \u0026#34;Science fiction\u0026#34; ], \u0026#34;actors\u0026#34;: [ { \u0026#34;lastName\u0026#34;: \u0026#34;Dullea\u0026#34;, \u0026#34;firstName\u0026#34;: \u0026#34;Keir\u0026#34;, \u0026#34;role\u0026#34;: \u0026#34;Dr. David Bowman\u0026#34; } ], \u0026#34;directors\u0026#34;: [ { \u0026#34;lastName\u0026#34;: \u0026#34;Kubrick\u0026#34;, \u0026#34;firstName\u0026#34;: \u0026#34;Stanley\u0026#34; } ] } ] into\n\u0026lt;films type=\u0026#34;array\u0026#34;\u0026gt; \u0026lt;filmsItem type=\u0026#34;object\u0026#34;\u0026gt; \u0026lt;title type=\u0026#34;string\u0026#34;\u0026gt;\u0026lt;![CDATA[2001 : A Space Odyssey]]\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;release type=\u0026#34;object\u0026#34;\u0026gt; \u0026lt;day type=\u0026#34;number\u0026#34;\u0026gt;27\u0026lt;/day\u0026gt; \u0026lt;month type=\u0026#34;number\u0026#34;\u0026gt;9\u0026lt;/month\u0026gt; \u0026lt;year type=\u0026#34;number\u0026#34;\u0026gt;1968\u0026lt;/year\u0026gt; \u0026lt;/release\u0026gt; \u0026lt;genres type=\u0026#34;array\u0026#34;\u0026gt; \u0026lt;genresItem type=\u0026#34;string\u0026#34;\u0026gt;\u0026lt;![CDATA[Science fiction]]\u0026gt;\u0026lt;/genresItem\u0026gt; \u0026lt;/genres\u0026gt; \u0026lt;actors type=\u0026#34;array\u0026#34;\u0026gt; \u0026lt;actorsItem type=\u0026#34;object\u0026#34;\u0026gt; \u0026lt;lastName type=\u0026#34;string\u0026#34;\u0026gt;\u0026lt;![CDATA[Dullea]]\u0026gt;\u0026lt;/lastName\u0026gt; \u0026lt;firstName type=\u0026#34;string\u0026#34;\u0026gt;\u0026lt;![CDATA[Keir]]\u0026gt;\u0026lt;/firstName\u0026gt; \u0026lt;role type=\u0026#34;string\u0026#34;\u0026gt;\u0026lt;![CDATA[Dr. David Bowman]]\u0026gt;\u0026lt;/role\u0026gt; \u0026lt;/actorsItem\u0026gt; \u0026lt;/actors\u0026gt; \u0026lt;directors type=\u0026#34;array\u0026#34;\u0026gt; \u0026lt;directorsItem type=\u0026#34;object\u0026#34;\u0026gt; \u0026lt;lastName type=\u0026#34;string\u0026#34;\u0026gt;\u0026lt;![CDATA[Kubrick]]\u0026gt;\u0026lt;/lastName\u0026gt; \u0026lt;firstName type=\u0026#34;string\u0026#34;\u0026gt;\u0026lt;![CDATA[Stanley]]\u0026gt;\u0026lt;/firstName\u0026gt; \u0026lt;/directorsItem\u0026gt; \u0026lt;/directors\u0026gt; \u0026lt;/filmsItem\u0026gt; \u0026lt;/films\u0026gt; Note that, unlike JSON, XML have no notion of booleans, number or null, so we add type information as attribute on each node. This has the benefit of enabling us to convert such XML back to their former JSON form. Also note that, we need CDATA sections to preserve spaces.\nProblem solved? Yes! But we can go much much further on this subject\u0026hellip;\nThe Rocket Science way There much more thing to say about this example, first let\u0026rsquo;s expose some properties of JSON values.\nInviting (Co)Algebras to the Party JSON values can be modelled with an Algebraic Data Type or ADT for short. Play-Json represents them by the type JsValue:\nsealed abstract class JsValue final case object JsNull extends JsValue final case class JsNumber(value: BigDecimal) extends JsValue final case class JsBoolean(value: Boolean) extends JsValue final case class JsString(value: String) extends JsValue final case class JsArray(value: List[JsValue]) extends JsValue final case class JsObject(value: Map[String, JsValue]) extends JsValue But in order to simplify the presentation, we will use slightly different, but equivalent, definition of JSON values:\nsealed abstract class Atomic final case object Null extends Atomic final case class Bool(value: Boolean) extends Atomic final case class Number(value: BigDecimal) extends Atomic final case class Str(value: String) extends Atomic sealed abstract class JsValue final case class JsAtom(value: Atomic) extends JsValue final case class JsArray(value: List[JsValue]) extends JsValue final case class JsObject(value: Map[String, JsValue]) extends JsValue Like in any Algebraic Data Type, the constructors of JsValues can be seen as operations on it. JsAtom informs us that every number, boolean, string and null give rise to a distinct JSON value. JsArray and JsObject tells us that each (qualified) list of JSON values forms a distinct JSON value itself. Considering that JSON values are defined in terms of these operations, and that we want to translate JSON into XML, it would make sense to define them on XML as well. First, let\u0026rsquo;s explicit these operations:\nsealed abstract class JsLike[+R] final case class Atom(value: Atomic) extends JsLike[Nothing] final case class Arr[+R](value: List[R]) extends JsLike[R] final case class Obj[+R](value: Map[String, R]) extends JsLike[R] The interesting point here is we can translate back and forth between JsValue and JsLike[JsValue]. These translations are even the inverse of each other, meaning both types are totally equivalent!\nval jsLike2JsValue: JsLike[JsValue] =\u0026gt; JsValue = { case Atom(a) =\u0026gt; JsAtom(a) case Arr(a) =\u0026gt; JsArray(a) case Obj(m) =\u0026gt; JsObject(m) } val jsValue2JsLike: JsValue =\u0026gt; JsLike[JsValue] = { case JsAtom(a) =\u0026gt; Atom(a) case JsArray(a) =\u0026gt; Arr(a.toList) case JsObject(m) =\u0026gt; Obj(m) } jsLike2JsValue is called a JsLike-Algebra because it has the form JsLike[X] =\u0026gt; X. It means jsLike2JsValue is a way \u0026ldquo;compute\u0026rdquo; JsLike operation, i.e. it composes values to form new ones. On the opposite, jsValue2JsLike is called a JsLike-CoAlgebra because it has the form X =\u0026gt; JsLike[X]. It is a way to expose how a value is built, i.e. it deconstructs values to expose their structure.\nCan we find such functions for XML values? We are looking for two functions:\nval jsLike2Elem: JsLike[Elem] =\u0026gt; Elem = ??? val elem2JsLike: Elem =\u0026gt; JsLike[Elem] = ??? It would certainly be nice, but unfortunately this is not that simple! 5, true and null are valid JSON values, So jsLike2Elem(Atom(Number(5))), jsLike2Elem(Atom(Bool(true))) and jsLike2Elem(Atom(Null))) should be valid XML value! But what should be the root tag of the resulting elements? How to translate 5 into a valid XML? We know that it would have the form:\n\u0026lt;someRootTag type=\u0026#34;number\u0026#34;\u0026gt;5\u0026lt;/someRootTag\u0026gt; But what someRootTag should be? We could pick an arbitrary one, but it would break composability (try it, you\u0026rsquo;ll see!). There\u0026rsquo;s no escape, all XML values need tags but not every JSON value have some! The situation suggest JSON values are closer to \u0026ldquo;XML values with unknown root tags\u0026rdquo; \u0026lt;X type=\u0026quot;number\u0026quot;\u0026gt;5\u0026lt;/X\u0026gt; where X as the unknown, i.e. the functional space String =\u0026gt; Elem:\nval _5: String =\u0026gt; Elem = (someRootTag: String) =\u0026gt; \u0026lt;someRootTag type=\u0026#34;number\u0026#34;\u0026gt;5\u0026lt;/someRootTag\u0026gt; Do you think we can define meaningful functions?\nval jsLike2xml: JsLike[String =\u0026gt; Elem] =\u0026gt; (String =\u0026gt; Elem) = ??? val xml2JsLike: (String =\u0026gt; Elem) =\u0026gt; JsLike[String =\u0026gt; Elem] = ??? Yes we can \u0026hellip; partially. We can define jsLike2xml:\nval jsLike2xml: JsLike[String =\u0026gt; Elem] =\u0026gt; (String =\u0026gt; Elem) = { def mkRoot(jsType: String, children: Node*): String =\u0026gt; Elem = (someRootTag: String) =\u0026gt; Elem(null, someRootTag, new UnprefixedAttribute(\u0026#34;type\u0026#34;, jsType, scala.xml.Null), TopScope, true, children: _* ) (j: JsLike[String =\u0026gt; Elem]) =\u0026gt; j match { case Atom(Null) =\u0026gt; mkRoot(\u0026#34;null\u0026#34;) case Atom(Str(s)) =\u0026gt; mkRoot(\u0026#34;string\u0026#34;, PCData(s)) case Atom(Bool(b)) =\u0026gt; mkRoot(\u0026#34;boolean\u0026#34;, Text(b.toString)) case Atom(Number(n)) =\u0026gt; mkRoot(\u0026#34;number\u0026#34;, Text(n.toString)) case Arr(a) =\u0026gt; (root: String) =\u0026gt; { mkRoot(\u0026#34;array\u0026#34;, a.map(_(s\u0026#34;${root}Item\u0026#34;)): _*)(root) } case Obj(m) =\u0026gt; mkRoot(\u0026#34;object\u0026#34;, m.toList.map { case (k, v) =\u0026gt; v(k) }: _*) } } but for xml2JsLike, we\u0026rsquo;re facing two not-that-small issues:\n First, unlikejsValue2JsLike, we can not pattern-match on functions. We have no sane way to know that\n(someRootTag: String) =\u0026gt; \u0026lt;someRootTag type=\u0026#34;number\u0026#34;\u0026gt;5\u0026lt;/someRootTag\u0026gt;  is built from Atom(Number(5)).\n Even if we could pattern-match on functions, jsLike2xml is not surjective, i.e. not every XML element is the result of jsLike2xml(f) for some f. To deal with invalid input, the return type of xml2JsLike can not be JsLike[String =\u0026gt; Elem] but F[JsLike[String =\u0026gt; Elem]] for some functor F able to deal with errors like Option, Either, etc. For simplicity\u0026rsquo;s sake, let\u0026rsquo;s consider F to be Option.  Let\u0026rsquo;s once again take a step back. We want to decompose a function (f: String =\u0026gt; Elem) into an Option[JsLike[String =\u0026gt; Elem]] without pattern-matching it. The only reasonable thing we can do with functions is pass them some arguments:\ndef xml2JsLike(f: (String =\u0026gt; Elem)): String =\u0026gt; Option[JsLike[Elem =\u0026gt; String]] = (someRootTag: String) =\u0026gt; ... f(someRootTag) ... The type String =\u0026gt; Option[A] is actually a monad, known as a ReaderT[Option, String, A]. Which makes xml2JsLike a monadic coalgebra. Let\u0026rsquo;s give it a name:\nimport cats.data.ReaderT type TagOpt[A] = ReaderT[Option, String, A] As an exercise try to implement xml2JsLike. *To that end, it may be useful to notice that JsLike is a Traverse, i.e. that an instance of Traverse[JsLike] can be defined. Such an instance defines a function:\ndef `traverse[G[_]: Applicative, A, B](ja: JsLike[A])(f: A =\u0026gt; G[B]): G[JsLike[B]]` To summarize this part, we have these four functions:\nval jsLike2JsValue: JsLike[JsValue] =\u0026gt; JsValue val jsValue2JsLike: JsValue =\u0026gt; JsLike[JsValue] val jsLike2xml: JsLike[String =\u0026gt; Elem] =\u0026gt; (String =\u0026gt; Elem) val xml2JsLike: (String =\u0026gt; Elem) =\u0026gt; TagOpt[JsLike[String =\u0026gt; Elem]] Now we want to convert JsValue from/into String =\u0026gt; Elem.\nConverting back and forth Now that we know how to compose and decompose both JSON and XML values. How do we write converters? For simplify\u0026rsquo;s sake, let\u0026rsquo;s be a bit more abstract. Let A and B be to types (like JsValue and String =\u0026gt; Elem) and F[_] a type constructor (like JsLike) that have the nice property of being a functor (i.e. it has function map: F[A] =\u0026gt; (A =\u0026gt; B) =\u0026gt; F[B]). In addition, let decomposeA: A =\u0026gt; F[A] and recomposeB: F[B] =\u0026gt; B (like jsValue2JsLike and jsLike2xml). We want a function convert: A =\u0026gt; B:\ntrait Direct { import cats.Functor import cats.syntax.functor._ type A type B type F[_] implicit val fHasMap: Functor[F] val decomposeA: A =\u0026gt; F[A] val recomposeB: F[B] =\u0026gt; B final def convert(a: A): B = { val fa: F[A] = decomposeA(a) val fb: F[B] = fa.map(convert) recomposeB(fb): B } } Or in a more compact way:\ndef hylo[A,B, F[_]: Functor](decompose: A =\u0026gt; F[A], recompose: F[B] =\u0026gt; B): A =\u0026gt; B = { def convert(a: A): B = recompose(decompose(a).map(convert)) convert _ } And voila, a converter in just 1 lines of code:\ndef json2xml(json: JsValue): String =\u0026gt; Elem = hylo(jsValue2JsLike, jsLike2xml).apply(json) The way back is only a bit more involving. This time we require F to be Traverse and the function decomposeA to be of type A =\u0026gt; M[F[A]] for some monad M:\ntrait WayBack { type A type B type F[_] implicit val fHasTraverse: Traverse[F] type M[_] implicit val mIsAMonad: Monad[M] val decomposeA: A =\u0026gt; M[F[A]] val recomposeB: F[B] =\u0026gt; B final def convert(a: A): M[B] = for { fa \u0026lt;- decomposeA(a) fb \u0026lt;- fa.traverse(convert) } yield recomposeB(fb) } Again, in a more compact way:\ndef hyloish[A,B, F[_]: Traverse, M[_]: Monad](decompose: A =\u0026gt; M[F[A]], recompose: F[B] =\u0026gt; B): A =\u0026gt; M[B] = { def convert(a: A): M[B] = for { fa \u0026lt;- decompose(a) fb \u0026lt;- fa.traverse(convert) } yield recompose(fb) convert _ } which gives the way back as the oneliner:\ndef xml2json(f: String =\u0026gt; Elem): TagOpt[JsValue] = hyloish(xml2JsLike, jsLike2JsValue).apply(f) Reorganizing a bit, it leads to the two conversion functions between (String, JsValue) and Elem:\nval json2xmlBetter: ((String, JsValue)) =\u0026gt; Elem = (jsonPlusTag: (String, JsValue)) =\u0026gt; json2xml(jsonPlusTag._2)(jsonPlusTag._1) val xml2jsonBetter: Elem =\u0026gt; TagOpt[(String, JsValue)] = (e: Elem) =\u0026gt; xml2json((s: String) =\u0026gt; e.copy(label = s)).map(e.label -\u0026gt; _) What\u0026rsquo;s the point? Apart from being so much more complicated that the trivial approach, is there some benefits? Actually yes.\n Firstly, given n formats, there are n² converters. Writing and testing n² functions is a lot of tedious and error-prone work. But if you find some common operations F[_], you only need 2n functions (one X =\u0026gt; F[X] and one F[X] =\u0026gt; X for each format X) to achieve the same goal. Furthermore, each of those functions will be easier to test, which is not to neglect. Secondly, algebras (functions X =\u0026gt; F[X]) and coalgebras (functions F[X] =\u0026gt; X) operate one level at a time. They enable to treat format X as if it was an algebraic data type over operations F. Pattern-matching is such a nice feature! Thirdly, you can write generic functions taking any type X for which you can provide functions X =\u0026gt; F[X] and F[X] =\u0026gt; X. These functions also have higher chances of being correct because there is less space for unexpected behaviour.  If want to dive deeper in this subject, you can look at Matryoshka, read Functional programming with bananas, lenses, envelopes and barbed wire or any resource on F-Algebras and recursion schemes.\nSolution to exercises JsLike instance for Traverse implicit val jsLikeInstances: Traverse[JsLike] = new Traverse[JsLike] { import cats.Eval def traverse[G[_], A, B](fa: JsLike[A])(f: A =\u0026gt; G[B])( implicit G: Applicative[G]): G[JsLike[B]] = fa match { case Atom(a) =\u0026gt; G.point(Atom(a)) case Arr(a) =\u0026gt; a.traverse[G, B](f).map(Arr(_)) case Obj(m) =\u0026gt; m.toList .traverse[G, (String, B)] { case (s, a) =\u0026gt; f(a).map(s -\u0026gt; _) } .map(i =\u0026gt; Obj(i.toMap)) } def foldLeft[A, B](fa: JsLike[A], b: B)(f: (B, A) =\u0026gt; B): B = fa match { case Atom(_) =\u0026gt; b case Arr(a) =\u0026gt; a.foldLeft(b)(f) case Obj(m) =\u0026gt; m.values.foldLeft(b)(f) } def foldRight[A, B](fa: JsLike[A], lb: Eval[B])( f: (A, Eval[B]) =\u0026gt; Eval[B]): Eval[B] = fa match { case Atom(_) =\u0026gt; lb case Arr(a) =\u0026gt; a.foldRight(lb)(f) case Obj(m) =\u0026gt; m.values.foldRight(lb)(f) } } xml2JsLike def xml2JsLike(f: String =\u0026gt; Elem): TagOpt[JsLike[String =\u0026gt; Elem]] = ReaderT[Option, String, JsLike[String =\u0026gt; Elem]] { (s: String) =\u0026gt; val elem: Elem = f(s) elem .attributes .asAttrMap .get(\u0026#34;type\u0026#34;) .flatMap[JsLike[String =\u0026gt; Elem]] { case \u0026#34;null\u0026#34; =\u0026gt; Some(Atom(Null)) case \u0026#34;boolean\u0026#34; =\u0026gt; elem.text match { case \u0026#34;true\u0026#34; =\u0026gt; Some(Atom(Bool(true))) case \u0026#34;false\u0026#34; =\u0026gt; Some(Atom(Bool(false))) case _ =\u0026gt; None } case \u0026#34;number\u0026#34; =\u0026gt; import scala.util.Try Try(BigDecimal(elem.text)) .toOption .map(n =\u0026gt; Atom(Number(n))) case \u0026#34;string\u0026#34; =\u0026gt; Some(Atom(Str(elem.text))) case \u0026#34;array\u0026#34; =\u0026gt; Some(Arr( elem .child .toList .flatMap { case e: Elem =\u0026gt; List((s: String) =\u0026gt; e.copy(label = s)) case _ =\u0026gt; Nil } )) case \u0026#34;object\u0026#34; =\u0026gt; Some(Obj( elem .child .toList .flatMap { case e: Elem =\u0026gt; List(e.label -\u0026gt; ((s: String) =\u0026gt; e.copy(label = s))) case _ =\u0026gt; Nil }.toMap )) case _ =\u0026gt; None } }"
},
{
	"uri": "https://chrilves.github.io/posts/falgebra_scalaio_2017/",
	"title": "F-Algebra talk at ScalaIO 2017: Modéliser astucieusement vos données",
	"tags": [],
	"description": "ScalaIO.2017 Talk",
	"content": " I had the chance to present a talk about F-Algebras at ScalaIO 2017.\nThe Video  The Slides  "
},
{
	"uri": "https://chrilves.github.io/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://chrilves.github.io/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]